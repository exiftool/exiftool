{"version":3,"file":"observers.mjs","sources":["../../../../../src/motion/features/viewport/observers.ts"],"sourcesContent":["type IntersectionHandler = (entry: IntersectionObserverEntry) => void\n\ninterface ElementIntersectionObservers {\n    [key: string]: IntersectionObserver\n}\n\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap<Element, IntersectionHandler>()\n\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap<\n    Element | Document,\n    ElementIntersectionObservers\n>()\n\nconst fireObserverCallback = (entry: IntersectionObserverEntry) => {\n    const callback = observerCallbacks.get(entry.target)\n    callback && callback(entry)\n}\n\nconst fireAllObserverCallbacks: IntersectionObserverCallback = (entries) => {\n    entries.forEach(fireObserverCallback)\n}\n\nfunction initIntersectionObserver({\n    root,\n    ...options\n}: IntersectionObserverInit): IntersectionObserver {\n    const lookupRoot = root || document\n\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {})\n    }\n    const rootObservers = observers.get(lookupRoot)!\n\n    const key = JSON.stringify(options)\n\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(\n            fireAllObserverCallbacks,\n            { root, ...options }\n        )\n    }\n\n    return rootObservers[key]\n}\n\nexport function observeIntersection(\n    element: Element,\n    options: IntersectionObserverInit,\n    callback: IntersectionHandler\n) {\n    const rootInteresectionObserver = initIntersectionObserver(options)\n\n    observerCallbacks.set(element, callback)\n    rootInteresectionObserver.observe(element)\n\n    return () => {\n        observerCallbacks.delete(element)\n        rootInteresectionObserver.unobserve(element)\n    }\n}\n"],"names":[],"mappings":"AAMA;;;;AAIG;AACH,MAAM,iBAAiB,GAAG,IAAI,OAAO,EAAgC,CAAA;AAErE;;;;AAIG;AACH,MAAM,SAAS,GAAG,IAAI,OAAO,EAG1B,CAAA;AAEH,MAAM,oBAAoB,GAAG,CAAC,KAAgC,KAAI;IAC9D,MAAM,QAAQ,GAAG,iBAAiB,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA;AACpD,IAAA,QAAQ,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAA;AAC/B,CAAC,CAAA;AAED,MAAM,wBAAwB,GAAiC,CAAC,OAAO,KAAI;AACvE,IAAA,OAAO,CAAC,OAAO,CAAC,oBAAoB,CAAC,CAAA;AACzC,CAAC,CAAA;AAED,SAAS,wBAAwB,CAAC,EAC9B,IAAI,EACJ,GAAG,OAAO,EACa,EAAA;AACvB,IAAA,MAAM,UAAU,GAAG,IAAI,IAAI,QAAQ,CAAA;AAEnC;;AAEG;IACH,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;AAC5B,QAAA,SAAS,CAAC,GAAG,CAAC,UAAU,EAAE,EAAE,CAAC,CAAA;KAChC;IACD,MAAM,aAAa,GAAG,SAAS,CAAC,GAAG,CAAC,UAAU,CAAE,CAAA;IAEhD,MAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAA;AAEnC;;;AAGG;AACH,IAAA,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,EAAE;AACrB,QAAA,aAAa,CAAC,GAAG,CAAC,GAAG,IAAI,oBAAoB,CACzC,wBAAwB,EACxB,EAAE,IAAI,EAAE,GAAG,OAAO,EAAE,CACvB,CAAA;KACJ;AAED,IAAA,OAAO,aAAa,CAAC,GAAG,CAAC,CAAA;AAC7B,CAAC;SAEe,mBAAmB,CAC/B,OAAgB,EAChB,OAAiC,EACjC,QAA6B,EAAA;AAE7B,IAAA,MAAM,yBAAyB,GAAG,wBAAwB,CAAC,OAAO,CAAC,CAAA;AAEnE,IAAA,iBAAiB,CAAC,GAAG,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAA;AACxC,IAAA,yBAAyB,CAAC,OAAO,CAAC,OAAO,CAAC,CAAA;AAE1C,IAAA,OAAO,MAAK;AACR,QAAA,iBAAiB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAA;AACjC,QAAA,yBAAyB,CAAC,SAAS,CAAC,OAAO,CAAC,CAAA;AAChD,KAAC,CAAA;AACL;;;;"}