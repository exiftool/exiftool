{"version":3,"file":"LayoutAnimationBuilder.mjs","sources":["../../../src/layout/LayoutAnimationBuilder.ts"],"sourcesContent":["import { noop } from \"motion-utils\"\nimport type { AnimationOptions } from \"../animation/types\"\nimport { GroupAnimation, type AcceptedAnimations } from \"../animation/GroupAnimation\"\nimport { getLayoutElements } from \"./get-layout-elements\"\nimport {\n    buildProjectionTree,\n    cleanupProjectionTree,\n    type ProjectionContext,\n    type BuildProjectionTreeOptions,\n} from \"./projection-tree\"\nimport { resolveElements, type ElementOrSelector } from \"../utils/resolve-elements\"\nimport { frame } from \"../frameloop\"\n\nexport class LayoutAnimationBuilder implements PromiseLike<GroupAnimation> {\n    private scope: Element | Document\n    private updateDom: () => void\n    private defaultOptions?: AnimationOptions\n\n    private sharedTransitions = new Map<string, AnimationOptions>()\n\n    private notifyReady: (value: GroupAnimation) => void = noop\n    private readyPromise: Promise<GroupAnimation>\n    private executed = false\n\n    constructor(\n        scope: Element | Document,\n        updateDom: () => void,\n        defaultOptions?: AnimationOptions\n    ) {\n        this.scope = scope\n        this.updateDom = updateDom\n        this.defaultOptions = defaultOptions\n\n        this.readyPromise = new Promise<GroupAnimation>((resolve) => {\n            this.notifyReady = resolve\n        })\n\n        // Queue execution on microtask to allow builder methods to be called\n        queueMicrotask(() => this.execute())\n    }\n\n    shared(id: string, options: AnimationOptions): this {\n        this.sharedTransitions.set(id, options)\n        return this\n    }\n\n    then<TResult1 = GroupAnimation, TResult2 = never>(\n        onfulfilled?:\n            | ((value: GroupAnimation) => TResult1 | PromiseLike<TResult1>)\n            | null,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null\n    ): Promise<TResult1 | TResult2> {\n        return this.readyPromise.then(onfulfilled, onrejected)\n    }\n\n    private async execute() {\n        if (this.executed) return\n        this.executed = true\n\n        let context: ProjectionContext | undefined\n\n        // Phase 1: Pre-mutation - Build projection tree and take snapshots\n        const beforeElements = getLayoutElements(this.scope)\n\n        if (beforeElements.length > 0) {\n            context = buildProjectionTree(\n                beforeElements,\n                undefined,\n                this.getBuildOptions()\n            )\n\n            context.root.startUpdate()\n\n            for (const node of context.nodes.values()) {\n                node.isLayoutDirty = false\n                node.willUpdate()\n            }\n        }\n\n        // Phase 2: Execute DOM update\n        this.updateDom()\n\n        // Phase 3: Post-mutation - Compare before/after elements\n        const afterElements = getLayoutElements(this.scope)\n        const beforeSet = new Set(beforeElements)\n        const afterSet = new Set(afterElements)\n\n        const entering = afterElements.filter((el) => !beforeSet.has(el))\n        const exiting = beforeElements.filter((el) => !afterSet.has(el))\n\n        // Build projection nodes for entering elements\n        if (entering.length > 0) {\n            context = buildProjectionTree(\n                entering,\n                context,\n                this.getBuildOptions()\n            )\n        }\n\n        // No layout elements - return empty animation\n        if (!context) {\n            this.notifyReady(new GroupAnimation([]))\n            return\n        }\n\n        // Handle shared elements\n        for (const element of exiting) {\n            const node = context.nodes.get(element)\n            node?.getStack()?.remove(node)\n        }\n\n        for (const element of entering) {\n            context.nodes.get(element)?.promote()\n        }\n\n        // Phase 4: Animate\n        context.root.didUpdate()\n\n        await new Promise<void>((resolve) =>\n            frame.postRender(() => resolve())\n        )\n\n        const animations: AcceptedAnimations[] = []\n        for (const node of context.nodes.values()) {\n            if (node.currentAnimation) {\n                animations.push(node.currentAnimation)\n            }\n        }\n\n        const groupAnimation = new GroupAnimation(animations)\n\n        groupAnimation.finished.then(() => {\n            // Only clean up nodes for elements no longer in the document.\n            // Elements still in DOM keep their nodes so subsequent animations\n            // can use the stored position snapshots (A→B→A pattern).\n            const elementsToCleanup = new Set<HTMLElement>()\n            for (const element of context!.nodes.keys()) {\n                if (!document.contains(element)) {\n                    elementsToCleanup.add(element)\n                }\n            }\n            cleanupProjectionTree(context!, elementsToCleanup)\n        })\n\n        this.notifyReady(groupAnimation)\n    }\n\n    private getBuildOptions(): BuildProjectionTreeOptions {\n        return {\n            defaultTransition: this.defaultOptions || {\n                duration: 0.3,\n                ease: \"easeOut\",\n            },\n            sharedTransitions:\n                this.sharedTransitions.size > 0\n                    ? this.sharedTransitions\n                    : undefined,\n        }\n    }\n\n}\n\n/**\n * Parse arguments for animateLayout overloads\n */\nexport function parseAnimateLayoutArgs(\n    scopeOrUpdateDom: ElementOrSelector | (() => void),\n    updateDomOrOptions?: (() => void) | AnimationOptions,\n    options?: AnimationOptions\n): {\n    scope: Element | Document\n    updateDom: () => void\n    defaultOptions?: AnimationOptions\n} {\n    // animateLayout(updateDom)\n    if (typeof scopeOrUpdateDom === \"function\") {\n        return {\n            scope: document,\n            updateDom: scopeOrUpdateDom,\n            defaultOptions: updateDomOrOptions as AnimationOptions | undefined,\n        }\n    }\n\n    // animateLayout(scope, updateDom, options?)\n    const elements = resolveElements(scopeOrUpdateDom)\n    const scope = elements[0] || document\n\n    return {\n        scope: scope instanceof Document ? scope : scope,\n        updateDom: updateDomOrOptions as () => void,\n        defaultOptions: options,\n    }\n}\n"],"names":[],"mappings":"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"}