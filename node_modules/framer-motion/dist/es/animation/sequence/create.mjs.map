{"version":3,"file":"create.mjs","sources":["../../../../src/animation/sequence/create.ts"],"sourcesContent":["import {\n    AnimationScope,\n    createGeneratorEasing,\n    defaultOffset,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    fillOffset,\n    GeneratorFactory,\n    isGenerator,\n    isMotionValue,\n    Transition,\n    UnresolvedValueKeyframe,\n    type AnyResolvedKeyframe,\n    type MotionValue,\n} from \"motion-dom\"\nimport {\n    Easing,\n    getEasingForSegment,\n    invariant,\n    progress,\n    secondsToMilliseconds,\n} from \"motion-utils\"\nimport { resolveSubjects } from \"../animate/resolve-subjects\"\nimport {\n    AnimationSequence,\n    At,\n    ResolvedAnimationDefinitions,\n    SequenceMap,\n    SequenceOptions,\n    ValueSequence,\n} from \"./types\"\nimport { calculateRepeatDuration } from \"./utils/calc-repeat-duration\"\nimport { calcNextTime } from \"./utils/calc-time\"\nimport { addKeyframes } from \"./utils/edit\"\nimport { normalizeTimes } from \"./utils/normalize-times\"\nimport { compareByTime } from \"./utils/sort\"\n\nconst defaultSegmentEasing = \"easeInOut\"\n\nconst MAX_REPEAT = 20\n\nexport function createAnimationsFromSequence(\n    sequence: AnimationSequence,\n    { defaultTransition = {}, ...sequenceTransition }: SequenceOptions = {},\n    scope?: AnimationScope,\n    generators?: { [key: string]: GeneratorFactory }\n): ResolvedAnimationDefinitions {\n    const defaultDuration = defaultTransition.duration || 0.3\n    const animationDefinitions: ResolvedAnimationDefinitions = new Map()\n    const sequences = new Map<Element | MotionValue, SequenceMap>()\n    const elementCache = {}\n    const timeLabels = new Map<string, number>()\n\n    let prevTime = 0\n    let currentTime = 0\n    let totalDuration = 0\n\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i]\n\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime)\n            continue\n        } else if (!Array.isArray(segment)) {\n            timeLabels.set(\n                segment.name,\n                calcNextTime(currentTime, segment.at, prevTime, timeLabels)\n            )\n            continue\n        }\n\n        let [subject, keyframes, transition = {}] = segment\n\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(\n                currentTime,\n                transition.at,\n                prevTime,\n                timeLabels\n            )\n        }\n\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0\n\n        const resolveValueSequence = (\n            valueKeyframes: UnresolvedValueKeyframe | UnresolvedValueKeyframe[],\n            valueTransition: Transition | DynamicAnimationOptions,\n            valueSequence: ValueSequence,\n            elementIndex = 0,\n            numSubjects = 0\n        ) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes)\n            const {\n                delay = 0,\n                times = defaultOffset(valueKeyframesAsList),\n                type = \"keyframes\",\n                repeat,\n                repeatType,\n                repeatDelay = 0,\n                ...remainingTransition\n            } = valueTransition\n            let { ease = defaultTransition.ease || \"easeOut\", duration } =\n                valueTransition\n\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay =\n                typeof delay === \"function\"\n                    ? delay(elementIndex, numSubjects)\n                    : delay\n\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length\n            const createGenerator = isGenerator(type)\n                ? type\n                : generators?.[type || \"keyframes\"]\n\n            if (numKeyframes <= 2 && createGenerator) {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100\n                if (\n                    numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)\n                ) {\n                    const delta =\n                        valueKeyframesAsList[1] - valueKeyframesAsList[0]\n                    absoluteDelta = Math.abs(delta)\n                }\n\n                const springTransition = { ...remainingTransition }\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration)\n                }\n\n                const springEasing = createGeneratorEasing(\n                    springTransition,\n                    absoluteDelta,\n                    createGenerator\n                )\n\n                ease = springEasing.ease\n                duration = springEasing.duration\n            }\n\n            duration ??= defaultDuration\n\n            const startTime = currentTime + calculatedDelay\n\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1\n            }\n\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length\n            remainder > 0 && fillOffset(times, remainder)\n\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null)\n\n            /**\n             * Handle repeat options\n             */\n            if (repeat) {\n                invariant(\n                    repeat < MAX_REPEAT,\n                    \"Repeat count too high, must be less than 20\",\n                    \"repeat-count-high\"\n                )\n\n                duration = calculateRepeatDuration(\n                    duration,\n                    repeat,\n                    repeatDelay\n                )\n\n                const originalKeyframes = [...valueKeyframesAsList]\n                const originalTimes = [...times]\n                ease = Array.isArray(ease) ? [...ease] : [ease]\n                const originalEase = [...ease]\n\n                for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\n                    valueKeyframesAsList.push(...originalKeyframes)\n\n                    for (\n                        let keyframeIndex = 0;\n                        keyframeIndex < originalKeyframes.length;\n                        keyframeIndex++\n                    ) {\n                        times.push(\n                            originalTimes[keyframeIndex] + (repeatIndex + 1)\n                        )\n                        ease.push(\n                            keyframeIndex === 0\n                                ? \"linear\"\n                                : getEasingForSegment(\n                                      originalEase,\n                                      keyframeIndex - 1\n                                  )\n                        )\n                    }\n                }\n\n                normalizeTimes(times, repeat)\n            }\n\n            const targetTime = startTime + duration\n\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(\n                valueSequence,\n                valueKeyframesAsList,\n                ease as Easing | Easing[],\n                times,\n                startTime,\n                targetTime\n            )\n\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration)\n            totalDuration = Math.max(targetTime, totalDuration)\n        }\n\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences)\n            resolveValueSequence(\n                keyframes as AnyResolvedKeyframe,\n                transition,\n                getValueSequence(\"default\", subjectSequence)\n            )\n        } else {\n            const subjects = resolveSubjects(\n                subject,\n                keyframes as DOMKeyframesDefinition,\n                scope,\n                elementCache\n            )\n\n            const numSubjects = subjects.length\n\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (\n                let subjectIndex = 0;\n                subjectIndex < numSubjects;\n                subjectIndex++\n            ) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes as DOMKeyframesDefinition\n                transition = transition as DynamicAnimationOptions\n\n                const thisSubject = subjects[subjectIndex]\n                const subjectSequence = getSubjectSequence(\n                    thisSubject,\n                    sequences\n                )\n\n                for (const key in keyframes) {\n                    resolveValueSequence(\n                        keyframes[\n                            key as keyof typeof keyframes\n                        ] as UnresolvedValueKeyframe,\n                        getValueTransition(transition, key),\n                        getValueSequence(key, subjectSequence),\n                        subjectIndex,\n                        numSubjects\n                    )\n                }\n            }\n        }\n\n        prevTime = currentTime\n        currentTime += maxDuration\n    }\n\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key]\n\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime)\n\n            const keyframes: UnresolvedValueKeyframe[] = []\n            const valueOffset: number[] = []\n            const valueEasing: Easing[] = []\n\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i]\n                keyframes.push(value)\n                valueOffset.push(progress(0, totalDuration, at))\n                valueEasing.push(easing || \"easeOut\")\n            }\n\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0)\n                keyframes.unshift(keyframes[0])\n                valueEasing.unshift(defaultSegmentEasing)\n            }\n\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1)\n                keyframes.push(null)\n            }\n\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                })\n            }\n\n            const definition = animationDefinitions.get(element)!\n\n            definition.keyframes[key] = keyframes\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            }\n        }\n    })\n\n    return animationDefinitions\n}\n\nfunction getSubjectSequence<O extends {}>(\n    subject: Element | MotionValue | O,\n    sequences: Map<Element | MotionValue | O, SequenceMap>\n): SequenceMap {\n    !sequences.has(subject) && sequences.set(subject, {})\n    return sequences.get(subject)!\n}\n\nfunction getValueSequence(name: string, sequences: SequenceMap): ValueSequence {\n    if (!sequences[name]) sequences[name] = []\n    return sequences[name]\n}\n\nfunction keyframesAsList(\n    keyframes: UnresolvedValueKeyframe | UnresolvedValueKeyframe[]\n): UnresolvedValueKeyframe[] {\n    return Array.isArray(keyframes) ? keyframes : [keyframes]\n}\n\nexport function getValueTransition(\n    transition: DynamicAnimationOptions & At,\n    key: string\n): DynamicAnimationOptions {\n    return transition && transition[key as keyof typeof transition]\n        ? {\n              ...transition,\n              ...(transition[key as keyof typeof transition] as Transition),\n          }\n        : { ...transition }\n}\n\nconst isNumber = (keyframe: unknown) => typeof keyframe === \"number\"\nconst isNumberKeyframesArray = (\n    keyframes: UnresolvedValueKeyframe[]\n): keyframes is number[] => keyframes.every(isNumber)\n"],"names":[],"mappings":"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"}