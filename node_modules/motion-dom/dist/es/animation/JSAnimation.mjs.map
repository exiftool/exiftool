{"version":3,"file":"JSAnimation.mjs","sources":["../../../src/animation/JSAnimation.ts"],"sourcesContent":["import {\n    clamp,\n    invariant,\n    millisecondsToSeconds,\n    pipe,\n    secondsToMilliseconds,\n} from \"motion-utils\"\nimport { time } from \"../frameloop/sync-time\"\nimport { activeAnimations } from \"../stats/animation-count\"\nimport { mix } from \"../utils/mix\"\nimport { Mixer } from \"../utils/mix/types\"\nimport { frameloopDriver } from \"./drivers/frame\"\nimport { DriverControls } from \"./drivers/types\"\nimport { inertia } from \"./generators/inertia\"\nimport { keyframes as keyframesGenerator } from \"./generators/keyframes\"\nimport { calcGeneratorDuration } from \"./generators/utils/calc-duration\"\nimport { getFinalKeyframe } from \"./keyframes/get-final\"\nimport {\n    AnimationPlaybackControlsWithThen,\n    AnimationState,\n    GeneratorFactory,\n    KeyframeGenerator,\n    TimelineWithFallback,\n    ValueAnimationOptions,\n} from \"./types\"\nimport { replaceTransitionType } from \"./utils/replace-transition-type\"\nimport { WithPromise } from \"./utils/WithPromise\"\n\nconst percentToProgress = (percent: number) => percent / 100\n\nexport class JSAnimation<T extends number | string>\n    extends WithPromise\n    implements AnimationPlaybackControlsWithThen\n{\n    state: AnimationPlayState = \"idle\"\n\n    startTime: number | null = null\n\n    /**\n     * The driver that's controlling the animation loop. Normally this is a requestAnimationFrame loop\n     * but in tests we can pass in a synchronous loop.\n     */\n    private driver?: DriverControls\n\n    private isStopped = false\n\n    private generator: KeyframeGenerator<T>\n\n    private calculatedDuration: number\n\n    private resolvedDuration: number\n\n    private totalDuration: number\n\n    private options: ValueAnimationOptions<T>\n\n    /**\n     * The current time of the animation.\n     */\n    private currentTime: number = 0\n\n    /**\n     * The time at which the animation was paused.\n     */\n    private holdTime: number | null = null\n\n    /**\n     * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n     */\n    private playbackSpeed = 1\n\n    /*\n     * If our generator doesn't support mixing numbers, we need to replace keyframes with\n     * [0, 100] and then make a function that maps that to the actual keyframes.\n     *\n     * 100 is chosen instead of 1 as it works nicer with spring animations.\n     */\n    private mixKeyframes: Mixer<T> | undefined\n\n    private mirroredGenerator: KeyframeGenerator<T> | undefined\n\n    constructor(options: ValueAnimationOptions<T>) {\n        super()\n        activeAnimations.mainThread++\n\n        this.options = options\n        this.initAnimation()\n        this.play()\n\n        if (options.autoplay === false) this.pause()\n    }\n\n    initAnimation() {\n        const { options } = this\n\n        replaceTransitionType(options)\n\n        const {\n            type = keyframesGenerator,\n            repeat = 0,\n            repeatDelay = 0,\n            repeatType,\n            velocity = 0,\n        } = options\n        let { keyframes } = options\n\n        const generatorFactory =\n            (type as GeneratorFactory) || keyframesGenerator\n\n        if (\n            process.env.NODE_ENV !== \"production\" &&\n            generatorFactory !== keyframesGenerator\n        ) {\n            invariant(\n                keyframes.length <= 2,\n                `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes}`,\n                \"spring-two-frames\"\n            )\n        }\n\n        if (\n            generatorFactory !== keyframesGenerator &&\n            typeof keyframes[0] !== \"number\"\n        ) {\n            this.mixKeyframes = pipe(\n                percentToProgress,\n                mix(keyframes[0], keyframes[1])\n            ) as (t: number) => T\n\n            keyframes = [0 as T, 100 as T]\n        }\n\n        const generator = generatorFactory({ ...options, keyframes })\n\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === \"mirror\") {\n            this.mirroredGenerator = generatorFactory({\n                ...options,\n                keyframes: [...keyframes].reverse(),\n                velocity: -velocity,\n            })\n        }\n\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator)\n        }\n\n        const { calculatedDuration } = generator\n        this.calculatedDuration = calculatedDuration\n        this.resolvedDuration = calculatedDuration + repeatDelay\n        this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay\n        this.generator = generator\n    }\n\n    updateTime(timestamp: number) {\n        const animationTime =\n            Math.round(timestamp - this.startTime!) * this.playbackSpeed\n\n        // Update currentTime\n        if (this.holdTime !== null) {\n            this.currentTime = this.holdTime\n        } else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime = animationTime\n        }\n    }\n\n    tick(timestamp: number, sample = false) {\n        const {\n            generator,\n            totalDuration,\n            mixKeyframes,\n            mirroredGenerator,\n            resolvedDuration,\n            calculatedDuration,\n        } = this\n\n        if (this.startTime === null) return generator.next(0)\n\n        const {\n            delay = 0,\n            keyframes,\n            repeat,\n            repeatType,\n            repeatDelay,\n            type,\n            onUpdate,\n            finalKeyframe,\n        } = this.options\n\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp)\n        } else if (this.speed < 0) {\n            this.startTime = Math.min(\n                timestamp - totalDuration / this.speed,\n                this.startTime\n            )\n        }\n\n        if (sample) {\n            this.currentTime = timestamp\n        } else {\n            this.updateTime(timestamp)\n        }\n\n        // Rebase on delay\n        const timeWithoutDelay =\n            this.currentTime - delay * (this.playbackSpeed >= 0 ? 1 : -1)\n        const isInDelayPhase =\n            this.playbackSpeed >= 0\n                ? timeWithoutDelay < 0\n                : timeWithoutDelay > totalDuration\n        this.currentTime = Math.max(timeWithoutDelay, 0)\n\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === \"finished\" && this.holdTime === null) {\n            this.currentTime = totalDuration\n        }\n\n        let elapsed = this.currentTime\n        let frameGenerator = generator\n\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress =\n                Math.min(this.currentTime, totalDuration) / resolvedDuration\n\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress)\n\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0\n\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1\n            }\n\n            iterationProgress === 1 && currentIteration--\n\n            currentIteration = Math.min(currentIteration, repeat + 1)\n\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n\n            const isOddIteration = Boolean(currentIteration % 2)\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration\n                    }\n                } else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator!\n                }\n            }\n\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration\n        }\n\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed)\n\n        if (mixKeyframes) {\n            state.value = mixKeyframes(state.value as number)\n        }\n\n        let { done } = state\n\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.playbackSpeed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0\n        }\n\n        const isAnimationFinished =\n            this.holdTime === null &&\n            (this.state === \"finished\" || (this.state === \"running\" && done))\n\n        // TODO: The exception for inertia could be cleaner here\n        if (isAnimationFinished && type !== inertia) {\n            state.value = getFinalKeyframe(\n                keyframes,\n                this.options,\n                finalKeyframe,\n                this.speed\n            )\n        }\n\n        if (onUpdate) {\n            onUpdate(state.value)\n        }\n\n        if (isAnimationFinished) {\n            this.finish()\n        }\n\n        return state\n    }\n\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve: VoidFunction, reject?: VoidFunction) {\n        return this.finished.then(resolve, reject)\n    }\n\n    get duration() {\n        return millisecondsToSeconds(this.calculatedDuration)\n    }\n\n    get iterationDuration() {\n        const { delay = 0 } = this.options || {}\n        return this.duration + millisecondsToSeconds(delay)\n    }\n\n    get time() {\n        return millisecondsToSeconds(this.currentTime)\n    }\n\n    set time(newTime: number) {\n        newTime = secondsToMilliseconds(newTime)\n        this.currentTime = newTime\n\n        if (\n            this.startTime === null ||\n            this.holdTime !== null ||\n            this.playbackSpeed === 0\n        ) {\n            this.holdTime = newTime\n        } else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.playbackSpeed\n        }\n\n        this.driver?.start(false)\n    }\n\n    get speed() {\n        return this.playbackSpeed\n    }\n\n    set speed(newSpeed: number) {\n        this.updateTime(time.now())\n        const hasChanged = this.playbackSpeed !== newSpeed\n        this.playbackSpeed = newSpeed\n\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime)\n        }\n    }\n\n    play() {\n        if (this.isStopped) return\n\n        const { driver = frameloopDriver, startTime } = this.options\n\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp))\n        }\n\n        this.options.onPlay?.()\n\n        const now = this.driver.now()\n\n        if (this.state === \"finished\") {\n            this.updateFinished()\n            this.startTime = now\n        } else if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime\n        } else if (!this.startTime) {\n            this.startTime = startTime ?? now\n        }\n\n        if (this.state === \"finished\" && this.speed < 0) {\n            this.startTime += this.calculatedDuration\n        }\n\n        this.holdTime = null\n\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        this.state = \"running\"\n\n        this.driver.start()\n    }\n\n    pause() {\n        this.state = \"paused\"\n        this.updateTime(time.now())\n        this.holdTime = this.currentTime\n    }\n\n    /**\n     * This method is bound to the instance to fix a pattern where\n     * animation.stop is returned as a reference from a useEffect.\n     */\n    stop = () => {\n        const { motionValue } = this.options\n        if (motionValue && motionValue.updatedAt !== time.now()) {\n            this.tick(time.now())\n        }\n\n        this.isStopped = true\n        if (this.state === \"idle\") return\n        this.teardown()\n        this.options.onStop?.()\n    }\n\n    complete() {\n        if (this.state !== \"running\") {\n            this.play()\n        }\n\n        this.state = \"finished\"\n        this.holdTime = null\n    }\n\n    finish() {\n        this.notifyFinished()\n        this.teardown()\n        this.state = \"finished\"\n\n        this.options.onComplete?.()\n    }\n\n    cancel() {\n        this.holdTime = null\n        this.startTime = 0\n        this.tick(0)\n        this.teardown()\n        this.options.onCancel?.()\n    }\n\n    private teardown() {\n        this.state = \"idle\"\n        this.stopDriver()\n        this.startTime = this.holdTime = null\n        activeAnimations.mainThread--\n    }\n\n    private stopDriver() {\n        if (!this.driver) return\n        this.driver.stop()\n        this.driver = undefined\n    }\n\n    sample(sampleTime: number): AnimationState<T> {\n        this.startTime = 0\n        return this.tick(sampleTime, true)\n    }\n\n    attachTimeline(timeline: TimelineWithFallback): VoidFunction {\n        if (this.options.allowFlatten) {\n            this.options.type = \"keyframes\"\n            this.options.ease = \"linear\"\n            this.initAnimation()\n        }\n\n        this.driver?.stop()\n        return timeline.observe(this)\n    }\n}\n\n// Legacy function support\nexport function animateValue<T extends number | string>(\n    options: ValueAnimationOptions<T>\n) {\n    return new JSAnimation(options)\n}\n"],"names":["keyframesGenerator","keyframes"],"mappings":"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"}