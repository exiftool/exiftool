{"version":3,"file":"size-rollup-scroll.js","sources":["../../motion-utils/dist/es/clamp.mjs","../../motion-utils/dist/es/format-error-message.mjs","../../motion-utils/dist/es/errors.mjs","../../motion-utils/dist/es/global-config.mjs","../../motion-utils/dist/es/is-object.mjs","../../motion-utils/dist/es/memo.mjs","../../motion-utils/dist/es/noop.mjs","../../motion-utils/dist/es/pipe.mjs","../../motion-utils/dist/es/progress.mjs","../../motion-dom/dist/es/frameloop/order.mjs","../../motion-dom/dist/es/stats/buffer.mjs","../../motion-dom/dist/es/frameloop/batcher.mjs","../../motion-dom/dist/es/frameloop/render-step.mjs","../../motion-dom/dist/es/frameloop/frame.mjs","../../motion-dom/dist/es/animation/utils/is-css-variable.mjs","../../motion-dom/dist/es/value/types/numbers/index.mjs","../../motion-dom/dist/es/value/types/utils/sanitize.mjs","../../motion-dom/dist/es/value/types/utils/float-regex.mjs","../../motion-dom/dist/es/value/types/utils/single-color-regex.mjs","../../motion-dom/dist/es/value/types/color/utils.mjs","../../motion-dom/dist/es/value/types/utils/is-nullish.mjs","../../motion-dom/dist/es/value/types/color/rgba.mjs","../../motion-dom/dist/es/value/types/color/hex.mjs","../../motion-dom/dist/es/value/types/numbers/units.mjs","../../motion-dom/dist/es/value/types/color/hsla.mjs","../../motion-dom/dist/es/value/types/color/index.mjs","../../motion-dom/dist/es/value/types/utils/color-regex.mjs","../../motion-dom/dist/es/value/types/complex/index.mjs","../../motion-dom/dist/es/value/types/color/hsla-to-rgba.mjs","../../motion-dom/dist/es/utils/mix/immediate.mjs","../../motion-dom/dist/es/utils/mix/number.mjs","../../motion-dom/dist/es/utils/mix/color.mjs","../../motion-dom/dist/es/utils/mix/visibility.mjs","../../motion-dom/dist/es/utils/mix/complex.mjs","../../motion-dom/dist/es/utils/mix/index.mjs","../../motion-dom/dist/es/utils/interpolate.mjs","../../motion-dom/dist/es/animation/keyframes/offsets/default.mjs","../../motion-dom/dist/es/animation/keyframes/offsets/fill.mjs","../../motion-dom/dist/es/utils/supports/scroll-timeline.mjs","../../motion-dom/dist/es/utils/is-html-element.mjs","../../motion-dom/dist/es/resize/handle-element.mjs","../../motion-dom/dist/es/utils/is-svg-element.mjs","../../motion-dom/dist/es/utils/resolve-elements.mjs","../../motion-dom/dist/es/resize/handle-window.mjs","../../motion-dom/dist/es/scroll/observe.mjs","../lib/render/dom/scroll/info.js","../../motion-utils/dist/es/velocity-per-second.mjs","../lib/render/dom/scroll/offsets/edge.js","../lib/render/dom/scroll/offsets/offset.js","../lib/render/dom/scroll/offsets/presets.js","../lib/render/dom/scroll/offsets/index.js","../lib/render/dom/scroll/offsets/inset.js","../lib/render/dom/scroll/on-scroll-handler.js","../lib/render/dom/scroll/track.js","../../motion-dom/dist/es/resize/index.mjs","../lib/render/dom/scroll/utils/get-timeline.js","../lib/render/dom/scroll/index.js","../lib/render/dom/scroll/attach-function.js","../lib/render/dom/scroll/attach-animation.js"],"sourcesContent":["const clamp = (min, max, v) => {\n    if (v > max)\n        return max;\n    if (v < min)\n        return min;\n    return v;\n};\n\nexport { clamp };\n//# sourceMappingURL=clamp.mjs.map\n","function formatErrorMessage(message, errorCode) {\n    return errorCode\n        ? `${message}. For more information and steps for solving, visit https://motion.dev/troubleshooting/${errorCode}`\n        : message;\n}\n\nexport { formatErrorMessage };\n//# sourceMappingURL=format-error-message.mjs.map\n","import { formatErrorMessage } from './format-error-message.mjs';\n\nlet warning = () => { };\nlet invariant = () => { };\nif (typeof process !== \"undefined\" &&\n    process.env?.NODE_ENV !== \"production\") {\n    warning = (check, message, errorCode) => {\n        if (!check && typeof console !== \"undefined\") {\n            console.warn(formatErrorMessage(message, errorCode));\n        }\n    };\n    invariant = (check, message, errorCode) => {\n        if (!check) {\n            throw new Error(formatErrorMessage(message, errorCode));\n        }\n    };\n}\n\nexport { invariant, warning };\n//# sourceMappingURL=errors.mjs.map\n","const MotionGlobalConfig = {};\n\nexport { MotionGlobalConfig };\n//# sourceMappingURL=global-config.mjs.map\n","function isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\n\nexport { isObject };\n//# sourceMappingURL=is-object.mjs.map\n","/*#__NO_SIDE_EFFECTS__*/\nfunction memo(callback) {\n    let result;\n    return () => {\n        if (result === undefined)\n            result = callback();\n        return result;\n    };\n}\n\nexport { memo };\n//# sourceMappingURL=memo.mjs.map\n","/*#__NO_SIDE_EFFECTS__*/\nconst noop = (any) => any;\n\nexport { noop };\n//# sourceMappingURL=noop.mjs.map\n","/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\nconst combineFunctions = (a, b) => (v) => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\nexport { pipe };\n//# sourceMappingURL=pipe.mjs.map\n","/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\n/*#__NO_SIDE_EFFECTS__*/\nconst progress = (from, to, value) => {\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nexport { progress };\n//# sourceMappingURL=progress.mjs.map\n","const stepsOrder = [\n    \"setup\", // Compute\n    \"read\", // Read\n    \"resolveKeyframes\", // Write/Read/Write/Read\n    \"preUpdate\", // Compute\n    \"update\", // Compute\n    \"preRender\", // Compute\n    \"render\", // Write\n    \"postRender\", // Compute\n];\n\nexport { stepsOrder };\n//# sourceMappingURL=order.mjs.map\n","const statsBuffer = {\n    value: null,\n    addProjectionMetrics: null,\n};\n\nexport { statsBuffer };\n//# sourceMappingURL=buffer.mjs.map\n","import { MotionGlobalConfig } from 'motion-utils';\nimport { stepsOrder } from './order.mjs';\nimport { createRenderStep } from './render-step.mjs';\n\nconst maxElapsed = 40;\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n    let runNextFrame = false;\n    let useDefaultElapsed = true;\n    const state = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    const flagRunNextFrame = () => (runNextFrame = true);\n    const steps = stepsOrder.reduce((acc, key) => {\n        acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : undefined);\n        return acc;\n    }, {});\n    const { setup, read, resolveKeyframes, preUpdate, update, preRender, render, postRender, } = steps;\n    const processBatch = () => {\n        const timestamp = MotionGlobalConfig.useManualTiming\n            ? state.timestamp\n            : performance.now();\n        runNextFrame = false;\n        if (!MotionGlobalConfig.useManualTiming) {\n            state.delta = useDefaultElapsed\n                ? 1000 / 60\n                : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);\n        }\n        state.timestamp = timestamp;\n        state.isProcessing = true;\n        // Unrolled render loop for better per-frame performance\n        setup.process(state);\n        read.process(state);\n        resolveKeyframes.process(state);\n        preUpdate.process(state);\n        update.process(state);\n        preRender.process(state);\n        render.process(state);\n        postRender.process(state);\n        state.isProcessing = false;\n        if (runNextFrame && allowKeepAlive) {\n            useDefaultElapsed = false;\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const wake = () => {\n        runNextFrame = true;\n        useDefaultElapsed = true;\n        if (!state.isProcessing) {\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const schedule = stepsOrder.reduce((acc, key) => {\n        const step = steps[key];\n        acc[key] = (process, keepAlive = false, immediate = false) => {\n            if (!runNextFrame)\n                wake();\n            return step.schedule(process, keepAlive, immediate);\n        };\n        return acc;\n    }, {});\n    const cancel = (process) => {\n        for (let i = 0; i < stepsOrder.length; i++) {\n            steps[stepsOrder[i]].cancel(process);\n        }\n    };\n    return { schedule, cancel, state, steps };\n}\n\nexport { createRenderBatcher };\n//# sourceMappingURL=batcher.mjs.map\n","import { statsBuffer } from '../stats/buffer.mjs';\n\nfunction createRenderStep(runNextFrame, stepName) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Set();\n    let nextFrame = new Set();\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    let latestFrameData = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    let numCalls = 0;\n    function triggerCallback(callback) {\n        if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n        }\n        numCalls++;\n        callback(latestFrameData);\n    }\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (!queue.has(callback))\n                queue.add(callback);\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.delete(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            latestFrameData = frameData;\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Execute this frame\n            thisFrame.forEach(triggerCallback);\n            /**\n             * If we're recording stats then\n             */\n            if (stepName && statsBuffer.value) {\n                statsBuffer.value.frameloop[stepName].push(numCalls);\n            }\n            numCalls = 0;\n            // Clear the frame so no callbacks remain. This is to avoid\n            // memory leaks should this render step not run for a while.\n            thisFrame.clear();\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nexport { createRenderStep };\n//# sourceMappingURL=render-step.mjs.map\n","import { noop } from 'motion-utils';\nimport { createRenderBatcher } from './batcher.mjs';\n\nconst { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : noop, true);\n\nexport { cancelFrame, frame, frameData, frameSteps };\n//# sourceMappingURL=frame.mjs.map\n","const checkStringStartsWith = (token) => (key) => typeof key === \"string\" && key.startsWith(token);\nconst isCSSVariableName = \n/*@__PURE__*/ checkStringStartsWith(\"--\");\nconst startsAsVariableToken = \n/*@__PURE__*/ checkStringStartsWith(\"var(--\");\nconst isCSSVariableToken = (value) => {\n    const startsWithToken = startsAsVariableToken(value);\n    if (!startsWithToken)\n        return false;\n    // Ensure any comments are stripped from the value as this can harm performance of the regex.\n    return singleCssVariableRegex.test(value.split(\"/*\")[0].trim());\n};\nconst singleCssVariableRegex = /var\\(--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)$/iu;\n/**\n * Check if a value contains a CSS variable anywhere (e.g. inside calc()).\n * Unlike isCSSVariableToken which checks if the value IS a var() token,\n * this checks if the value CONTAINS var() somewhere in the string.\n */\nfunction containsCSSVariable(value) {\n    if (typeof value !== \"string\")\n        return false;\n    // Strip comments to avoid false positives\n    return value.split(\"/*\")[0].includes(\"var(--\");\n}\n\nexport { containsCSSVariable, isCSSVariableName, isCSSVariableToken };\n//# sourceMappingURL=is-css-variable.mjs.map\n","import { clamp } from 'motion-utils';\n\nconst number = {\n    test: (v) => typeof v === \"number\",\n    parse: parseFloat,\n    transform: (v) => v,\n};\nconst alpha = {\n    ...number,\n    transform: (v) => clamp(0, 1, v),\n};\nconst scale = {\n    ...number,\n    default: 1,\n};\n\nexport { alpha, number, scale };\n//# sourceMappingURL=index.mjs.map\n","// If this number is a decimal, make it just five decimal places\n// to avoid exponents\nconst sanitize = (v) => Math.round(v * 100000) / 100000;\n\nexport { sanitize };\n//# sourceMappingURL=sanitize.mjs.map\n","const floatRegex = /-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/gu;\n\nexport { floatRegex };\n//# sourceMappingURL=float-regex.mjs.map\n","const singleColorRegex = /^(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))$/iu;\n\nexport { singleColorRegex };\n//# sourceMappingURL=single-color-regex.mjs.map\n","import { floatRegex } from '../utils/float-regex.mjs';\nimport { isNullish } from '../utils/is-nullish.mjs';\nimport { singleColorRegex } from '../utils/single-color-regex.mjs';\n\n/**\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\n * but false if a number or multiple colors\n */\nconst isColorString = (type, testProp) => (v) => {\n    return Boolean((typeof v === \"string\" &&\n        singleColorRegex.test(v) &&\n        v.startsWith(type)) ||\n        (testProp &&\n            !isNullish(v) &&\n            Object.prototype.hasOwnProperty.call(v, testProp)));\n};\nconst splitColor = (aName, bName, cName) => (v) => {\n    if (typeof v !== \"string\")\n        return v;\n    const [a, b, c, alpha] = v.match(floatRegex);\n    return {\n        [aName]: parseFloat(a),\n        [bName]: parseFloat(b),\n        [cName]: parseFloat(c),\n        alpha: alpha !== undefined ? parseFloat(alpha) : 1,\n    };\n};\n\nexport { isColorString, splitColor };\n//# sourceMappingURL=utils.mjs.map\n","function isNullish(v) {\n    return v == null;\n}\n\nexport { isNullish };\n//# sourceMappingURL=is-nullish.mjs.map\n","import { clamp } from 'motion-utils';\nimport { number, alpha } from '../numbers/index.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\nimport { isColorString, splitColor } from './utils.mjs';\n\nconst clampRgbUnit = (v) => clamp(0, 255, v);\nconst rgbUnit = {\n    ...number,\n    transform: (v) => Math.round(clampRgbUnit(v)),\n};\nconst rgba = {\n    test: /*@__PURE__*/ isColorString(\"rgb\", \"red\"),\n    parse: /*@__PURE__*/ splitColor(\"red\", \"green\", \"blue\"),\n    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \"rgba(\" +\n        rgbUnit.transform(red) +\n        \", \" +\n        rgbUnit.transform(green) +\n        \", \" +\n        rgbUnit.transform(blue) +\n        \", \" +\n        sanitize(alpha.transform(alpha$1)) +\n        \")\",\n};\n\nexport { rgbUnit, rgba };\n//# sourceMappingURL=rgba.mjs.map\n","import { rgba } from './rgba.mjs';\nimport { isColorString } from './utils.mjs';\n\nfunction parseHex(v) {\n    let r = \"\";\n    let g = \"\";\n    let b = \"\";\n    let a = \"\";\n    // If we have 6 characters, ie #FF0000\n    if (v.length > 5) {\n        r = v.substring(1, 3);\n        g = v.substring(3, 5);\n        b = v.substring(5, 7);\n        a = v.substring(7, 9);\n        // Or we have 3 characters, ie #F00\n    }\n    else {\n        r = v.substring(1, 2);\n        g = v.substring(2, 3);\n        b = v.substring(3, 4);\n        a = v.substring(4, 5);\n        r += r;\n        g += g;\n        b += b;\n        a += a;\n    }\n    return {\n        red: parseInt(r, 16),\n        green: parseInt(g, 16),\n        blue: parseInt(b, 16),\n        alpha: a ? parseInt(a, 16) / 255 : 1,\n    };\n}\nconst hex = {\n    test: /*@__PURE__*/ isColorString(\"#\"),\n    parse: parseHex,\n    transform: rgba.transform,\n};\n\nexport { hex };\n//# sourceMappingURL=hex.mjs.map\n","/*#__NO_SIDE_EFFECTS__*/\nconst createUnitType = (unit) => ({\n    test: (v) => typeof v === \"string\" && v.endsWith(unit) && v.split(\" \").length === 1,\n    parse: parseFloat,\n    transform: (v) => `${v}${unit}`,\n});\nconst degrees = /*@__PURE__*/ createUnitType(\"deg\");\nconst percent = /*@__PURE__*/ createUnitType(\"%\");\nconst px = /*@__PURE__*/ createUnitType(\"px\");\nconst vh = /*@__PURE__*/ createUnitType(\"vh\");\nconst vw = /*@__PURE__*/ createUnitType(\"vw\");\nconst progressPercentage = /*@__PURE__*/ (() => ({\n    ...percent,\n    parse: (v) => percent.parse(v) / 100,\n    transform: (v) => percent.transform(v * 100),\n}))();\n\nexport { degrees, percent, progressPercentage, px, vh, vw };\n//# sourceMappingURL=units.mjs.map\n","import { alpha } from '../numbers/index.mjs';\nimport { percent } from '../numbers/units.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\nimport { isColorString, splitColor } from './utils.mjs';\n\nconst hsla = {\n    test: /*@__PURE__*/ isColorString(\"hsl\", \"hue\"),\n    parse: /*@__PURE__*/ splitColor(\"hue\", \"saturation\", \"lightness\"),\n    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n        return (\"hsla(\" +\n            Math.round(hue) +\n            \", \" +\n            percent.transform(sanitize(saturation)) +\n            \", \" +\n            percent.transform(sanitize(lightness)) +\n            \", \" +\n            sanitize(alpha.transform(alpha$1)) +\n            \")\");\n    },\n};\n\nexport { hsla };\n//# sourceMappingURL=hsla.mjs.map\n","import { hex } from './hex.mjs';\nimport { hsla } from './hsla.mjs';\nimport { rgba } from './rgba.mjs';\n\nconst color = {\n    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n    parse: (v) => {\n        if (rgba.test(v)) {\n            return rgba.parse(v);\n        }\n        else if (hsla.test(v)) {\n            return hsla.parse(v);\n        }\n        else {\n            return hex.parse(v);\n        }\n    },\n    transform: (v) => {\n        return typeof v === \"string\"\n            ? v\n            : v.hasOwnProperty(\"red\")\n                ? rgba.transform(v)\n                : hsla.transform(v);\n    },\n    getAnimatableNone: (v) => {\n        const parsed = color.parse(v);\n        parsed.alpha = 0;\n        return color.transform(parsed);\n    },\n};\n\nexport { color };\n//# sourceMappingURL=index.mjs.map\n","const colorRegex = /(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))/giu;\n\nexport { colorRegex };\n//# sourceMappingURL=color-regex.mjs.map\n","import { color } from '../color/index.mjs';\nimport { colorRegex } from '../utils/color-regex.mjs';\nimport { floatRegex } from '../utils/float-regex.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\n\nfunction test(v) {\n    return (isNaN(v) &&\n        typeof v === \"string\" &&\n        (v.match(floatRegex)?.length || 0) +\n            (v.match(colorRegex)?.length || 0) >\n            0);\n}\nconst NUMBER_TOKEN = \"number\";\nconst COLOR_TOKEN = \"color\";\nconst VAR_TOKEN = \"var\";\nconst VAR_FUNCTION_TOKEN = \"var(\";\nconst SPLIT_TOKEN = \"${}\";\n// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\nconst complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\nfunction analyseComplexValue(value) {\n    const originalValue = value.toString();\n    const values = [];\n    const indexes = {\n        color: [],\n        number: [],\n        var: [],\n    };\n    const types = [];\n    let i = 0;\n    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {\n        if (color.test(parsedValue)) {\n            indexes.color.push(i);\n            types.push(COLOR_TOKEN);\n            values.push(color.parse(parsedValue));\n        }\n        else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n            indexes.var.push(i);\n            types.push(VAR_TOKEN);\n            values.push(parsedValue);\n        }\n        else {\n            indexes.number.push(i);\n            types.push(NUMBER_TOKEN);\n            values.push(parseFloat(parsedValue));\n        }\n        ++i;\n        return SPLIT_TOKEN;\n    });\n    const split = tokenised.split(SPLIT_TOKEN);\n    return { values, split, indexes, types };\n}\nfunction parseComplexValue(v) {\n    return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n    const { split, types } = analyseComplexValue(source);\n    const numSections = split.length;\n    return (v) => {\n        let output = \"\";\n        for (let i = 0; i < numSections; i++) {\n            output += split[i];\n            if (v[i] !== undefined) {\n                const type = types[i];\n                if (type === NUMBER_TOKEN) {\n                    output += sanitize(v[i]);\n                }\n                else if (type === COLOR_TOKEN) {\n                    output += color.transform(v[i]);\n                }\n                else {\n                    output += v[i];\n                }\n            }\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v;\nfunction getAnimatableNone(v) {\n    const parsed = parseComplexValue(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n    test,\n    parse: parseComplexValue,\n    createTransformer,\n    getAnimatableNone,\n};\n\nexport { analyseComplexValue, complex };\n//# sourceMappingURL=index.mjs.map\n","// Adapted from https://gist.github.com/mjackson/5311256\nfunction hueToRgb(p, q, t) {\n    if (t < 0)\n        t += 1;\n    if (t > 1)\n        t -= 1;\n    if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n    if (t < 1 / 2)\n        return q;\n    if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    }\n    else {\n        const q = lightness < 0.5\n            ? lightness * (1 + saturation)\n            : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha,\n    };\n}\n\nexport { hslaToRgba };\n//# sourceMappingURL=hsla-to-rgba.mjs.map\n","function mixImmediate(a, b) {\n    return (p) => (p > 0 ? b : a);\n}\n\nexport { mixImmediate };\n//# sourceMappingURL=immediate.mjs.map\n","/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (usually a number from 0 to 1)\n\n  So progress = 0.5 would change\n\n  from -------- to\n\n  to\n\n  from ---- to\n\n  E.g. from = 10, to = 20, progress = 0.5 => 15\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\nconst mixNumber = (from, to, progress) => {\n    return from + (to - from) * progress;\n};\n\nexport { mixNumber };\n//# sourceMappingURL=number.mjs.map\n","import { warning } from 'motion-utils';\nimport { hex } from '../../value/types/color/hex.mjs';\nimport { hsla } from '../../value/types/color/hsla.mjs';\nimport { hslaToRgba } from '../../value/types/color/hsla-to-rgba.mjs';\nimport { rgba } from '../../value/types/color/rgba.mjs';\nimport { mixImmediate } from './immediate.mjs';\nimport { mixNumber } from './number.mjs';\n\n// Linear color space blending\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\nconst mixLinearColor = (from, to, v) => {\n    const fromExpo = from * from;\n    const expo = v * (to * to - fromExpo) + fromExpo;\n    return expo < 0 ? 0 : Math.sqrt(expo);\n};\nconst colorTypes = [hex, rgba, hsla];\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\nfunction asRGBA(color) {\n    const type = getColorType(color);\n    warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`, \"color-not-animatable\");\n    if (!Boolean(type))\n        return false;\n    let model = type.parse(color);\n    if (type === hsla) {\n        // TODO Remove this cast - needed since Motion's stricter typing\n        model = hslaToRgba(model);\n    }\n    return model;\n}\nconst mixColor = (from, to) => {\n    const fromRGBA = asRGBA(from);\n    const toRGBA = asRGBA(to);\n    if (!fromRGBA || !toRGBA) {\n        return mixImmediate(from, to);\n    }\n    const blended = { ...fromRGBA };\n    return (v) => {\n        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\n        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\n        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\n        blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);\n        return rgba.transform(blended);\n    };\n};\n\nexport { mixColor, mixLinearColor };\n//# sourceMappingURL=color.mjs.map\n","const invisibleValues = new Set([\"none\", \"hidden\"]);\n/**\n * Returns a function that, when provided a progress value between 0 and 1,\n * will return the \"none\" or \"hidden\" string only when the progress is that of\n * the origin or target.\n */\nfunction mixVisibility(origin, target) {\n    if (invisibleValues.has(origin)) {\n        return (p) => (p <= 0 ? origin : target);\n    }\n    else {\n        return (p) => (p >= 1 ? target : origin);\n    }\n}\n\nexport { invisibleValues, mixVisibility };\n//# sourceMappingURL=visibility.mjs.map\n","import { pipe, warning } from 'motion-utils';\nimport { isCSSVariableToken } from '../../animation/utils/is-css-variable.mjs';\nimport { color } from '../../value/types/color/index.mjs';\nimport { complex, analyseComplexValue } from '../../value/types/complex/index.mjs';\nimport { mixColor } from './color.mjs';\nimport { mixImmediate } from './immediate.mjs';\nimport { mixNumber as mixNumber$1 } from './number.mjs';\nimport { invisibleValues, mixVisibility } from './visibility.mjs';\n\nfunction mixNumber(a, b) {\n    return (p) => mixNumber$1(a, b, p);\n}\nfunction getMixer(a) {\n    if (typeof a === \"number\") {\n        return mixNumber;\n    }\n    else if (typeof a === \"string\") {\n        return isCSSVariableToken(a)\n            ? mixImmediate\n            : color.test(a)\n                ? mixColor\n                : mixComplex;\n    }\n    else if (Array.isArray(a)) {\n        return mixArray;\n    }\n    else if (typeof a === \"object\") {\n        return color.test(a) ? mixColor : mixObject;\n    }\n    return mixImmediate;\n}\nfunction mixArray(a, b) {\n    const output = [...a];\n    const numValues = output.length;\n    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\n    return (p) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](p);\n        }\n        return output;\n    };\n}\nfunction mixObject(a, b) {\n    const output = { ...a, ...b };\n    const blendValue = {};\n    for (const key in output) {\n        if (a[key] !== undefined && b[key] !== undefined) {\n            blendValue[key] = getMixer(a[key])(a[key], b[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n}\nfunction matchOrder(origin, target) {\n    const orderedOrigin = [];\n    const pointers = { color: 0, var: 0, number: 0 };\n    for (let i = 0; i < target.values.length; i++) {\n        const type = target.types[i];\n        const originIndex = origin.indexes[type][pointers[type]];\n        const originValue = origin.values[originIndex] ?? 0;\n        orderedOrigin[i] = originValue;\n        pointers[type]++;\n    }\n    return orderedOrigin;\n}\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyseComplexValue(origin);\n    const targetStats = analyseComplexValue(target);\n    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\n        originStats.indexes.number.length >= targetStats.indexes.number.length;\n    if (canInterpolate) {\n        if ((invisibleValues.has(origin) &&\n            !targetStats.values.length) ||\n            (invisibleValues.has(target) &&\n                !originStats.values.length)) {\n            return mixVisibility(origin, target);\n        }\n        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n    }\n    else {\n        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`, \"complex-values-different\");\n        return mixImmediate(origin, target);\n    }\n};\n\nexport { getMixer, mixArray, mixComplex, mixObject };\n//# sourceMappingURL=complex.mjs.map\n","import { getMixer } from './complex.mjs';\nimport { mixNumber } from './number.mjs';\n\nfunction mix(from, to, p) {\n    if (typeof from === \"number\" &&\n        typeof to === \"number\" &&\n        typeof p === \"number\") {\n        return mixNumber(from, to, p);\n    }\n    const mixer = getMixer(from);\n    return mixer(from, to);\n}\n\nexport { mix };\n//# sourceMappingURL=index.mjs.map\n","import { invariant, clamp, MotionGlobalConfig, noop, pipe, progress } from 'motion-utils';\nimport { mix } from './mix/index.mjs';\n\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revisit this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    invariant(inputLength === output.length, \"Both input and output ranges must be the same length\", \"range-length\");\n    /**\n     * If we're only provided a single input, we can just make a function\n     * that returns the output.\n     */\n    if (inputLength === 1)\n        return () => output[0];\n    if (inputLength === 2 && output[0] === output[1])\n        return () => output[1];\n    const isZeroDeltaRange = input[0] === input[1];\n    // If input runs highest -> lowest, reverse both arrays\n    if (input[0] > input[inputLength - 1]) {\n        input = [...input].reverse();\n        output = [...output].reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const numMixers = mixers.length;\n    const interpolator = (v) => {\n        if (isZeroDeltaRange && v < input[0])\n            return output[0];\n        let i = 0;\n        if (numMixers > 1) {\n            for (; i < input.length - 2; i++) {\n                if (v < input[i + 1])\n                    break;\n            }\n        }\n        const progressInRange = progress(input[i], input[i + 1], v);\n        return mixers[i](progressInRange);\n    };\n    return isClamp\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\nexport { interpolate };\n//# sourceMappingURL=interpolate.mjs.map\n","import { fillOffset } from './fill.mjs';\n\nfunction defaultOffset(arr) {\n    const offset = [0];\n    fillOffset(offset, arr.length - 1);\n    return offset;\n}\n\nexport { defaultOffset };\n//# sourceMappingURL=default.mjs.map\n","import { progress } from 'motion-utils';\nimport { mixNumber } from '../../../utils/mix/number.mjs';\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = progress(0, remaining, i);\n        offset.push(mixNumber(min, 1, offsetProgress));\n    }\n}\n\nexport { fillOffset };\n//# sourceMappingURL=fill.mjs.map\n","import { memo } from 'motion-utils';\n\nconst supportsScrollTimeline = /* @__PURE__ */ memo(() => window.ScrollTimeline !== undefined);\n\nexport { supportsScrollTimeline };\n//# sourceMappingURL=scroll-timeline.mjs.map\n","import { isObject } from 'motion-utils';\n\n/**\n * Checks if an element is an HTML element in a way\n * that works across iframes\n */\nfunction isHTMLElement(element) {\n    return isObject(element) && \"offsetHeight\" in element;\n}\n\nexport { isHTMLElement };\n//# sourceMappingURL=is-html-element.mjs.map\n","import { isSVGElement } from '../utils/is-svg-element.mjs';\nimport { resolveElements } from '../utils/resolve-elements.mjs';\n\nconst resizeHandlers = new WeakMap();\nlet observer;\nconst getSize = (borderBoxAxis, svgAxis, htmlAxis) => (target, borderBoxSize) => {\n    if (borderBoxSize && borderBoxSize[0]) {\n        return borderBoxSize[0][(borderBoxAxis + \"Size\")];\n    }\n    else if (isSVGElement(target) && \"getBBox\" in target) {\n        return target.getBBox()[svgAxis];\n    }\n    else {\n        return target[htmlAxis];\n    }\n};\nconst getWidth = /*@__PURE__*/ getSize(\"inline\", \"width\", \"offsetWidth\");\nconst getHeight = /*@__PURE__*/ getSize(\"block\", \"height\", \"offsetHeight\");\nfunction notifyTarget({ target, borderBoxSize }) {\n    resizeHandlers.get(target)?.forEach((handler) => {\n        handler(target, {\n            get width() {\n                return getWidth(target, borderBoxSize);\n            },\n            get height() {\n                return getHeight(target, borderBoxSize);\n            },\n        });\n    });\n}\nfunction notifyAll(entries) {\n    entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n    if (typeof ResizeObserver === \"undefined\")\n        return;\n    observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n    if (!observer)\n        createResizeObserver();\n    const elements = resolveElements(target);\n    elements.forEach((element) => {\n        let elementHandlers = resizeHandlers.get(element);\n        if (!elementHandlers) {\n            elementHandlers = new Set();\n            resizeHandlers.set(element, elementHandlers);\n        }\n        elementHandlers.add(handler);\n        observer?.observe(element);\n    });\n    return () => {\n        elements.forEach((element) => {\n            const elementHandlers = resizeHandlers.get(element);\n            elementHandlers?.delete(handler);\n            if (!elementHandlers?.size) {\n                observer?.unobserve(element);\n            }\n        });\n    };\n}\n\nexport { resizeElement };\n//# sourceMappingURL=handle-element.mjs.map\n","import { isObject } from 'motion-utils';\n\n/**\n * Checks if an element is an SVG element in a way\n * that works across iframes\n */\nfunction isSVGElement(element) {\n    return isObject(element) && \"ownerSVGElement\" in element;\n}\n\nexport { isSVGElement };\n//# sourceMappingURL=is-svg-element.mjs.map\n","function resolveElements(elementOrSelector, scope, selectorCache) {\n    if (elementOrSelector == null) {\n        return [];\n    }\n    if (elementOrSelector instanceof EventTarget) {\n        return [elementOrSelector];\n    }\n    else if (typeof elementOrSelector === \"string\") {\n        let root = document;\n        if (scope) {\n            root = scope.current;\n        }\n        const elements = selectorCache?.[elementOrSelector] ??\n            root.querySelectorAll(elementOrSelector);\n        return elements ? Array.from(elements) : [];\n    }\n    return Array.from(elementOrSelector).filter((element) => element != null);\n}\n\nexport { resolveElements };\n//# sourceMappingURL=resolve-elements.mjs.map\n","const windowCallbacks = new Set();\nlet windowResizeHandler;\nfunction createWindowResizeHandler() {\n    windowResizeHandler = () => {\n        const info = {\n            get width() {\n                return window.innerWidth;\n            },\n            get height() {\n                return window.innerHeight;\n            },\n        };\n        windowCallbacks.forEach((callback) => callback(info));\n    };\n    window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n    windowCallbacks.add(callback);\n    if (!windowResizeHandler)\n        createWindowResizeHandler();\n    return () => {\n        windowCallbacks.delete(callback);\n        if (!windowCallbacks.size &&\n            typeof windowResizeHandler === \"function\") {\n            window.removeEventListener(\"resize\", windowResizeHandler);\n            windowResizeHandler = undefined;\n        }\n    };\n}\n\nexport { resizeWindow };\n//# sourceMappingURL=handle-window.mjs.map\n","import { frame, cancelFrame } from '../frameloop/frame.mjs';\n\nfunction observeTimeline(update, timeline) {\n    let prevProgress;\n    const onFrame = () => {\n        const { currentTime } = timeline;\n        const percentage = currentTime === null ? 0 : currentTime.value;\n        const progress = percentage / 100;\n        if (prevProgress !== progress) {\n            update(progress);\n        }\n        prevProgress = progress;\n    };\n    frame.preUpdate(onFrame, true);\n    return () => cancelFrame(onFrame);\n}\n\nexport { observeTimeline };\n//# sourceMappingURL=observe.mjs.map\n","import { progress, velocityPerSecond } from \"motion-utils\";\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50;\nconst createAxisInfo = () => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n});\nexport const createScrollInfo = () => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n});\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\",\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\",\n    },\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n    const axis = info[axisName];\n    const { length, position } = keys[axisName];\n    const prev = axis.current;\n    const prevTime = info.time;\n    axis.current = element[`scroll${position}`];\n    axis.scrollLength = element[`scroll${length}`] - element[`client${length}`];\n    axis.offset.length = 0;\n    axis.offset[0] = 0;\n    axis.offset[1] = axis.scrollLength;\n    axis.progress = progress(0, axis.scrollLength, axis.current);\n    const elapsed = time - prevTime;\n    axis.velocity =\n        elapsed > maxElapsed\n            ? 0\n            : velocityPerSecond(axis.current - prev, elapsed);\n}\nexport function updateScrollInfo(element, info, time) {\n    updateAxisInfo(element, \"x\", info, time);\n    updateAxisInfo(element, \"y\", info, time);\n    info.time = time;\n}\n//# sourceMappingURL=info.js.map","/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nexport { velocityPerSecond };\n//# sourceMappingURL=velocity-per-second.mjs.map\n","export const namedEdges = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n};\nexport function resolveEdge(edge, length, inset = 0) {\n    let delta = 0;\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (edge in namedEdges) {\n        edge = namedEdges[edge];\n    }\n    /**\n     * Handle unit values\n     */\n    if (typeof edge === \"string\") {\n        const asNumber = parseFloat(edge);\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber;\n        }\n        else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100;\n        }\n        else if (edge.endsWith(\"vw\")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth;\n        }\n        else if (edge.endsWith(\"vh\")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight;\n        }\n        else {\n            edge = asNumber;\n        }\n    }\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (typeof edge === \"number\") {\n        delta = length * edge;\n    }\n    return inset + delta;\n}\n//# sourceMappingURL=edge.js.map","import { namedEdges, resolveEdge } from \"./edge\";\nconst defaultOffset = [0, 0];\nexport function resolveOffset(offset, containerLength, targetLength, targetInset) {\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n    let targetPoint = 0;\n    let containerPoint = 0;\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset];\n    }\n    else if (typeof offset === \"string\") {\n        offset = offset.trim();\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \");\n        }\n        else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n        }\n    }\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n    return targetPoint - containerPoint;\n}\n//# sourceMappingURL=offset.js.map","export const ScrollOffset = {\n    Enter: [\n        [0, 1],\n        [1, 1],\n    ],\n    Exit: [\n        [0, 0],\n        [1, 0],\n    ],\n    Any: [\n        [1, 0],\n        [0, 1],\n    ],\n    All: [\n        [0, 0],\n        [1, 1],\n    ],\n};\n//# sourceMappingURL=presets.js.map","import { defaultOffset, interpolate } from \"motion-dom\";\nimport { clamp } from \"motion-utils\";\nimport { calcInset } from \"./inset\";\nimport { resolveOffset } from \"./offset\";\nimport { ScrollOffset } from \"./presets\";\nconst point = { x: 0, y: 0 };\nfunction getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? target.getBBox()\n        : { width: target.clientWidth, height: target.clientHeight };\n}\nexport function resolveOffsets(container, info, options) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : getTargetSize(target);\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition), { clamp: false });\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = clamp(0, 1, info[axis].interpolate(info[axis].current));\n}\n//# sourceMappingURL=index.js.map","import { isHTMLElement } from \"motion-dom\";\nexport function calcInset(element, container) {\n    const inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (isHTMLElement(current)) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect();\n            current = current.parentElement;\n            const parentBoundingBox = current.getBoundingClientRect();\n            inset.x += svgBoundingBox.left - parentBoundingBox.left;\n            inset.y += svgBoundingBox.top - parentBoundingBox.top;\n        }\n        else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox();\n            inset.x += x;\n            inset.y += y;\n            let svg = null;\n            let parent = current.parentNode;\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent;\n                }\n                parent = current.parentNode;\n            }\n            current = svg;\n        }\n        else {\n            break;\n        }\n    }\n    return inset;\n}\n//# sourceMappingURL=inset.js.map","import { warnOnce } from \"motion-utils\";\nimport { updateScrollInfo } from \"./info\";\nimport { resolveOffsets } from \"./offsets/index\";\nfunction measure(container, target = container, info) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0;\n    info.y.targetOffset = 0;\n    if (target !== container) {\n        let node = target;\n        while (node && node !== container) {\n            info.x.targetOffset += node.offsetLeft;\n            info.y.targetOffset += node.offsetTop;\n            node = node.offsetParent;\n        }\n    }\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth;\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight;\n    info.x.containerLength = container.clientWidth;\n    info.y.containerLength = container.clientHeight;\n    /**\n     * In development mode ensure scroll containers aren't position: static as this makes\n     * it difficult to measure their relative positions.\n     */\n    if (process.env.NODE_ENV !== \"production\") {\n        if (container && target && target !== container) {\n            warnOnce(getComputedStyle(container).position !== \"static\", \"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\");\n        }\n    }\n}\nexport function createOnScrollHandler(element, onScroll, info, options = {}) {\n    return {\n        measure: (time) => {\n            measure(element, options.target, info);\n            updateScrollInfo(element, info, time);\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options);\n            }\n        },\n        notify: () => onScroll(info),\n    };\n}\n//# sourceMappingURL=on-scroll-handler.js.map","import { cancelFrame, frame, frameData, resize } from \"motion-dom\";\nimport { noop } from \"motion-utils\";\nimport { createScrollInfo } from \"./info\";\nimport { createOnScrollHandler } from \"./on-scroll-handler\";\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\nconst getEventTarget = (element) => element === document.scrollingElement ? window : element;\nexport function scrollInfo(onScroll, { container = document.scrollingElement, ...options } = {}) {\n    if (!container)\n        return noop;\n    let containerHandlers = onScrollHandlers.get(container);\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set();\n        onScrollHandlers.set(container, containerHandlers);\n    }\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo();\n    const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n    containerHandlers.add(containerHandler);\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const measureAll = () => {\n            for (const handler of containerHandlers) {\n                handler.measure(frameData.timestamp);\n            }\n            frame.preUpdate(notifyAll);\n        };\n        const notifyAll = () => {\n            for (const handler of containerHandlers) {\n                handler.notify();\n            }\n        };\n        const listener = () => frame.read(measureAll);\n        scrollListeners.set(container, listener);\n        const target = getEventTarget(container);\n        window.addEventListener(\"resize\", listener, { passive: true });\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener));\n        }\n        target.addEventListener(\"scroll\", listener, { passive: true });\n        listener();\n    }\n    const listener = scrollListeners.get(container);\n    frame.read(listener, false, true);\n    return () => {\n        cancelFrame(listener);\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const currentHandlers = onScrollHandlers.get(container);\n        if (!currentHandlers)\n            return;\n        currentHandlers.delete(containerHandler);\n        if (currentHandlers.size)\n            return;\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const scrollListener = scrollListeners.get(container);\n        scrollListeners.delete(container);\n        if (scrollListener) {\n            getEventTarget(container).removeEventListener(\"scroll\", scrollListener);\n            resizeListeners.get(container)?.();\n            window.removeEventListener(\"resize\", scrollListener);\n        }\n    };\n}\n//# sourceMappingURL=track.js.map","import { resizeElement } from './handle-element.mjs';\nimport { resizeWindow } from './handle-window.mjs';\n\nfunction resize(a, b) {\n    return typeof a === \"function\" ? resizeWindow(a) : resizeElement(a, b);\n}\n\nexport { resize };\n//# sourceMappingURL=index.mjs.map\n","import { supportsScrollTimeline } from \"motion-dom\";\nimport { scrollInfo } from \"../track\";\nconst timelineCache = new Map();\nfunction scrollTimelineFallback(options) {\n    const currentTime = { value: 0 };\n    const cancel = scrollInfo((info) => {\n        currentTime.value = info[options.axis].progress * 100;\n    }, options);\n    return { currentTime, cancel };\n}\nexport function getTimeline({ source, container, ...options }) {\n    const { axis } = options;\n    if (source)\n        container = source;\n    const containerCache = timelineCache.get(container) ?? new Map();\n    timelineCache.set(container, containerCache);\n    const targetKey = options.target ?? \"self\";\n    const targetCache = containerCache.get(targetKey) ?? {};\n    const axisKey = axis + (options.offset ?? []).join(\",\");\n    if (!targetCache[axisKey]) {\n        targetCache[axisKey] =\n            !options.target && supportsScrollTimeline()\n                ? new ScrollTimeline({ source: container, axis })\n                : scrollTimelineFallback({ container, ...options });\n    }\n    return targetCache[axisKey];\n}\n//# sourceMappingURL=get-timeline.js.map","import { noop } from \"motion-utils\";\nimport { attachToAnimation } from \"./attach-animation\";\nimport { attachToFunction } from \"./attach-function\";\nexport function scroll(onScroll, { axis = \"y\", container = document.scrollingElement, ...options } = {}) {\n    if (!container)\n        return noop;\n    const optionsWithDefaults = { axis, container, ...options };\n    return typeof onScroll === \"function\"\n        ? attachToFunction(onScroll, optionsWithDefaults)\n        : attachToAnimation(onScroll, optionsWithDefaults);\n}\n//# sourceMappingURL=index.js.map","import { observeTimeline } from \"motion-dom\";\nimport { scrollInfo } from \"./track\";\nimport { getTimeline } from \"./utils/get-timeline\";\n/**\n * If the onScroll function has two arguments, it's expecting\n * more specific information about the scroll from scrollInfo.\n */\nfunction isOnScrollWithInfo(onScroll) {\n    return onScroll.length === 2;\n}\nexport function attachToFunction(onScroll, options) {\n    if (isOnScrollWithInfo(onScroll)) {\n        return scrollInfo((info) => {\n            onScroll(info[options.axis].progress, info);\n        }, options);\n    }\n    else {\n        return observeTimeline(onScroll, getTimeline(options));\n    }\n}\n//# sourceMappingURL=attach-function.js.map","import { observeTimeline } from \"motion-dom\";\nimport { getTimeline } from \"./utils/get-timeline\";\nexport function attachToAnimation(animation, options) {\n    const timeline = getTimeline(options);\n    return animation.attachTimeline({\n        timeline: options.target ? undefined : timeline,\n        observe: (valueAnimation) => {\n            valueAnimation.pause();\n            return observeTimeline((progress) => {\n                valueAnimation.time =\n                    valueAnimation.iterationDuration * progress;\n            }, timeline);\n        },\n    });\n}\n//# sourceMappingURL=attach-animation.js.map"],"names":["clamp","min","max","v","formatErrorMessage","message","errorCode","warning","invariant","process","env","NODE_ENV","check","console","warn","Error","MotionGlobalConfig","isObject","value","memo","callback","result","undefined","noop","any","combineFunctions","a","b","pipe","transformers","reduce","progress","from","to","toFromDifference","stepsOrder","statsBuffer","addProjectionMetrics","createRenderBatcher","scheduleNextBatch","allowKeepAlive","runNextFrame","useDefaultElapsed","state","delta","timestamp","isProcessing","flagRunNextFrame","steps","acc","key","stepName","thisFrame","Set","nextFrame","flushNextFrame","toKeepAlive","WeakSet","latestFrameData","numCalls","triggerCallback","has","step","schedule","keepAlive","immediate","queue","add","cancel","delete","frameData","forEach","frameloop","push","clear","createRenderStep","setup","read","resolveKeyframes","preUpdate","update","preRender","render","postRender","processBatch","useManualTiming","performance","now","Math","i","length","frame","cancelFrame","frameSteps","requestAnimationFrame","startsAsVariableToken","token","startsWith","checkStringStartsWith","singleCssVariableRegex","number","test","parse","parseFloat","transform","alpha","sanitize","round","floatRegex","singleColorRegex","isColorString","type","testProp","Boolean","isNullish","Object","prototype","hasOwnProperty","call","splitColor","aName","bName","cName","c","match","rgbUnit","clampRgbUnit","rgba","red","green","blue","alpha$1","hex","r","g","substring","parseInt","percent","unit","endsWith","split","createUnitType","hsla","hue","saturation","lightness","color","getAnimatableNone","parsed","colorRegex","NUMBER_TOKEN","COLOR_TOKEN","complexRegex","analyseComplexValue","originalValue","toString","values","indexes","var","types","replace","parsedValue","parseComplexValue","createTransformer","source","numSections","output","convertNumbersToZero","complex","isNaN","transformer","map","hueToRgb","p","q","t","mixImmediate","mixNumber","mixLinearColor","fromExpo","expo","sqrt","colorTypes","asRGBA","find","model","hslaToRgba","mixColor","fromRGBA","toRGBA","blended","invisibleValues","mixNumber$1","getMixer","trim","mixComplex","Array","isArray","mixArray","mixObject","numValues","blendValue","origin","target","template","originStats","targetStats","mixVisibility","orderedOrigin","pointers","originIndex","originValue","matchOrder","mix","mixer","interpolate","input","isClamp","ease","inputLength","isZeroDeltaRange","reverse","mixers","customMixer","mixerFactory","numMixers","easingFunction","createMixers","interpolator","progressInRange","defaultOffset","arr","offset","remaining","offsetProgress","fillOffset","supportsScrollTimeline","window","ScrollTimeline","isHTMLElement","element","resizeHandlers","WeakMap","observer","getSize","borderBoxAxis","svgAxis","htmlAxis","borderBoxSize","getBBox","getWidth","getHeight","notifyTarget","get","handler","width","height","notifyAll","entries","resizeElement","ResizeObserver","elements","elementOrSelector","EventTarget","document","querySelectorAll","filter","resolveElements","elementHandlers","set","observe","size","unobserve","windowCallbacks","windowResizeHandler","resizeWindow","info","innerWidth","innerHeight","addEventListener","removeEventListener","observeTimeline","timeline","prevProgress","onFrame","currentTime","keys","x","position","y","updateAxisInfo","axisName","time","axis","prev","current","prevTime","scrollLength","elapsed","velocity","frameDuration","namedEdges","start","center","end","resolveEdge","edge","inset","asNumber","documentElement","clientWidth","clientHeight","resolveOffset","containerLength","targetLength","targetInset","offsetDefinition","targetPoint","containerPoint","includes","ScrollOffset","Enter","Exit","Any","All","point","resolveOffsets","container","options","lengthLabel","offsetLeft","offsetTop","offsetParent","tagName","svgBoundingBox","getBoundingClientRect","parentElement","parentBoundingBox","left","top","SVGGraphicsElement","svg","parent","parentNode","calcInset","targetSize","scrollWidth","scrollHeight","getTargetSize","containerSize","hasChanged","numOffsets","interpolatorOffsets","createOnScrollHandler","onScroll","measure","targetOffset","node","updateScrollInfo","notify","scrollListeners","resizeListeners","onScrollHandlers","getEventTarget","scrollingElement","scrollInfo","containerHandlers","containerHandler","measureAll","listener","passive","currentHandlers","scrollListener","timelineCache","Map","getTimeline","containerCache","targetKey","targetCache","axisKey","join","scrollTimelineFallback","scroll","optionsWithDefaults","isOnScrollWithInfo","attachToFunction","animation","attachTimeline","valueAnimation","pause","iterationDuration","attachToAnimation"],"mappings":"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"}