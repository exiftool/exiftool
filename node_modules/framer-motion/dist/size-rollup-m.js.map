{"version":3,"file":"size-rollup-m.js","sources":["../../motion-utils/dist/es/clamp.mjs","../lib/context/LayoutGroupContext.js","../lib/context/LazyContext.js","../lib/context/MotionConfigContext.js","../lib/context/MotionContext/index.js","../../motion-dom/dist/es/animation/utils/is-css-variable.mjs","../../motion-dom/dist/es/value/types/numbers/index.mjs","../../motion-dom/dist/es/value/types/utils/sanitize.mjs","../../motion-dom/dist/es/value/types/utils/float-regex.mjs","../../motion-dom/dist/es/value/types/utils/single-color-regex.mjs","../../motion-dom/dist/es/value/types/color/utils.mjs","../../motion-dom/dist/es/value/types/utils/is-nullish.mjs","../../motion-dom/dist/es/value/types/color/rgba.mjs","../../motion-dom/dist/es/value/types/color/hex.mjs","../../motion-dom/dist/es/value/types/numbers/units.mjs","../../motion-dom/dist/es/value/types/color/hsla.mjs","../../motion-dom/dist/es/value/types/color/index.mjs","../../motion-dom/dist/es/value/types/utils/color-regex.mjs","../../motion-dom/dist/es/value/types/complex/index.mjs","../../motion-dom/dist/es/render/utils/keys-transform.mjs","../../motion-dom/dist/es/render/utils/resolve-variants.mjs","../../motion-dom/dist/es/value/utils/is-motion-value.mjs","../../motion-dom/dist/es/animation/optimized-appear/data-id.mjs","../../motion-dom/dist/es/render/dom/utils/camel-to-dash.mjs","../../motion-dom/dist/es/value/types/int.mjs","../../motion-dom/dist/es/value/types/maps/number.mjs","../../motion-dom/dist/es/value/types/maps/transform.mjs","../../motion-dom/dist/es/value/types/utils/get-as-type.mjs","../../motion-dom/dist/es/render/utils/is-animation-controls.mjs","../../motion-dom/dist/es/render/utils/is-variant-label.mjs","../../motion-dom/dist/es/render/utils/variant-props.mjs","../../motion-dom/dist/es/render/utils/is-controlling-variants.mjs","../../motion-dom/dist/es/render/VisualElement.mjs","../../motion-dom/dist/es/render/html/utils/build-transform.mjs","../../motion-dom/dist/es/render/html/utils/build-styles.mjs","../../motion-dom/dist/es/projection/styles/scale-border-radius.mjs","../../motion-dom/dist/es/projection/styles/scale-box-shadow.mjs","../../motion-dom/dist/es/utils/mix/number.mjs","../../motion-dom/dist/es/projection/styles/scale-correction.mjs","../../motion-dom/dist/es/render/utils/is-forced-motion-value.mjs","../../motion-dom/dist/es/render/html/utils/scrape-motion-values.mjs","../../motion-dom/dist/es/render/svg/utils/path.mjs","../../motion-dom/dist/es/render/svg/utils/build-attrs.mjs","../../motion-dom/dist/es/value/utils/resolve-motion-value.mjs","../lib/context/MotionContext/create.js","../lib/context/MotionContext/utils.js","../lib/render/html/utils/create-render-state.js","../lib/render/html/use-props.js","../lib/render/svg/utils/create-render-state.js","../lib/render/svg/use-props.js","../../motion-dom/dist/es/render/svg/utils/is-svg-tag.mjs","../lib/motion/utils/valid-prop.js","../lib/render/dom/utils/filter-props.js","../lib/render/svg/lowercase-elements.js","../lib/render/dom/utils/is-svg-component.js","../lib/render/dom/use-render.js","../lib/context/PresenceContext.js","../lib/motion/utils/use-visual-state.js","../lib/utils/use-constant.js","../lib/render/html/use-html-visual-state.js","../lib/render/svg/use-svg-visual-state.js","../../motion-dom/dist/es/render/svg/utils/scrape-motion-values.mjs","../lib/utils/is-browser.js","../lib/motion/features/definitions.js","../lib/motion/utils/symbol.js","../lib/motion/utils/use-motion-ref.js","../lib/context/SwitchLayoutGroupContext.js","../lib/utils/is-ref-object.js","../lib/utils/use-isomorphic-effect.js","../lib/motion/utils/use-visual-element.js","../lib/motion/index.js","../lib/render/components/m/create.js","../lib/render/components/m/elements.js","../lib/render/components/m/size.js"],"sourcesContent":["const clamp = (min, max, v) => {\n    if (v > max)\n        return max;\n    if (v < min)\n        return min;\n    return v;\n};\n\nexport { clamp };\n//# sourceMappingURL=clamp.mjs.map\n","\"use client\";\nimport { createContext } from \"react\";\nexport const LayoutGroupContext = createContext({});\n//# sourceMappingURL=LayoutGroupContext.js.map","\"use client\";\nimport { createContext } from \"react\";\nexport const LazyContext = createContext({ strict: false });\n//# sourceMappingURL=LazyContext.js.map","\"use client\";\nimport { createContext } from \"react\";\n/**\n * @public\n */\nexport const MotionConfigContext = createContext({\n    transformPagePoint: (p) => p,\n    isStatic: false,\n    reducedMotion: \"never\",\n});\n//# sourceMappingURL=MotionConfigContext.js.map","\"use client\";\nimport { createContext } from \"react\";\nexport const MotionContext = /* @__PURE__ */ createContext({});\n//# sourceMappingURL=index.js.map","const checkStringStartsWith = (token) => (key) => typeof key === \"string\" && key.startsWith(token);\nconst isCSSVariableName = \n/*@__PURE__*/ checkStringStartsWith(\"--\");\nconst startsAsVariableToken = \n/*@__PURE__*/ checkStringStartsWith(\"var(--\");\nconst isCSSVariableToken = (value) => {\n    const startsWithToken = startsAsVariableToken(value);\n    if (!startsWithToken)\n        return false;\n    // Ensure any comments are stripped from the value as this can harm performance of the regex.\n    return singleCssVariableRegex.test(value.split(\"/*\")[0].trim());\n};\nconst singleCssVariableRegex = /var\\(--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)$/iu;\n/**\n * Check if a value contains a CSS variable anywhere (e.g. inside calc()).\n * Unlike isCSSVariableToken which checks if the value IS a var() token,\n * this checks if the value CONTAINS var() somewhere in the string.\n */\nfunction containsCSSVariable(value) {\n    if (typeof value !== \"string\")\n        return false;\n    // Strip comments to avoid false positives\n    return value.split(\"/*\")[0].includes(\"var(--\");\n}\n\nexport { containsCSSVariable, isCSSVariableName, isCSSVariableToken };\n//# sourceMappingURL=is-css-variable.mjs.map\n","import { clamp } from 'motion-utils';\n\nconst number = {\n    test: (v) => typeof v === \"number\",\n    parse: parseFloat,\n    transform: (v) => v,\n};\nconst alpha = {\n    ...number,\n    transform: (v) => clamp(0, 1, v),\n};\nconst scale = {\n    ...number,\n    default: 1,\n};\n\nexport { alpha, number, scale };\n//# sourceMappingURL=index.mjs.map\n","// If this number is a decimal, make it just five decimal places\n// to avoid exponents\nconst sanitize = (v) => Math.round(v * 100000) / 100000;\n\nexport { sanitize };\n//# sourceMappingURL=sanitize.mjs.map\n","const floatRegex = /-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/gu;\n\nexport { floatRegex };\n//# sourceMappingURL=float-regex.mjs.map\n","const singleColorRegex = /^(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))$/iu;\n\nexport { singleColorRegex };\n//# sourceMappingURL=single-color-regex.mjs.map\n","import { floatRegex } from '../utils/float-regex.mjs';\nimport { isNullish } from '../utils/is-nullish.mjs';\nimport { singleColorRegex } from '../utils/single-color-regex.mjs';\n\n/**\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\n * but false if a number or multiple colors\n */\nconst isColorString = (type, testProp) => (v) => {\n    return Boolean((typeof v === \"string\" &&\n        singleColorRegex.test(v) &&\n        v.startsWith(type)) ||\n        (testProp &&\n            !isNullish(v) &&\n            Object.prototype.hasOwnProperty.call(v, testProp)));\n};\nconst splitColor = (aName, bName, cName) => (v) => {\n    if (typeof v !== \"string\")\n        return v;\n    const [a, b, c, alpha] = v.match(floatRegex);\n    return {\n        [aName]: parseFloat(a),\n        [bName]: parseFloat(b),\n        [cName]: parseFloat(c),\n        alpha: alpha !== undefined ? parseFloat(alpha) : 1,\n    };\n};\n\nexport { isColorString, splitColor };\n//# sourceMappingURL=utils.mjs.map\n","function isNullish(v) {\n    return v == null;\n}\n\nexport { isNullish };\n//# sourceMappingURL=is-nullish.mjs.map\n","import { clamp } from 'motion-utils';\nimport { number, alpha } from '../numbers/index.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\nimport { isColorString, splitColor } from './utils.mjs';\n\nconst clampRgbUnit = (v) => clamp(0, 255, v);\nconst rgbUnit = {\n    ...number,\n    transform: (v) => Math.round(clampRgbUnit(v)),\n};\nconst rgba = {\n    test: /*@__PURE__*/ isColorString(\"rgb\", \"red\"),\n    parse: /*@__PURE__*/ splitColor(\"red\", \"green\", \"blue\"),\n    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \"rgba(\" +\n        rgbUnit.transform(red) +\n        \", \" +\n        rgbUnit.transform(green) +\n        \", \" +\n        rgbUnit.transform(blue) +\n        \", \" +\n        sanitize(alpha.transform(alpha$1)) +\n        \")\",\n};\n\nexport { rgbUnit, rgba };\n//# sourceMappingURL=rgba.mjs.map\n","import { rgba } from './rgba.mjs';\nimport { isColorString } from './utils.mjs';\n\nfunction parseHex(v) {\n    let r = \"\";\n    let g = \"\";\n    let b = \"\";\n    let a = \"\";\n    // If we have 6 characters, ie #FF0000\n    if (v.length > 5) {\n        r = v.substring(1, 3);\n        g = v.substring(3, 5);\n        b = v.substring(5, 7);\n        a = v.substring(7, 9);\n        // Or we have 3 characters, ie #F00\n    }\n    else {\n        r = v.substring(1, 2);\n        g = v.substring(2, 3);\n        b = v.substring(3, 4);\n        a = v.substring(4, 5);\n        r += r;\n        g += g;\n        b += b;\n        a += a;\n    }\n    return {\n        red: parseInt(r, 16),\n        green: parseInt(g, 16),\n        blue: parseInt(b, 16),\n        alpha: a ? parseInt(a, 16) / 255 : 1,\n    };\n}\nconst hex = {\n    test: /*@__PURE__*/ isColorString(\"#\"),\n    parse: parseHex,\n    transform: rgba.transform,\n};\n\nexport { hex };\n//# sourceMappingURL=hex.mjs.map\n","/*#__NO_SIDE_EFFECTS__*/\nconst createUnitType = (unit) => ({\n    test: (v) => typeof v === \"string\" && v.endsWith(unit) && v.split(\" \").length === 1,\n    parse: parseFloat,\n    transform: (v) => `${v}${unit}`,\n});\nconst degrees = /*@__PURE__*/ createUnitType(\"deg\");\nconst percent = /*@__PURE__*/ createUnitType(\"%\");\nconst px = /*@__PURE__*/ createUnitType(\"px\");\nconst vh = /*@__PURE__*/ createUnitType(\"vh\");\nconst vw = /*@__PURE__*/ createUnitType(\"vw\");\nconst progressPercentage = /*@__PURE__*/ (() => ({\n    ...percent,\n    parse: (v) => percent.parse(v) / 100,\n    transform: (v) => percent.transform(v * 100),\n}))();\n\nexport { degrees, percent, progressPercentage, px, vh, vw };\n//# sourceMappingURL=units.mjs.map\n","import { alpha } from '../numbers/index.mjs';\nimport { percent } from '../numbers/units.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\nimport { isColorString, splitColor } from './utils.mjs';\n\nconst hsla = {\n    test: /*@__PURE__*/ isColorString(\"hsl\", \"hue\"),\n    parse: /*@__PURE__*/ splitColor(\"hue\", \"saturation\", \"lightness\"),\n    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n        return (\"hsla(\" +\n            Math.round(hue) +\n            \", \" +\n            percent.transform(sanitize(saturation)) +\n            \", \" +\n            percent.transform(sanitize(lightness)) +\n            \", \" +\n            sanitize(alpha.transform(alpha$1)) +\n            \")\");\n    },\n};\n\nexport { hsla };\n//# sourceMappingURL=hsla.mjs.map\n","import { hex } from './hex.mjs';\nimport { hsla } from './hsla.mjs';\nimport { rgba } from './rgba.mjs';\n\nconst color = {\n    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n    parse: (v) => {\n        if (rgba.test(v)) {\n            return rgba.parse(v);\n        }\n        else if (hsla.test(v)) {\n            return hsla.parse(v);\n        }\n        else {\n            return hex.parse(v);\n        }\n    },\n    transform: (v) => {\n        return typeof v === \"string\"\n            ? v\n            : v.hasOwnProperty(\"red\")\n                ? rgba.transform(v)\n                : hsla.transform(v);\n    },\n    getAnimatableNone: (v) => {\n        const parsed = color.parse(v);\n        parsed.alpha = 0;\n        return color.transform(parsed);\n    },\n};\n\nexport { color };\n//# sourceMappingURL=index.mjs.map\n","const colorRegex = /(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))/giu;\n\nexport { colorRegex };\n//# sourceMappingURL=color-regex.mjs.map\n","import { color } from '../color/index.mjs';\nimport { colorRegex } from '../utils/color-regex.mjs';\nimport { floatRegex } from '../utils/float-regex.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\n\nfunction test(v) {\n    return (isNaN(v) &&\n        typeof v === \"string\" &&\n        (v.match(floatRegex)?.length || 0) +\n            (v.match(colorRegex)?.length || 0) >\n            0);\n}\nconst NUMBER_TOKEN = \"number\";\nconst COLOR_TOKEN = \"color\";\nconst VAR_TOKEN = \"var\";\nconst VAR_FUNCTION_TOKEN = \"var(\";\nconst SPLIT_TOKEN = \"${}\";\n// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\nconst complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\nfunction analyseComplexValue(value) {\n    const originalValue = value.toString();\n    const values = [];\n    const indexes = {\n        color: [],\n        number: [],\n        var: [],\n    };\n    const types = [];\n    let i = 0;\n    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {\n        if (color.test(parsedValue)) {\n            indexes.color.push(i);\n            types.push(COLOR_TOKEN);\n            values.push(color.parse(parsedValue));\n        }\n        else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n            indexes.var.push(i);\n            types.push(VAR_TOKEN);\n            values.push(parsedValue);\n        }\n        else {\n            indexes.number.push(i);\n            types.push(NUMBER_TOKEN);\n            values.push(parseFloat(parsedValue));\n        }\n        ++i;\n        return SPLIT_TOKEN;\n    });\n    const split = tokenised.split(SPLIT_TOKEN);\n    return { values, split, indexes, types };\n}\nfunction parseComplexValue(v) {\n    return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n    const { split, types } = analyseComplexValue(source);\n    const numSections = split.length;\n    return (v) => {\n        let output = \"\";\n        for (let i = 0; i < numSections; i++) {\n            output += split[i];\n            if (v[i] !== undefined) {\n                const type = types[i];\n                if (type === NUMBER_TOKEN) {\n                    output += sanitize(v[i]);\n                }\n                else if (type === COLOR_TOKEN) {\n                    output += color.transform(v[i]);\n                }\n                else {\n                    output += v[i];\n                }\n            }\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v;\nfunction getAnimatableNone(v) {\n    const parsed = parseComplexValue(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n    test,\n    parse: parseComplexValue,\n    createTransformer,\n    getAnimatableNone,\n};\n\nexport { analyseComplexValue, complex };\n//# sourceMappingURL=index.mjs.map\n","/**\n * Generate a list of every possible transform key.\n */\nconst transformPropOrder = [\n    \"transformPerspective\",\n    \"x\",\n    \"y\",\n    \"z\",\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"scale\",\n    \"scaleX\",\n    \"scaleY\",\n    \"rotate\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\",\n];\n/**\n * A quick lookup for transform props.\n */\nconst transformProps = /*@__PURE__*/ (() => new Set(transformPropOrder))();\n\nexport { transformPropOrder, transformProps };\n//# sourceMappingURL=keys-transform.mjs.map\n","function getValueState(visualElement) {\n    const state = [{}, {}];\n    visualElement?.values.forEach((value, key) => {\n        state[0][key] = value.get();\n        state[1][key] = value.getVelocity();\n    });\n    return state;\n}\nfunction resolveVariantFromProps(props, definition, custom, visualElement) {\n    /**\n     * If the variant definition is a function, resolve.\n     */\n    if (typeof definition === \"function\") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    /**\n     * If the variant definition is a variant label, or\n     * the function returned a variant label, resolve.\n     */\n    if (typeof definition === \"string\") {\n        definition = props.variants && props.variants[definition];\n    }\n    /**\n     * At this point we've resolved both functions and variant labels,\n     * but the resolved variant label might itself have been a function.\n     * If so, resolve. This can only have returned a valid target object.\n     */\n    if (typeof definition === \"function\") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    return definition;\n}\n\nexport { resolveVariantFromProps };\n//# sourceMappingURL=resolve-variants.mjs.map\n","const isMotionValue = (value) => Boolean(value && value.getVelocity);\n\nexport { isMotionValue };\n//# sourceMappingURL=is-motion-value.mjs.map\n","import { camelToDash } from '../../render/dom/utils/camel-to-dash.mjs';\n\nconst optimizedAppearDataId = \"framerAppearId\";\nconst optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\n\nexport { optimizedAppearDataAttribute, optimizedAppearDataId };\n//# sourceMappingURL=data-id.mjs.map\n","function camelToDash(str) {\n    return str.replace(/([A-Z])/g, (match) => `-${match.toLowerCase()}`);\n}\n\nexport { camelToDash };\n//# sourceMappingURL=camel-to-dash.mjs.map\n","import { number } from './numbers/index.mjs';\n\nconst int = {\n    ...number,\n    transform: Math.round,\n};\n\nexport { int };\n//# sourceMappingURL=int.mjs.map\n","import { int } from '../int.mjs';\nimport { alpha } from '../numbers/index.mjs';\nimport { px } from '../numbers/units.mjs';\nimport { transformValueTypes } from './transform.mjs';\n\nconst numberValueTypes = {\n    // Border props\n    borderWidth: px,\n    borderTopWidth: px,\n    borderRightWidth: px,\n    borderBottomWidth: px,\n    borderLeftWidth: px,\n    borderRadius: px,\n    radius: px,\n    borderTopLeftRadius: px,\n    borderTopRightRadius: px,\n    borderBottomRightRadius: px,\n    borderBottomLeftRadius: px,\n    // Positioning props\n    width: px,\n    maxWidth: px,\n    height: px,\n    maxHeight: px,\n    top: px,\n    right: px,\n    bottom: px,\n    left: px,\n    inset: px,\n    insetBlock: px,\n    insetBlockStart: px,\n    insetBlockEnd: px,\n    insetInline: px,\n    insetInlineStart: px,\n    insetInlineEnd: px,\n    // Spacing props\n    padding: px,\n    paddingTop: px,\n    paddingRight: px,\n    paddingBottom: px,\n    paddingLeft: px,\n    paddingBlock: px,\n    paddingBlockStart: px,\n    paddingBlockEnd: px,\n    paddingInline: px,\n    paddingInlineStart: px,\n    paddingInlineEnd: px,\n    margin: px,\n    marginTop: px,\n    marginRight: px,\n    marginBottom: px,\n    marginLeft: px,\n    marginBlock: px,\n    marginBlockStart: px,\n    marginBlockEnd: px,\n    marginInline: px,\n    marginInlineStart: px,\n    marginInlineEnd: px,\n    // Misc\n    backgroundPositionX: px,\n    backgroundPositionY: px,\n    ...transformValueTypes,\n    zIndex: int,\n    // SVG\n    fillOpacity: alpha,\n    strokeOpacity: alpha,\n    numOctaves: int,\n};\n\nexport { numberValueTypes };\n//# sourceMappingURL=number.mjs.map\n","import { scale, alpha } from '../numbers/index.mjs';\nimport { degrees, px, progressPercentage } from '../numbers/units.mjs';\n\nconst transformValueTypes = {\n    rotate: degrees,\n    rotateX: degrees,\n    rotateY: degrees,\n    rotateZ: degrees,\n    scale,\n    scaleX: scale,\n    scaleY: scale,\n    scaleZ: scale,\n    skew: degrees,\n    skewX: degrees,\n    skewY: degrees,\n    distance: px,\n    translateX: px,\n    translateY: px,\n    translateZ: px,\n    x: px,\n    y: px,\n    z: px,\n    perspective: px,\n    transformPerspective: px,\n    opacity: alpha,\n    originX: progressPercentage,\n    originY: progressPercentage,\n    originZ: px,\n};\n\nexport { transformValueTypes };\n//# sourceMappingURL=transform.mjs.map\n","/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nconst getValueAsType = (value, type) => {\n    return type && typeof value === \"number\"\n        ? type.transform(value)\n        : value;\n};\n\nexport { getValueAsType };\n//# sourceMappingURL=get-as-type.mjs.map\n","function isAnimationControls(v) {\n    return (v !== null &&\n        typeof v === \"object\" &&\n        typeof v.start === \"function\");\n}\n\nexport { isAnimationControls };\n//# sourceMappingURL=is-animation-controls.mjs.map\n","/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n    return typeof v === \"string\" || Array.isArray(v);\n}\n\nexport { isVariantLabel };\n//# sourceMappingURL=is-variant-label.mjs.map\n","const variantPriorityOrder = [\n    \"animate\",\n    \"whileInView\",\n    \"whileFocus\",\n    \"whileHover\",\n    \"whileTap\",\n    \"whileDrag\",\n    \"exit\",\n];\nconst variantProps = [\"initial\", ...variantPriorityOrder];\n\nexport { variantPriorityOrder, variantProps };\n//# sourceMappingURL=variant-props.mjs.map\n","import { isAnimationControls } from './is-animation-controls.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { variantProps } from './variant-props.mjs';\n\nfunction isControllingVariants(props) {\n    return (isAnimationControls(props.animate) ||\n        variantProps.some((name) => isVariantLabel(props[name])));\n}\nfunction isVariantNode(props) {\n    return Boolean(isControllingVariants(props) || props.variants);\n}\n\nexport { isControllingVariants, isVariantNode };\n//# sourceMappingURL=is-controlling-variants.mjs.map\n","import { warnOnce, isNumericalString, isZeroValueString, SubscriptionManager } from 'motion-utils';\nimport { microtask } from '../frameloop/microtask.mjs';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { motionValue } from '../value/index.mjs';\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\nimport { KeyframeResolver } from '../animation/keyframes/KeyframesResolver.mjs';\nimport { transformProps } from './utils/keys-transform.mjs';\nimport { complex } from '../value/types/complex/index.mjs';\nimport { findValueType } from '../value/types/utils/find.mjs';\nimport { getAnimatableNone } from '../value/types/utils/animatable-none.mjs';\nimport { createBox } from '../projection/geometry/models.mjs';\nimport { initPrefersReducedMotion } from './utils/reduced-motion/index.mjs';\nimport { visualElementStore } from './store.mjs';\nimport { isControllingVariants, isVariantNode } from './utils/is-controlling-variants.mjs';\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\nimport { resolveVariantFromProps } from './utils/resolve-variants.mjs';\nimport { hasReducedMotionListener, prefersReducedMotion } from './utils/reduced-motion/state.mjs';\nimport { frame, cancelFrame } from '../frameloop/frame.mjs';\n\nconst propEventHandlers = [\n    \"AnimationStart\",\n    \"AnimationComplete\",\n    \"Update\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutMeasure\",\n    \"LayoutAnimationStart\",\n    \"LayoutAnimationComplete\",\n];\n/**\n * Static feature definitions - can be injected by framework layer\n */\nlet featureDefinitions = {};\n/**\n * Set feature definitions for all VisualElements.\n * This should be called by the framework layer (e.g., framer-motion) during initialization.\n */\nfunction setFeatureDefinitions(definitions) {\n    featureDefinitions = definitions;\n}\n/**\n * Get the current feature definitions\n */\nfunction getFeatureDefinitions() {\n    return featureDefinitions;\n}\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\n        return {};\n    }\n    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }, options = {}) {\n        /**\n         * A reference to the current underlying Instance, e.g. a HTMLElement\n         * or Three.Mesh etc.\n         */\n        this.current = null;\n        /**\n         * A set containing references to this VisualElement's children.\n         */\n        this.children = new Set();\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        this.isVariantNode = false;\n        this.isControllingVariants = false;\n        /**\n         * Decides whether this VisualElement should animate in reduced motion\n         * mode.\n         *\n         * TODO: This is currently set on every individual VisualElement but feels\n         * like it could be set globally.\n         */\n        this.shouldReduceMotion = null;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        this.values = new Map();\n        this.KeyframeResolver = KeyframeResolver;\n        /**\n         * Cleanup functions for active features (hover/tap/exit etc)\n         */\n        this.features = {};\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        this.valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        this.prevMotionValues = {};\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        /**\n         * An object containing an unsubscribe function for each prop event subscription.\n         * For example, every \"Update\" event can have multiple subscribers via\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n         */\n        this.propEventSubscriptions = {};\n        this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n        this.render = () => {\n            if (!this.current)\n                return;\n            this.triggerBuild();\n            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n        };\n        this.renderScheduledAt = 0.0;\n        this.scheduleRender = () => {\n            const now = time.now();\n            if (this.renderScheduledAt < now) {\n                this.renderScheduledAt = now;\n                frame.render(this.render, false, true);\n            }\n        };\n        const { latestValues, renderState } = visualState;\n        this.latestValues = latestValues;\n        this.baseTarget = { ...latestValues };\n        this.initialValues = props.initial ? { ...latestValues } : {};\n        this.renderState = renderState;\n        this.parent = parent;\n        this.props = props;\n        this.presenceContext = presenceContext;\n        this.depth = parent ? parent.depth + 1 : 0;\n        this.reducedMotionConfig = reducedMotionConfig;\n        this.options = options;\n        this.blockInitialAnimation = Boolean(blockInitialAnimation);\n        this.isControllingVariants = isControllingVariants(props);\n        this.isVariantNode = isVariantNode(props);\n        if (this.isVariantNode) {\n            this.variantChildren = new Set();\n        }\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't necessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key]);\n            }\n        }\n    }\n    mount(instance) {\n        this.current = instance;\n        visualElementStore.set(instance, this);\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance);\n        }\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this);\n        }\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n        /**\n         * Determine reduced motion preference. Only initialize the matchMedia\n         * listener if we actually need the dynamic value (i.e., when config\n         * is neither \"never\" nor \"always\").\n         */\n        if (this.reducedMotionConfig === \"never\") {\n            this.shouldReduceMotion = false;\n        }\n        else if (this.reducedMotionConfig === \"always\") {\n            this.shouldReduceMotion = true;\n        }\n        else {\n            if (!hasReducedMotionListener.current) {\n                initPrefersReducedMotion();\n            }\n            this.shouldReduceMotion = prefersReducedMotion.current;\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\", \"reduced-motion-disabled\");\n        }\n        this.parent?.addChild(this);\n        this.update(this.props, this.presenceContext);\n    }\n    unmount() {\n        this.projection && this.projection.unmount();\n        cancelFrame(this.notifyUpdate);\n        cancelFrame(this.render);\n        this.valueSubscriptions.forEach((remove) => remove());\n        this.valueSubscriptions.clear();\n        this.removeFromVariantTree && this.removeFromVariantTree();\n        this.parent?.removeChild(this);\n        for (const key in this.events) {\n            this.events[key].clear();\n        }\n        for (const key in this.features) {\n            const feature = this.features[key];\n            if (feature) {\n                feature.unmount();\n                feature.isMounted = false;\n            }\n        }\n        this.current = null;\n    }\n    addChild(child) {\n        this.children.add(child);\n        this.enteringChildren ?? (this.enteringChildren = new Set());\n        this.enteringChildren.add(child);\n    }\n    removeChild(child) {\n        this.children.delete(child);\n        this.enteringChildren && this.enteringChildren.delete(child);\n    }\n    bindToMotionValue(key, value) {\n        if (this.valueSubscriptions.has(key)) {\n            this.valueSubscriptions.get(key)();\n        }\n        const valueIsTransform = transformProps.has(key);\n        if (valueIsTransform && this.onBindTransform) {\n            this.onBindTransform();\n        }\n        const removeOnChange = value.on(\"change\", (latestValue) => {\n            this.latestValues[key] = latestValue;\n            this.props.onUpdate && frame.preRender(this.notifyUpdate);\n            if (valueIsTransform && this.projection) {\n                this.projection.isTransformDirty = true;\n            }\n            this.scheduleRender();\n        });\n        let removeSyncCheck;\n        if (typeof window !== \"undefined\" && window.MotionCheckAppearSync) {\n            removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\n        }\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange();\n            if (removeSyncCheck)\n                removeSyncCheck();\n            if (value.owner)\n                value.stop();\n        });\n    }\n    sortNodePosition(other) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (!this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type) {\n            return 0;\n        }\n        return this.sortInstanceNodePosition(this.current, other.current);\n    }\n    updateFeatures() {\n        let key = \"animation\";\n        for (key in featureDefinitions) {\n            const featureDefinition = featureDefinitions[key];\n            if (!featureDefinition)\n                continue;\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition;\n            /**\n             * If this feature is enabled but not active, make a new instance.\n             */\n            if (!this.features[key] &&\n                FeatureConstructor &&\n                isEnabled(this.props)) {\n                this.features[key] = new FeatureConstructor(this);\n            }\n            /**\n             * If we have a feature, mount or update it.\n             */\n            if (this.features[key]) {\n                const feature = this.features[key];\n                if (feature.isMounted) {\n                    feature.update();\n                }\n                else {\n                    feature.mount();\n                    feature.isMounted = true;\n                }\n            }\n        }\n    }\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.props);\n    }\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox();\n    }\n    getStaticValue(key) {\n        return this.latestValues[key];\n    }\n    setStaticValue(key, value) {\n        this.latestValues[key] = value;\n    }\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(props, presenceContext) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender();\n        }\n        this.prevProps = this.props;\n        this.props = props;\n        this.prevPresenceContext = this.presenceContext;\n        this.presenceContext = presenceContext;\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i];\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]();\n                delete this.propEventSubscriptions[key];\n            }\n            const listenerName = (\"on\" + key);\n            const listener = props[listenerName];\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key, listener);\n            }\n        }\n        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps || {}, this), this.prevMotionValues);\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue();\n        }\n    }\n    getProps() {\n        return this.props;\n    }\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name) {\n        return this.props.variants ? this.props.variants[name] : undefined;\n    }\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition;\n    }\n    getTransformPagePoint() {\n        return this.props.transformPagePoint;\n    }\n    getClosestVariantNode() {\n        return this.isVariantNode\n            ? this\n            : this.parent\n                ? this.parent.getClosestVariantNode()\n                : undefined;\n    }\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child) {\n        const closestVariantNode = this.getClosestVariantNode();\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child);\n            return () => closestVariantNode.variantChildren.delete(child);\n        }\n    }\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key, value) {\n        // Remove existing value if it exists\n        const existingValue = this.values.get(key);\n        if (value !== existingValue) {\n            if (existingValue)\n                this.removeValue(key);\n            this.bindToMotionValue(key, value);\n            this.values.set(key, value);\n            this.latestValues[key] = value.get();\n        }\n    }\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key) {\n        this.values.delete(key);\n        const unsubscribe = this.valueSubscriptions.get(key);\n        if (unsubscribe) {\n            unsubscribe();\n            this.valueSubscriptions.delete(key);\n        }\n        delete this.latestValues[key];\n        this.removeValueFromRenderState(key, this.renderState);\n    }\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key) {\n        return this.values.has(key);\n    }\n    getValue(key, defaultValue) {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key];\n        }\n        let value = this.values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(defaultValue === null ? undefined : defaultValue, { owner: this });\n            this.addValue(key, value);\n        }\n        return value;\n    }\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key, target) {\n        let value = this.latestValues[key] !== undefined || !this.current\n            ? this.latestValues[key]\n            : this.getBaseTargetFromProps(this.props, key) ??\n                this.readValueFromInstance(this.current, key, this.options);\n        if (value !== undefined && value !== null) {\n            if (typeof value === \"string\" &&\n                (isNumericalString(value) || isZeroValueString(value))) {\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n                value = parseFloat(value);\n            }\n            else if (!findValueType(value) && complex.test(target)) {\n                value = getAnimatableNone(key, target);\n            }\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\n        }\n        return isMotionValue(value) ? value.get() : value;\n    }\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key, value) {\n        this.baseTarget[key] = value;\n    }\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key) {\n        const { initial } = this.props;\n        let valueFromInitial;\n        if (typeof initial === \"string\" || typeof initial === \"object\") {\n            const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);\n            if (variant) {\n                valueFromInitial = variant[key];\n            }\n        }\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial;\n        }\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key);\n        if (target !== undefined && !isMotionValue(target))\n            return target;\n        /**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key];\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        return this.events[eventName].add(callback);\n    }\n    notify(eventName, ...args) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args);\n        }\n    }\n    scheduleRenderMicrotask() {\n        microtask.render(this.render);\n    }\n}\n\nexport { VisualElement, getFeatureDefinitions, setFeatureDefinitions };\n//# sourceMappingURL=VisualElement.mjs.map\n","import { getValueAsType } from '../../../value/types/utils/get-as-type.mjs';\nimport { numberValueTypes } from '../../../value/types/maps/number.mjs';\nimport { transformPropOrder } from '../../utils/keys-transform.mjs';\n\nconst translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\",\n};\nconst numTransforms = transformPropOrder.length;\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(latestValues, transform, transformTemplate) {\n    // The transform string we're going to build into.\n    let transformString = \"\";\n    let transformIsDefault = true;\n    /**\n     * Loop over all possible transforms in order, adding the ones that\n     * are present to the transform string.\n     */\n    for (let i = 0; i < numTransforms; i++) {\n        const key = transformPropOrder[i];\n        const value = latestValues[key];\n        if (value === undefined)\n            continue;\n        let valueIsDefault = true;\n        if (typeof value === \"number\") {\n            valueIsDefault = value === (key.startsWith(\"scale\") ? 1 : 0);\n        }\n        else {\n            valueIsDefault = parseFloat(value) === 0;\n        }\n        if (!valueIsDefault || transformTemplate) {\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\n            if (!valueIsDefault) {\n                transformIsDefault = false;\n                const transformName = translateAlias[key] || key;\n                transformString += `${transformName}(${valueAsType}) `;\n            }\n            if (transformTemplate) {\n                transform[key] = valueAsType;\n            }\n        }\n    }\n    transformString = transformString.trim();\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    }\n    else if (transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\n\nexport { buildTransform };\n//# sourceMappingURL=build-transform.mjs.map\n","import { getValueAsType } from '../../../value/types/utils/get-as-type.mjs';\nimport { numberValueTypes } from '../../../value/types/maps/number.mjs';\nimport { transformProps } from '../../utils/keys-transform.mjs';\nimport { isCSSVariableName } from '../../../animation/utils/is-css-variable.mjs';\nimport { buildTransform } from './build-transform.mjs';\n\nfunction buildHTMLStyles(state, latestValues, transformTemplate) {\n    const { style, vars, transformOrigin } = state;\n    // Track whether we encounter any transform or transformOrigin values.\n    let hasTransform = false;\n    let hasTransformOrigin = false;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept separately for further processing.\n     */\n    for (const key in latestValues) {\n        const value = latestValues[key];\n        if (transformProps.has(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            continue;\n        }\n        else if (isCSSVariableName(key)) {\n            vars[key] = value;\n            continue;\n        }\n        else {\n            // Convert the value to its default value type, ie 0 -> \"0px\"\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\n            if (key.startsWith(\"origin\")) {\n                // If this is a transform origin, flag and enable further transform-origin processing\n                hasTransformOrigin = true;\n                transformOrigin[key] =\n                    valueAsType;\n            }\n            else {\n                style[key] = valueAsType;\n            }\n        }\n    }\n    if (!latestValues.transform) {\n        if (hasTransform || transformTemplate) {\n            style.transform = buildTransform(latestValues, state.transform, transformTemplate);\n        }\n        else if (style.transform) {\n            /**\n             * If we have previously created a transform but currently don't have any,\n             * reset transform style to none.\n             */\n            style.transform = \"none\";\n        }\n    }\n    /**\n     * Build a transformOrigin style. Uses the same defaults as the browser for\n     * undefined origins.\n     */\n    if (hasTransformOrigin) {\n        const { originX = \"50%\", originY = \"50%\", originZ = 0, } = transformOrigin;\n        style.transformOrigin = `${originX} ${originY} ${originZ}`;\n    }\n}\n\nexport { buildHTMLStyles };\n//# sourceMappingURL=build-styles.mjs.map\n","import { px } from '../../value/types/numbers/units.mjs';\n\nfunction pixelsToPercent(pixels, axis) {\n    if (axis.max === axis.min)\n        return 0;\n    return (pixels / (axis.max - axis.min)) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\nconst correctBorderRadius = {\n    correct: (latest, node) => {\n        if (!node.target)\n            return latest;\n        /**\n         * If latest is a string, if it's a percentage we can return immediately as it's\n         * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n         */\n        if (typeof latest === \"string\") {\n            if (px.test(latest)) {\n                latest = parseFloat(latest);\n            }\n            else {\n                return latest;\n            }\n        }\n        /**\n         * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n         * pixel value as a percentage of each axis\n         */\n        const x = pixelsToPercent(latest, node.target.x);\n        const y = pixelsToPercent(latest, node.target.y);\n        return `${x}% ${y}%`;\n    },\n};\n\nexport { correctBorderRadius, pixelsToPercent };\n//# sourceMappingURL=scale-border-radius.mjs.map\n","import { complex } from '../../value/types/complex/index.mjs';\nimport { mixNumber } from '../../utils/mix/number.mjs';\n\nconst correctBoxShadow = {\n    correct: (latest, { treeScale, projectionDelta }) => {\n        const original = latest;\n        const shadow = complex.parse(latest);\n        // TODO: Doesn't support multiple shadows\n        if (shadow.length > 5)\n            return original;\n        const template = complex.createTransformer(latest);\n        const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n        // Calculate the overall context scale\n        const xScale = projectionDelta.x.scale * treeScale.x;\n        const yScale = projectionDelta.y.scale * treeScale.y;\n        shadow[0 + offset] /= xScale;\n        shadow[1 + offset] /= yScale;\n        /**\n         * Ideally we'd correct x and y scales individually, but because blur and\n         * spread apply to both we have to take a scale average and apply that instead.\n         * We could potentially improve the outcome of this by incorporating the ratio between\n         * the two scales.\n         */\n        const averageScale = mixNumber(xScale, yScale, 0.5);\n        // Blur\n        if (typeof shadow[2 + offset] === \"number\")\n            shadow[2 + offset] /= averageScale;\n        // Spread\n        if (typeof shadow[3 + offset] === \"number\")\n            shadow[3 + offset] /= averageScale;\n        return template(shadow);\n    },\n};\n\nexport { correctBoxShadow };\n//# sourceMappingURL=scale-box-shadow.mjs.map\n","/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (usually a number from 0 to 1)\n\n  So progress = 0.5 would change\n\n  from -------- to\n\n  to\n\n  from ---- to\n\n  E.g. from = 10, to = 20, progress = 0.5 => 15\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\nconst mixNumber = (from, to, progress) => {\n    return from + (to - from) * progress;\n};\n\nexport { mixNumber };\n//# sourceMappingURL=number.mjs.map\n","import { isCSSVariableName } from '../../animation/utils/is-css-variable.mjs';\nimport { correctBorderRadius } from './scale-border-radius.mjs';\nimport { correctBoxShadow } from './scale-box-shadow.mjs';\n\nconst scaleCorrectors = {\n    borderRadius: {\n        ...correctBorderRadius,\n        applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n        ],\n    },\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow,\n};\nfunction addScaleCorrector(correctors) {\n    for (const key in correctors) {\n        scaleCorrectors[key] = correctors[key];\n        if (isCSSVariableName(key)) {\n            scaleCorrectors[key].isCSSVariable = true;\n        }\n    }\n}\n\nexport { addScaleCorrector, scaleCorrectors };\n//# sourceMappingURL=scale-correction.mjs.map\n","import { transformProps } from './keys-transform.mjs';\nimport { scaleCorrectors } from '../../projection/styles/scale-correction.mjs';\nexport { addScaleCorrector } from '../../projection/styles/scale-correction.mjs';\n\nfunction isForcedMotionValue(key, { layout, layoutId }) {\n    return (transformProps.has(key) ||\n        key.startsWith(\"origin\") ||\n        ((layout || layoutId !== undefined) &&\n            (!!scaleCorrectors[key] || key === \"opacity\")));\n}\n\nexport { isForcedMotionValue, scaleCorrectors };\n//# sourceMappingURL=is-forced-motion-value.mjs.map\n","import { isMotionValue } from '../../../value/utils/is-motion-value.mjs';\nimport { isForcedMotionValue } from '../../utils/is-forced-motion-value.mjs';\n\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n    const style = props.style;\n    const prevStyle = prevProps?.style;\n    const newValues = {};\n    if (!style)\n        return newValues;\n    for (const key in style) {\n        if (isMotionValue(style[key]) ||\n            (prevStyle && isMotionValue(prevStyle[key])) ||\n            isForcedMotionValue(key, props) ||\n            visualElement?.getValue(key)?.liveStyle !== undefined) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\n\nexport { scrapeMotionValuesFromProps };\n//# sourceMappingURL=scrape-motion-values.mjs.map\n","const dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\",\n};\nconst camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\",\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n *\n * Note: We use unitless values for stroke-dasharray and stroke-dashoffset\n * because Safari incorrectly scales px values when the page is zoomed.\n */\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n    // Normalise path length by setting SVG attribute pathLength to 1\n    attrs.pathLength = 1;\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    const keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset (unitless to avoid Safari zoom bug)\n    attrs[keys.offset] = `${-offset}`;\n    // Build the dash array (unitless to avoid Safari zoom bug)\n    attrs[keys.array] = `${length} ${spacing}`;\n}\n\nexport { buildSVGPath };\n//# sourceMappingURL=path.mjs.map\n","import { buildHTMLStyles } from '../../html/utils/build-styles.mjs';\nimport { buildSVGPath } from './path.mjs';\n\n/**\n * CSS Motion Path properties that should remain as CSS styles on SVG elements.\n */\nconst cssMotionPathProperties = [\n    \"offsetDistance\",\n    \"offsetPath\",\n    \"offsetRotate\",\n    \"offsetAnchor\",\n];\n/**\n * Build SVG visual attributes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, { attrX, attrY, attrScale, pathLength, pathSpacing = 1, pathOffset = 0, \n// This is object creation, which we try to avoid per-frame.\n...latest }, isSVGTag, transformTemplate, styleProp) {\n    buildHTMLStyles(state, latest, transformTemplate);\n    /**\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\n     * as normal HTML tags.\n     */\n    if (isSVGTag) {\n        if (state.style.viewBox) {\n            state.attrs.viewBox = state.style.viewBox;\n        }\n        return;\n    }\n    state.attrs = state.style;\n    state.style = {};\n    const { attrs, style } = state;\n    /**\n     * However, we apply transforms as CSS transforms.\n     * So if we detect a transform, transformOrigin we take it from attrs and copy it into style.\n     */\n    if (attrs.transform) {\n        style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    if (style.transform || attrs.transformOrigin) {\n        style.transformOrigin = attrs.transformOrigin ?? \"50% 50%\";\n        delete attrs.transformOrigin;\n    }\n    if (style.transform) {\n        /**\n         * SVG's element transform-origin uses its own median as a reference.\n         * Therefore, transformBox becomes a fill-box\n         */\n        style.transformBox = styleProp?.transformBox ?? \"fill-box\";\n        delete attrs.transformBox;\n    }\n    for (const key of cssMotionPathProperties) {\n        if (attrs[key] !== undefined) {\n            style[key] = attrs[key];\n            delete attrs[key];\n        }\n    }\n    // Render attrX/attrY/attrScale as attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    if (attrScale !== undefined)\n        attrs.scale = attrScale;\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\nexport { buildSVGAttrs };\n//# sourceMappingURL=build-attrs.mjs.map\n","import { isMotionValue } from './is-motion-value.mjs';\n\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n */\nfunction resolveMotionValue(value) {\n    return isMotionValue(value) ? value.get() : value;\n}\n\nexport { resolveMotionValue };\n//# sourceMappingURL=resolve-motion-value.mjs.map\n","\"use client\";\nimport { useContext, useMemo } from \"react\";\nimport { MotionContext } from \".\";\nimport { getCurrentTreeVariants } from \"./utils\";\nexport function useCreateMotionContext(props) {\n    const { initial, animate } = getCurrentTreeVariants(props, useContext(MotionContext));\n    return useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);\n}\nfunction variantLabelsAsDependency(prop) {\n    return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n//# sourceMappingURL=create.js.map","import { isControllingVariants, isVariantLabel } from \"motion-dom\";\nexport function getCurrentTreeVariants(props, context) {\n    if (isControllingVariants(props)) {\n        const { initial, animate } = props;\n        return {\n            initial: initial === false || isVariantLabel(initial)\n                ? initial\n                : undefined,\n            animate: isVariantLabel(animate) ? animate : undefined,\n        };\n    }\n    return props.inherit !== false ? context : {};\n}\n//# sourceMappingURL=utils.js.map","export const createHtmlRenderState = () => ({\n    style: {},\n    transform: {},\n    transformOrigin: {},\n    vars: {},\n});\n//# sourceMappingURL=create-render-state.js.map","\"use client\";\nimport { buildHTMLStyles, isForcedMotionValue, isMotionValue } from \"motion-dom\";\nimport { useMemo } from \"react\";\nimport { createHtmlRenderState } from \"./utils/create-render-state\";\nexport function copyRawValuesOnly(target, source, props) {\n    for (const key in source) {\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key];\n        }\n    }\n}\nfunction useInitialMotionValues({ transformTemplate }, visualState) {\n    return useMemo(() => {\n        const state = createHtmlRenderState();\n        buildHTMLStyles(state, visualState, transformTemplate);\n        return Object.assign({}, state.vars, state.style);\n    }, [visualState]);\n}\nfunction useStyle(props, visualState) {\n    const styleProp = props.style || {};\n    const style = {};\n    /**\n     * Copy non-Motion Values straight into style\n     */\n    copyRawValuesOnly(style, styleProp, props);\n    Object.assign(style, useInitialMotionValues(props, visualState));\n    return style;\n}\nexport function useHTMLProps(props, visualState) {\n    // The `any` isn't ideal but it is the type of createElement props argument\n    const htmlProps = {};\n    const style = useStyle(props, visualState);\n    if (props.drag && props.dragListener !== false) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n        // Disable text selection\n        style.userSelect =\n            style.WebkitUserSelect =\n                style.WebkitTouchCallout =\n                    \"none\";\n        // Disable scrolling on the draggable direction\n        style.touchAction =\n            props.drag === true\n                ? \"none\"\n                : `pan-${props.drag === \"x\" ? \"y\" : \"x\"}`;\n    }\n    if (props.tabIndex === undefined &&\n        (props.onTap || props.onTapStart || props.whileTap)) {\n        htmlProps.tabIndex = 0;\n    }\n    htmlProps.style = style;\n    return htmlProps;\n}\n//# sourceMappingURL=use-props.js.map","import { createHtmlRenderState } from \"../../html/utils/create-render-state\";\nexport const createSvgRenderState = () => ({\n    ...createHtmlRenderState(),\n    attrs: {},\n});\n//# sourceMappingURL=create-render-state.js.map","\"use client\";\nimport { buildSVGAttrs, isSVGTag } from \"motion-dom\";\nimport { useMemo } from \"react\";\nimport { copyRawValuesOnly } from \"../html/use-props\";\nimport { createSvgRenderState } from \"./utils/create-render-state\";\nexport function useSVGProps(props, visualState, _isStatic, Component) {\n    const visualProps = useMemo(() => {\n        const state = createSvgRenderState();\n        buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate, props.style);\n        return {\n            ...state.attrs,\n            style: { ...state.style },\n        };\n    }, [visualState]);\n    if (props.style) {\n        const rawStyles = {};\n        copyRawValuesOnly(rawStyles, props.style, props);\n        visualProps.style = { ...rawStyles, ...visualProps.style };\n    }\n    return visualProps;\n}\n//# sourceMappingURL=use-props.js.map","const isSVGTag = (tag) => typeof tag === \"string\" && tag.toLowerCase() === \"svg\";\n\nexport { isSVGTag };\n//# sourceMappingURL=is-svg-tag.mjs.map\n","/**\n * A list of all valid MotionProps.\n *\n * @privateRemarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\nconst validMotionProps = new Set([\n    \"animate\",\n    \"exit\",\n    \"variants\",\n    \"initial\",\n    \"style\",\n    \"values\",\n    \"variants\",\n    \"transition\",\n    \"transformTemplate\",\n    \"custom\",\n    \"inherit\",\n    \"onBeforeLayoutMeasure\",\n    \"onAnimationStart\",\n    \"onAnimationComplete\",\n    \"onUpdate\",\n    \"onDragStart\",\n    \"onDrag\",\n    \"onDragEnd\",\n    \"onMeasureDragConstraints\",\n    \"onDirectionLock\",\n    \"onDragTransitionEnd\",\n    \"_dragX\",\n    \"_dragY\",\n    \"onHoverStart\",\n    \"onHoverEnd\",\n    \"onViewportEnter\",\n    \"onViewportLeave\",\n    \"globalTapTarget\",\n    \"ignoreStrict\",\n    \"viewport\",\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\nexport function isValidMotionProp(key) {\n    return (key.startsWith(\"while\") ||\n        (key.startsWith(\"drag\") && key !== \"draggable\") ||\n        key.startsWith(\"layout\") ||\n        key.startsWith(\"onTap\") ||\n        key.startsWith(\"onPan\") ||\n        key.startsWith(\"onLayout\") ||\n        validMotionProps.has(key));\n}\n//# sourceMappingURL=valid-prop.js.map","import { isValidMotionProp } from \"../../../motion/utils/valid-prop\";\nlet shouldForward = (key) => !isValidMotionProp(key);\nexport function loadExternalIsValidProp(isValidProp) {\n    if (typeof isValidProp !== \"function\")\n        return;\n    // Explicitly filter our events\n    shouldForward = (key) => key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key);\n}\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\ntry {\n    /**\n     * We attempt to import this package but require won't be defined in esm environments, in that case\n     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed\n     * in favour of explicit injection.\n     */\n    loadExternalIsValidProp(require(\"@emotion/is-prop-valid\").default);\n}\ncatch {\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nexport function filterProps(props, isDom, forwardMotionProps) {\n    const filteredProps = {};\n    for (const key in props) {\n        /**\n         * values is considered a valid prop by Emotion, so if it's present\n         * this will be rendered out to the DOM unless explicitly filtered.\n         *\n         * We check the type as it could be used with the `feColorMatrix`\n         * element, which we support.\n         */\n        if (key === \"values\" && typeof props.values === \"object\")\n            continue;\n        if (shouldForward(key) ||\n            (forwardMotionProps === true && isValidMotionProp(key)) ||\n            (!isDom && !isValidMotionProp(key)) ||\n            // If trying to use native HTML drag events, forward drag listeners\n            (props[\"draggable\"] &&\n                key.startsWith(\"onDrag\"))) {\n            filteredProps[key] =\n                props[key];\n        }\n    }\n    return filteredProps;\n}\n//# sourceMappingURL=filter-props.js.map","/**\n * We keep these listed separately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */\nexport const lowercaseSVGElements = [\n    \"animate\",\n    \"circle\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"filter\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"rect\",\n    \"stop\",\n    \"switch\",\n    \"symbol\",\n    \"svg\",\n    \"text\",\n    \"tspan\",\n    \"use\",\n    \"view\",\n];\n//# sourceMappingURL=lowercase-elements.js.map","import { lowercaseSVGElements } from \"../../svg/lowercase-elements\";\nexport function isSVGComponent(Component) {\n    if (\n    /**\n     * If it's not a string, it's a custom React component. Currently we only support\n     * HTML custom React components.\n     */\n    typeof Component !== \"string\" ||\n        /**\n         * If it contains a dash, the element is a custom HTML webcomponent.\n         */\n        Component.includes(\"-\")) {\n        return false;\n    }\n    else if (\n    /**\n     * If it's in our list of lowercase SVG tags, it's an SVG component\n     */\n    lowercaseSVGElements.indexOf(Component) > -1 ||\n        /**\n         * If it contains a capital letter, it's an SVG component\n         */\n        /[A-Z]/u.test(Component)) {\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=is-svg-component.js.map","\"use client\";\nimport { isMotionValue } from \"motion-dom\";\nimport { Fragment, createElement, useMemo } from \"react\";\nimport { useHTMLProps } from \"../html/use-props\";\nimport { useSVGProps } from \"../svg/use-props\";\nimport { filterProps } from \"./utils/filter-props\";\nimport { isSVGComponent } from \"./utils/is-svg-component\";\nexport function useRender(Component, props, ref, { latestValues, }, isStatic, forwardMotionProps = false, isSVG) {\n    const useVisualProps = (isSVG ?? isSVGComponent(Component)) ? useSVGProps : useHTMLProps;\n    const visualProps = useVisualProps(props, latestValues, isStatic, Component);\n    const filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n    const elementProps = Component !== Fragment ? { ...filteredProps, ...visualProps, ref } : {};\n    /**\n     * If component has been handed a motion value as its child,\n     * memoise its initial value and render that. Subsequent updates\n     * will be handled by the onChange handler\n     */\n    const { children } = props;\n    const renderedChildren = useMemo(() => (isMotionValue(children) ? children.get() : children), [children]);\n    return createElement(Component, {\n        ...elementProps,\n        children: renderedChildren,\n    });\n}\n//# sourceMappingURL=use-render.js.map","\"use client\";\nimport { createContext } from \"react\";\n/**\n * @public\n */\nexport const PresenceContext = \n/* @__PURE__ */ createContext(null);\n//# sourceMappingURL=PresenceContext.js.map","\"use client\";\nimport { isAnimationControls, isControllingVariants as checkIsControllingVariants, isVariantNode as checkIsVariantNode, resolveVariantFromProps, } from \"motion-dom\";\nimport { useContext } from \"react\";\nimport { MotionContext } from \"../../context/MotionContext\";\nimport { PresenceContext, } from \"../../context/PresenceContext\";\nimport { useConstant } from \"../../utils/use-constant\";\nimport { resolveMotionValue } from \"motion-dom\";\nfunction makeState({ scrapeMotionValuesFromProps, createRenderState, }, props, context, presenceContext) {\n    const state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState(),\n    };\n    return state;\n}\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    const values = {};\n    const motionValues = scrapeMotionValues(props, {});\n    for (const key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    let { initial, animate } = props;\n    const isControllingVariants = checkIsControllingVariants(props);\n    const isVariantNode = checkIsVariantNode(props);\n    if (context &&\n        isVariantNode &&\n        !isControllingVariants &&\n        props.inherit !== false) {\n        if (initial === undefined)\n            initial = context.initial;\n        if (animate === undefined)\n            animate = context.animate;\n    }\n    let isInitialAnimationBlocked = presenceContext\n        ? presenceContext.initial === false\n        : false;\n    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n    const variantToSet = isInitialAnimationBlocked ? animate : initial;\n    if (variantToSet &&\n        typeof variantToSet !== \"boolean\" &&\n        !isAnimationControls(variantToSet)) {\n        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n        for (let i = 0; i < list.length; i++) {\n            const resolved = resolveVariantFromProps(props, list[i]);\n            if (resolved) {\n                const { transitionEnd, transition, ...target } = resolved;\n                for (const key in target) {\n                    let valueTarget = target[key];\n                    if (Array.isArray(valueTarget)) {\n                        /**\n                         * Take final keyframe if the initial animation is blocked because\n                         * we want to initialise at the end of that blocked animation.\n                         */\n                        const index = isInitialAnimationBlocked\n                            ? valueTarget.length - 1\n                            : 0;\n                        valueTarget = valueTarget[index];\n                    }\n                    if (valueTarget !== null) {\n                        values[key] = valueTarget;\n                    }\n                }\n                for (const key in transitionEnd) {\n                    values[key] = transitionEnd[key];\n                }\n            }\n        }\n    }\n    return values;\n}\nexport const makeUseVisualState = (config) => (props, isStatic) => {\n    const context = useContext(MotionContext);\n    const presenceContext = useContext(PresenceContext);\n    const make = () => makeState(config, props, context, presenceContext);\n    return isStatic ? make() : useConstant(make);\n};\n//# sourceMappingURL=use-visual-state.js.map","\"use client\";\nimport { useRef } from \"react\";\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nexport function useConstant(init) {\n    const ref = useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n//# sourceMappingURL=use-constant.js.map","\"use client\";\nimport { scrapeHTMLMotionValuesFromProps } from \"motion-dom\";\nimport { makeUseVisualState } from \"../../motion/utils/use-visual-state\";\nimport { createHtmlRenderState } from \"./utils/create-render-state\";\nexport const useHTMLVisualState = /*@__PURE__*/ makeUseVisualState({\n    scrapeMotionValuesFromProps: scrapeHTMLMotionValuesFromProps,\n    createRenderState: createHtmlRenderState,\n});\n//# sourceMappingURL=use-html-visual-state.js.map","\"use client\";\nimport { scrapeSVGMotionValuesFromProps } from \"motion-dom\";\nimport { makeUseVisualState } from \"../../motion/utils/use-visual-state\";\nimport { createSvgRenderState } from \"./utils/create-render-state\";\nexport const useSVGVisualState = /*@__PURE__*/ makeUseVisualState({\n    scrapeMotionValuesFromProps: scrapeSVGMotionValuesFromProps,\n    createRenderState: createSvgRenderState,\n});\n//# sourceMappingURL=use-svg-visual-state.js.map","import { isMotionValue } from '../../../value/utils/is-motion-value.mjs';\nimport { transformPropOrder } from '../../utils/keys-transform.mjs';\nimport { scrapeMotionValuesFromProps as scrapeMotionValuesFromProps$1 } from '../../html/utils/scrape-motion-values.mjs';\n\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n    const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);\n    for (const key in props) {\n        if (isMotionValue(props[key]) ||\n            isMotionValue(prevProps[key])) {\n            const targetKey = transformPropOrder.indexOf(key) !== -1\n                ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1)\n                : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\n\nexport { scrapeMotionValuesFromProps };\n//# sourceMappingURL=scrape-motion-values.mjs.map\n","export const isBrowser = typeof window !== \"undefined\";\n//# sourceMappingURL=is-browser.js.map","import { getFeatureDefinitions, setFeatureDefinitions } from \"motion-dom\";\nconst featureProps = {\n    animation: [\n        \"animate\",\n        \"variants\",\n        \"whileHover\",\n        \"whileTap\",\n        \"exit\",\n        \"whileInView\",\n        \"whileFocus\",\n        \"whileDrag\",\n    ],\n    exit: [\"exit\"],\n    drag: [\"drag\", \"dragControls\"],\n    focus: [\"whileFocus\"],\n    hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\n    tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\n    pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\n    inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\n    layout: [\"layout\", \"layoutId\"],\n};\nlet isInitialized = false;\n/**\n * Initialize feature definitions with isEnabled checks.\n * This must be called before any motion components are rendered.\n */\nexport function initFeatureDefinitions() {\n    if (isInitialized)\n        return;\n    const initialFeatureDefinitions = {};\n    for (const key in featureProps) {\n        initialFeatureDefinitions[key] = {\n            isEnabled: (props) => featureProps[key].some((name) => !!props[name]),\n        };\n    }\n    setFeatureDefinitions(initialFeatureDefinitions);\n    isInitialized = true;\n}\n/**\n * Get the current feature definitions, initializing if needed.\n */\nexport function getInitializedFeatureDefinitions() {\n    initFeatureDefinitions();\n    return getFeatureDefinitions();\n}\n//# sourceMappingURL=definitions.js.map","export const motionComponentSymbol = Symbol.for(\"motionComponentSymbol\");\n//# sourceMappingURL=symbol.js.map","\"use client\";\nimport { useCallback, useInsertionEffect, useRef } from \"react\";\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nexport function useMotionRef(visualState, visualElement, externalRef) {\n    /**\n     * Store externalRef in a ref to avoid including it in the useCallback\n     * dependency array. Including externalRef in dependencies causes issues\n     * with libraries like Radix UI that create new callback refs on each render\n     * when using asChild - this would cause the callback to be recreated,\n     * triggering element remounts and breaking AnimatePresence exit animations.\n     */\n    const externalRefContainer = useRef(externalRef);\n    useInsertionEffect(() => {\n        externalRefContainer.current = externalRef;\n    });\n    // Store cleanup function returned by callback refs (React 19 feature)\n    const refCleanup = useRef(null);\n    return useCallback((instance) => {\n        if (instance) {\n            visualState.onMount?.(instance);\n        }\n        if (visualElement) {\n            instance ? visualElement.mount(instance) : visualElement.unmount();\n        }\n        const ref = externalRefContainer.current;\n        if (typeof ref === \"function\") {\n            if (instance) {\n                const cleanup = ref(instance);\n                if (typeof cleanup === \"function\") {\n                    refCleanup.current = cleanup;\n                }\n            }\n            else if (refCleanup.current) {\n                refCleanup.current();\n                refCleanup.current = null;\n            }\n            else {\n                ref(instance);\n            }\n        }\n        else if (ref) {\n            ;\n            ref.current = instance;\n        }\n    }, [visualElement]);\n}\n//# sourceMappingURL=use-motion-ref.js.map","\"use client\";\nimport { createContext } from \"react\";\n/**\n * Internal, exported only for usage in Framer\n */\nexport const SwitchLayoutGroupContext = createContext({});\n//# sourceMappingURL=SwitchLayoutGroupContext.js.map","export function isRefObject(ref) {\n    return (ref &&\n        typeof ref === \"object\" &&\n        Object.prototype.hasOwnProperty.call(ref, \"current\"));\n}\n//# sourceMappingURL=is-ref-object.js.map","\"use client\";\nimport { useEffect, useLayoutEffect } from \"react\";\nimport { isBrowser } from \"./is-browser\";\nexport const useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;\n//# sourceMappingURL=use-isomorphic-effect.js.map","\"use client\";\nimport { optimizedAppearDataAttribute, } from \"motion-dom\";\nimport { useContext, useEffect, useInsertionEffect, useRef } from \"react\";\nimport { LazyContext } from \"../../context/LazyContext\";\nimport { MotionConfigContext } from \"../../context/MotionConfigContext\";\nimport { MotionContext } from \"../../context/MotionContext\";\nimport { PresenceContext } from \"../../context/PresenceContext\";\nimport { SwitchLayoutGroupContext, } from \"../../context/SwitchLayoutGroupContext\";\nimport { isRefObject } from \"../../utils/is-ref-object\";\nimport { useIsomorphicLayoutEffect } from \"../../utils/use-isomorphic-effect\";\nexport function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor, isSVG) {\n    const { visualElement: parent } = useContext(MotionContext);\n    const lazyContext = useContext(LazyContext);\n    const presenceContext = useContext(PresenceContext);\n    const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;\n    const visualElementRef = useRef(null);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    createVisualElement =\n        createVisualElement ||\n            lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState,\n            parent,\n            props,\n            presenceContext,\n            blockInitialAnimation: presenceContext\n                ? presenceContext.initial === false\n                : false,\n            reducedMotionConfig,\n            isSVG,\n        });\n    }\n    const visualElement = visualElementRef.current;\n    /**\n     * Load Motion gesture and animation features. These are rendered as renderless\n     * components so each feature can optionally make use of React lifecycle methods.\n     */\n    const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\n    if (visualElement &&\n        !visualElement.projection &&\n        ProjectionNodeConstructor &&\n        (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\n        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n    }\n    const isMounted = useRef(false);\n    useInsertionEffect(() => {\n        /**\n         * Check the component has already mounted before calling\n         * `update` unnecessarily. This ensures we skip the initial update.\n         */\n        if (visualElement && isMounted.current) {\n            visualElement.update(props, presenceContext);\n        }\n    });\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */\n    const optimisedAppearId = props[optimizedAppearDataAttribute];\n    const wantsHandoff = useRef(Boolean(optimisedAppearId) &&\n        !window.MotionHandoffIsComplete?.(optimisedAppearId) &&\n        window.MotionHasOptimisedAnimation?.(optimisedAppearId));\n    useIsomorphicLayoutEffect(() => {\n        if (!visualElement)\n            return;\n        isMounted.current = true;\n        window.MotionIsMounted = true;\n        visualElement.updateFeatures();\n        visualElement.scheduleRenderMicrotask();\n        /**\n         * Ideally this function would always run in a useEffect.\n         *\n         * However, if we have optimised appear animations to handoff from,\n         * it needs to happen synchronously to ensure there's no flash of\n         * incorrect styles in the event of a hydration error.\n         *\n         * So if we detect a situtation where optimised appear animations\n         * are running, we use useLayoutEffect to trigger animations.\n         */\n        if (wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n    });\n    useEffect(() => {\n        if (!visualElement)\n            return;\n        if (!wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n        if (wantsHandoff.current) {\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\n            queueMicrotask(() => {\n                window.MotionHandoffMarkAsComplete?.(optimisedAppearId);\n            });\n            wantsHandoff.current = false;\n        }\n        /**\n         * Now we've finished triggering animations for this element we\n         * can wipe the enteringChildren set for the next render.\n         */\n        visualElement.enteringChildren = undefined;\n    });\n    return visualElement;\n}\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade, } = props;\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"]\n        ? undefined\n        : getClosestProjectingNode(visualElement.parent));\n    visualElement.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\n        visualElement,\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig,\n        crossfade: layoutCrossfade,\n        layoutScroll,\n        layoutRoot,\n    });\n}\nfunction getClosestProjectingNode(visualElement) {\n    if (!visualElement)\n        return undefined;\n    return visualElement.options.allowProjection !== false\n        ? visualElement.projection\n        : getClosestProjectingNode(visualElement.parent);\n}\n//# sourceMappingURL=use-visual-element.js.map","\"use client\";\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { invariant, warning } from \"motion-utils\";\nimport { forwardRef, useContext } from \"react\";\nimport { LayoutGroupContext } from \"../context/LayoutGroupContext\";\nimport { LazyContext } from \"../context/LazyContext\";\nimport { MotionConfigContext } from \"../context/MotionConfigContext\";\nimport { MotionContext } from \"../context/MotionContext\";\nimport { useCreateMotionContext } from \"../context/MotionContext/create\";\nimport { useRender } from \"../render/dom/use-render\";\nimport { isSVGComponent } from \"../render/dom/utils/is-svg-component\";\nimport { useHTMLVisualState } from \"../render/html/use-html-visual-state\";\nimport { useSVGVisualState } from \"../render/svg/use-svg-visual-state\";\nimport { isBrowser } from \"../utils/is-browser\";\nimport { getInitializedFeatureDefinitions } from \"./features/definitions\";\nimport { loadFeatures } from \"./features/load-features\";\nimport { motionComponentSymbol } from \"./utils/symbol\";\nimport { useMotionRef } from \"./utils/use-motion-ref\";\nimport { useVisualElement } from \"./utils/use-visual-element\";\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n */\nexport function createMotionComponent(Component, { forwardMotionProps = false, type } = {}, preloadedFeatures, createVisualElement) {\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    /**\n     * Determine whether to use SVG or HTML rendering based on:\n     * 1. Explicit `type` option (highest priority)\n     * 2. Auto-detection via `isSVGComponent`\n     */\n    const isSVG = type ? type === \"svg\" : isSVGComponent(Component);\n    const useVisualState = isSVG ? useSVGVisualState : useHTMLVisualState;\n    function MotionDOMComponent(props, externalRef) {\n        /**\n         * If we need to measure the element we load this functionality in a\n         * separate class component in order to gain access to getSnapshotBeforeUpdate.\n         */\n        let MeasureLayout;\n        const configAndProps = {\n            ...useContext(MotionConfigContext),\n            ...props,\n            layoutId: useLayoutId(props),\n        };\n        const { isStatic } = configAndProps;\n        const context = useCreateMotionContext(props);\n        const visualState = useVisualState(props, isStatic);\n        if (!isStatic && isBrowser) {\n            useStrictMode(configAndProps, preloadedFeatures);\n            const layoutProjection = getProjectionFunctionality(configAndProps);\n            MeasureLayout = layoutProjection.MeasureLayout;\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode, isSVG);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (_jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout && context.visualElement ? (_jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps, isSVG)] }));\n    }\n    MotionDOMComponent.displayName = `motion.${typeof Component === \"string\"\n        ? Component\n        : `create(${Component.displayName ?? Component.name ?? \"\"})`}`;\n    const ForwardRefMotionComponent = forwardRef(MotionDOMComponent);\n    ForwardRefMotionComponent[motionComponentSymbol] = Component;\n    return ForwardRefMotionComponent;\n}\nfunction useLayoutId({ layoutId }) {\n    const layoutGroupId = useContext(LayoutGroupContext).id;\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + \"-\" + layoutId\n        : layoutId;\n}\nfunction useStrictMode(configAndProps, preloadedFeatures) {\n    const isStrict = useContext(LazyContext).strict;\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n    if (process.env.NODE_ENV !== \"production\" &&\n        preloadedFeatures &&\n        isStrict) {\n        const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n        configAndProps.ignoreStrict\n            ? warning(false, strictMessage, \"lazy-strict-mode\")\n            : invariant(false, strictMessage, \"lazy-strict-mode\");\n    }\n}\nfunction getProjectionFunctionality(props) {\n    const featureDefinitions = getInitializedFeatureDefinitions();\n    const { drag, layout } = featureDefinitions;\n    if (!drag && !layout)\n        return {};\n    const combined = { ...drag, ...layout };\n    return {\n        MeasureLayout: drag?.isEnabled(props) || layout?.isEnabled(props)\n            ? combined.MeasureLayout\n            : undefined,\n        ProjectionNode: combined.ProjectionNode,\n    };\n}\n//# sourceMappingURL=index.js.map","import { createMotionComponent } from \"../../../motion\";\nexport function createMinimalMotionComponent(Component, options) {\n    return createMotionComponent(Component, options);\n}\n//# sourceMappingURL=create.js.map","\"use client\";\nimport { createMinimalMotionComponent } from \"./create\";\n/**\n * HTML components\n */\nexport const MotionA = /*@__PURE__*/ createMinimalMotionComponent(\"a\");\nexport const MotionAbbr = /*@__PURE__*/ createMinimalMotionComponent(\"abbr\");\nexport const MotionAddress = \n/*@__PURE__*/ createMinimalMotionComponent(\"address\");\nexport const MotionArea = /*@__PURE__*/ createMinimalMotionComponent(\"area\");\nexport const MotionArticle = \n/*@__PURE__*/ createMinimalMotionComponent(\"article\");\nexport const MotionAside = /*@__PURE__*/ createMinimalMotionComponent(\"aside\");\nexport const MotionAudio = /*@__PURE__*/ createMinimalMotionComponent(\"audio\");\nexport const MotionB = /*@__PURE__*/ createMinimalMotionComponent(\"b\");\nexport const MotionBase = /*@__PURE__*/ createMinimalMotionComponent(\"base\");\nexport const MotionBdi = /*@__PURE__*/ createMinimalMotionComponent(\"bdi\");\nexport const MotionBdo = /*@__PURE__*/ createMinimalMotionComponent(\"bdo\");\nexport const MotionBig = /*@__PURE__*/ createMinimalMotionComponent(\"big\");\nexport const MotionBlockquote = \n/*@__PURE__*/ createMinimalMotionComponent(\"blockquote\");\nexport const MotionBody = /*@__PURE__*/ createMinimalMotionComponent(\"body\");\nexport const MotionButton = /*@__PURE__*/ createMinimalMotionComponent(\"button\");\nexport const MotionCanvas = /*@__PURE__*/ createMinimalMotionComponent(\"canvas\");\nexport const MotionCaption = \n/*@__PURE__*/ createMinimalMotionComponent(\"caption\");\nexport const MotionCite = /*@__PURE__*/ createMinimalMotionComponent(\"cite\");\nexport const MotionCode = /*@__PURE__*/ createMinimalMotionComponent(\"code\");\nexport const MotionCol = /*@__PURE__*/ createMinimalMotionComponent(\"col\");\nexport const MotionColgroup = \n/*@__PURE__*/ createMinimalMotionComponent(\"colgroup\");\nexport const MotionData = /*@__PURE__*/ createMinimalMotionComponent(\"data\");\nexport const MotionDatalist = \n/*@__PURE__*/ createMinimalMotionComponent(\"datalist\");\nexport const MotionDd = /*@__PURE__*/ createMinimalMotionComponent(\"dd\");\nexport const MotionDel = /*@__PURE__*/ createMinimalMotionComponent(\"del\");\nexport const MotionDetails = \n/*@__PURE__*/ createMinimalMotionComponent(\"details\");\nexport const MotionDfn = /*@__PURE__*/ createMinimalMotionComponent(\"dfn\");\nexport const MotionDialog = /*@__PURE__*/ createMinimalMotionComponent(\"dialog\");\nexport const MotionDiv = /*@__PURE__*/ createMinimalMotionComponent(\"div\");\nexport const MotionDl = /*@__PURE__*/ createMinimalMotionComponent(\"dl\");\nexport const MotionDt = /*@__PURE__*/ createMinimalMotionComponent(\"dt\");\nexport const MotionEm = /*@__PURE__*/ createMinimalMotionComponent(\"em\");\nexport const MotionEmbed = /*@__PURE__*/ createMinimalMotionComponent(\"embed\");\nexport const MotionFieldset = \n/*@__PURE__*/ createMinimalMotionComponent(\"fieldset\");\nexport const MotionFigcaption = \n/*@__PURE__*/ createMinimalMotionComponent(\"figcaption\");\nexport const MotionFigure = /*@__PURE__*/ createMinimalMotionComponent(\"figure\");\nexport const MotionFooter = /*@__PURE__*/ createMinimalMotionComponent(\"footer\");\nexport const MotionForm = /*@__PURE__*/ createMinimalMotionComponent(\"form\");\nexport const MotionH1 = /*@__PURE__*/ createMinimalMotionComponent(\"h1\");\nexport const MotionH2 = /*@__PURE__*/ createMinimalMotionComponent(\"h2\");\nexport const MotionH3 = /*@__PURE__*/ createMinimalMotionComponent(\"h3\");\nexport const MotionH4 = /*@__PURE__*/ createMinimalMotionComponent(\"h4\");\nexport const MotionH5 = /*@__PURE__*/ createMinimalMotionComponent(\"h5\");\nexport const MotionH6 = /*@__PURE__*/ createMinimalMotionComponent(\"h6\");\nexport const MotionHead = /*@__PURE__*/ createMinimalMotionComponent(\"head\");\nexport const MotionHeader = /*@__PURE__*/ createMinimalMotionComponent(\"header\");\nexport const MotionHgroup = /*@__PURE__*/ createMinimalMotionComponent(\"hgroup\");\nexport const MotionHr = /*@__PURE__*/ createMinimalMotionComponent(\"hr\");\nexport const MotionHtml = /*@__PURE__*/ createMinimalMotionComponent(\"html\");\nexport const MotionI = /*@__PURE__*/ createMinimalMotionComponent(\"i\");\nexport const MotionIframe = /*@__PURE__*/ createMinimalMotionComponent(\"iframe\");\nexport const MotionImg = /*@__PURE__*/ createMinimalMotionComponent(\"img\");\nexport const MotionInput = /*@__PURE__*/ createMinimalMotionComponent(\"input\");\nexport const MotionIns = /*@__PURE__*/ createMinimalMotionComponent(\"ins\");\nexport const MotionKbd = /*@__PURE__*/ createMinimalMotionComponent(\"kbd\");\nexport const MotionKeygen = /*@__PURE__*/ createMinimalMotionComponent(\"keygen\");\nexport const MotionLabel = /*@__PURE__*/ createMinimalMotionComponent(\"label\");\nexport const MotionLegend = /*@__PURE__*/ createMinimalMotionComponent(\"legend\");\nexport const MotionLi = /*@__PURE__*/ createMinimalMotionComponent(\"li\");\nexport const MotionLink = /*@__PURE__*/ createMinimalMotionComponent(\"link\");\nexport const MotionMain = /*@__PURE__*/ createMinimalMotionComponent(\"main\");\nexport const MotionMap = /*@__PURE__*/ createMinimalMotionComponent(\"map\");\nexport const MotionMark = /*@__PURE__*/ createMinimalMotionComponent(\"mark\");\nexport const MotionMenu = /*@__PURE__*/ createMinimalMotionComponent(\"menu\");\nexport const MotionMenuitem = \n/*@__PURE__*/ createMinimalMotionComponent(\"menuitem\");\nexport const MotionMeter = /*@__PURE__*/ createMinimalMotionComponent(\"meter\");\nexport const MotionNav = /*@__PURE__*/ createMinimalMotionComponent(\"nav\");\nexport const MotionObject = /*@__PURE__*/ createMinimalMotionComponent(\"object\");\nexport const MotionOl = /*@__PURE__*/ createMinimalMotionComponent(\"ol\");\nexport const MotionOptgroup = \n/*@__PURE__*/ createMinimalMotionComponent(\"optgroup\");\nexport const MotionOption = /*@__PURE__*/ createMinimalMotionComponent(\"option\");\nexport const MotionOutput = /*@__PURE__*/ createMinimalMotionComponent(\"output\");\nexport const MotionP = /*@__PURE__*/ createMinimalMotionComponent(\"p\");\nexport const MotionParam = /*@__PURE__*/ createMinimalMotionComponent(\"param\");\nexport const MotionPicture = \n/*@__PURE__*/ createMinimalMotionComponent(\"picture\");\nexport const MotionPre = /*@__PURE__*/ createMinimalMotionComponent(\"pre\");\nexport const MotionProgress = \n/*@__PURE__*/ createMinimalMotionComponent(\"progress\");\nexport const MotionQ = /*@__PURE__*/ createMinimalMotionComponent(\"q\");\nexport const MotionRp = /*@__PURE__*/ createMinimalMotionComponent(\"rp\");\nexport const MotionRt = /*@__PURE__*/ createMinimalMotionComponent(\"rt\");\nexport const MotionRuby = /*@__PURE__*/ createMinimalMotionComponent(\"ruby\");\nexport const MotionS = /*@__PURE__*/ createMinimalMotionComponent(\"s\");\nexport const MotionSamp = /*@__PURE__*/ createMinimalMotionComponent(\"samp\");\nexport const MotionScript = /*@__PURE__*/ createMinimalMotionComponent(\"script\");\nexport const MotionSection = \n/*@__PURE__*/ createMinimalMotionComponent(\"section\");\nexport const MotionSelect = /*@__PURE__*/ createMinimalMotionComponent(\"select\");\nexport const MotionSmall = /*@__PURE__*/ createMinimalMotionComponent(\"small\");\nexport const MotionSource = /*@__PURE__*/ createMinimalMotionComponent(\"source\");\nexport const MotionSpan = /*@__PURE__*/ createMinimalMotionComponent(\"span\");\nexport const MotionStrong = /*@__PURE__*/ createMinimalMotionComponent(\"strong\");\nexport const MotionStyle = /*@__PURE__*/ createMinimalMotionComponent(\"style\");\nexport const MotionSub = /*@__PURE__*/ createMinimalMotionComponent(\"sub\");\nexport const MotionSummary = \n/*@__PURE__*/ createMinimalMotionComponent(\"summary\");\nexport const MotionSup = /*@__PURE__*/ createMinimalMotionComponent(\"sup\");\nexport const MotionTable = /*@__PURE__*/ createMinimalMotionComponent(\"table\");\nexport const MotionTbody = /*@__PURE__*/ createMinimalMotionComponent(\"tbody\");\nexport const MotionTd = /*@__PURE__*/ createMinimalMotionComponent(\"td\");\nexport const MotionTextarea = \n/*@__PURE__*/ createMinimalMotionComponent(\"textarea\");\nexport const MotionTfoot = /*@__PURE__*/ createMinimalMotionComponent(\"tfoot\");\nexport const MotionTh = /*@__PURE__*/ createMinimalMotionComponent(\"th\");\nexport const MotionThead = /*@__PURE__*/ createMinimalMotionComponent(\"thead\");\nexport const MotionTime = /*@__PURE__*/ createMinimalMotionComponent(\"time\");\nexport const MotionTitle = /*@__PURE__*/ createMinimalMotionComponent(\"title\");\nexport const MotionTr = /*@__PURE__*/ createMinimalMotionComponent(\"tr\");\nexport const MotionTrack = /*@__PURE__*/ createMinimalMotionComponent(\"track\");\nexport const MotionU = /*@__PURE__*/ createMinimalMotionComponent(\"u\");\nexport const MotionUl = /*@__PURE__*/ createMinimalMotionComponent(\"ul\");\nexport const MotionVideo = /*@__PURE__*/ createMinimalMotionComponent(\"video\");\nexport const MotionWbr = /*@__PURE__*/ createMinimalMotionComponent(\"wbr\");\nexport const MotionWebview = \n/*@__PURE__*/ createMinimalMotionComponent(\"webview\");\n/**\n * SVG components\n */\nexport const MotionAnimate = \n/*@__PURE__*/ createMinimalMotionComponent(\"animate\");\nexport const MotionCircle = /*@__PURE__*/ createMinimalMotionComponent(\"circle\");\nexport const MotionDefs = /*@__PURE__*/ createMinimalMotionComponent(\"defs\");\nexport const MotionDesc = /*@__PURE__*/ createMinimalMotionComponent(\"desc\");\nexport const MotionEllipse = \n/*@__PURE__*/ createMinimalMotionComponent(\"ellipse\");\nexport const MotionG = /*@__PURE__*/ createMinimalMotionComponent(\"g\");\nexport const MotionImage = /*@__PURE__*/ createMinimalMotionComponent(\"image\");\nexport const MotionLine = /*@__PURE__*/ createMinimalMotionComponent(\"line\");\nexport const MotionFilter = /*@__PURE__*/ createMinimalMotionComponent(\"filter\");\nexport const MotionMarker = /*@__PURE__*/ createMinimalMotionComponent(\"marker\");\nexport const MotionMask = /*@__PURE__*/ createMinimalMotionComponent(\"mask\");\nexport const MotionMetadata = \n/*@__PURE__*/ createMinimalMotionComponent(\"metadata\");\nexport const MotionPath = /*@__PURE__*/ createMinimalMotionComponent(\"path\");\nexport const MotionPattern = \n/*@__PURE__*/ createMinimalMotionComponent(\"pattern\");\nexport const MotionPolygon = \n/*@__PURE__*/ createMinimalMotionComponent(\"polygon\");\nexport const MotionPolyline = \n/*@__PURE__*/ createMinimalMotionComponent(\"polyline\");\nexport const MotionRect = /*@__PURE__*/ createMinimalMotionComponent(\"rect\");\nexport const MotionStop = /*@__PURE__*/ createMinimalMotionComponent(\"stop\");\nexport const MotionSvg = /*@__PURE__*/ createMinimalMotionComponent(\"svg\");\nexport const MotionSymbol = /*@__PURE__*/ createMinimalMotionComponent(\"symbol\");\nexport const MotionText = /*@__PURE__*/ createMinimalMotionComponent(\"text\");\nexport const MotionTspan = /*@__PURE__*/ createMinimalMotionComponent(\"tspan\");\nexport const MotionUse = /*@__PURE__*/ createMinimalMotionComponent(\"use\");\nexport const MotionView = /*@__PURE__*/ createMinimalMotionComponent(\"view\");\nexport const MotionClipPath = \n/*@__PURE__*/ createMinimalMotionComponent(\"clipPath\");\nexport const MotionFeBlend = \n/*@__PURE__*/ createMinimalMotionComponent(\"feBlend\");\nexport const MotionFeColorMatrix = \n/*@__PURE__*/ createMinimalMotionComponent(\"feColorMatrix\");\nexport const MotionFeComponentTransfer = \n/*@__PURE__*/ createMinimalMotionComponent(\"feComponentTransfer\");\nexport const MotionFeComposite = \n/*@__PURE__*/ createMinimalMotionComponent(\"feComposite\");\nexport const MotionFeConvolveMatrix = \n/*@__PURE__*/ createMinimalMotionComponent(\"feConvolveMatrix\");\nexport const MotionFeDiffuseLighting = \n/*@__PURE__*/ createMinimalMotionComponent(\"feDiffuseLighting\");\nexport const MotionFeDisplacementMap = \n/*@__PURE__*/ createMinimalMotionComponent(\"feDisplacementMap\");\nexport const MotionFeDistantLight = \n/*@__PURE__*/ createMinimalMotionComponent(\"feDistantLight\");\nexport const MotionFeDropShadow = \n/*@__PURE__*/ createMinimalMotionComponent(\"feDropShadow\");\nexport const MotionFeFlood = \n/*@__PURE__*/ createMinimalMotionComponent(\"feFlood\");\nexport const MotionFeFuncA = \n/*@__PURE__*/ createMinimalMotionComponent(\"feFuncA\");\nexport const MotionFeFuncB = \n/*@__PURE__*/ createMinimalMotionComponent(\"feFuncB\");\nexport const MotionFeFuncG = \n/*@__PURE__*/ createMinimalMotionComponent(\"feFuncG\");\nexport const MotionFeFuncR = \n/*@__PURE__*/ createMinimalMotionComponent(\"feFuncR\");\nexport const MotionFeGaussianBlur = \n/*@__PURE__*/ createMinimalMotionComponent(\"feGaussianBlur\");\nexport const MotionFeImage = \n/*@__PURE__*/ createMinimalMotionComponent(\"feImage\");\nexport const MotionFeMerge = \n/*@__PURE__*/ createMinimalMotionComponent(\"feMerge\");\nexport const MotionFeMergeNode = \n/*@__PURE__*/ createMinimalMotionComponent(\"feMergeNode\");\nexport const MotionFeMorphology = \n/*@__PURE__*/ createMinimalMotionComponent(\"feMorphology\");\nexport const MotionFeOffset = \n/*@__PURE__*/ createMinimalMotionComponent(\"feOffset\");\nexport const MotionFePointLight = \n/*@__PURE__*/ createMinimalMotionComponent(\"fePointLight\");\nexport const MotionFeSpecularLighting = \n/*@__PURE__*/ createMinimalMotionComponent(\"feSpecularLighting\");\nexport const MotionFeSpotLight = \n/*@__PURE__*/ createMinimalMotionComponent(\"feSpotLight\");\nexport const MotionFeTile = /*@__PURE__*/ createMinimalMotionComponent(\"feTile\");\nexport const MotionFeTurbulence = \n/*@__PURE__*/ createMinimalMotionComponent(\"feTurbulence\");\nexport const MotionForeignObject = \n/*@__PURE__*/ createMinimalMotionComponent(\"foreignObject\");\nexport const MotionLinearGradient = \n/*@__PURE__*/ createMinimalMotionComponent(\"linearGradient\");\nexport const MotionRadialGradient = \n/*@__PURE__*/ createMinimalMotionComponent(\"radialGradient\");\nexport const MotionTextPath = \n/*@__PURE__*/ createMinimalMotionComponent(\"textPath\");\n//# sourceMappingURL=elements.js.map","import { m } from \"./\";\nexport const MotionDiv = m.div;\n//# sourceMappingURL=size.js.map"],"names":["clamp","min","max","v","LayoutGroupContext","createContext","LazyContext","strict","MotionConfigContext","transformPagePoint","p","isStatic","reducedMotion","MotionContext","isCSSVariableName","token","key","startsWith","checkStringStartsWith","number","test","parse","parseFloat","transform","alpha","scale","default","sanitize","Math","round","floatRegex","singleColorRegex","isColorString","type","testProp","Boolean","isNullish","Object","prototype","hasOwnProperty","call","splitColor","aName","bName","cName","a","b","c","match","undefined","rgbUnit","clampRgbUnit","rgba","red","green","blue","alpha$1","hex","r","g","length","substring","parseInt","createUnitType","unit","endsWith","split","degrees","percent","px","progressPercentage","hsla","hue","saturation","lightness","color","getAnimatableNone","parsed","colorRegex","NUMBER_TOKEN","COLOR_TOKEN","complexRegex","analyseComplexValue","value","originalValue","toString","values","indexes","var","types","i","replace","parsedValue","push","parseComplexValue","createTransformer","source","numSections","output","convertNumbersToZero","complex","isNaN","transformer","map","transformPropOrder","transformProps","Set","resolveVariantFromProps","props","definition","custom","visualElement","current","velocity","variants","isMotionValue","getVelocity","optimizedAppearDataAttribute","toLowerCase","int","numberValueTypes","borderWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderRadius","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","width","maxWidth","height","maxHeight","top","right","bottom","left","inset","insetBlock","insetBlockStart","insetBlockEnd","insetInline","insetInlineStart","insetInlineEnd","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","paddingBlock","paddingBlockStart","paddingBlockEnd","paddingInline","paddingInlineStart","paddingInlineEnd","margin","marginTop","marginRight","marginBottom","marginLeft","marginBlock","marginBlockStart","marginBlockEnd","marginInline","marginInlineStart","marginInlineEnd","backgroundPositionX","backgroundPositionY","rotate","rotateX","rotateY","rotateZ","scaleX","scaleY","scaleZ","skew","skewX","skewY","distance","translateX","translateY","translateZ","x","y","z","perspective","transformPerspective","opacity","originX","originY","originZ","zIndex","fillOpacity","strokeOpacity","numOctaves","getValueAsType","isAnimationControls","start","isVariantLabel","Array","isArray","variantProps","isControllingVariants","animate","some","name","featureDefinitions","translateAlias","numTransforms","buildHTMLStyles","state","latestValues","transformTemplate","style","vars","transformOrigin","hasTransform","hasTransformOrigin","has","valueAsType","transformString","transformIsDefault","valueIsDefault","trim","buildTransform","pixelsToPercent","pixels","axis","correctBorderRadius","correct","latest","node","target","correctBoxShadow","treeScale","projectionDelta","original","shadow","template","offset","xScale","yScale","averageScale","from","scaleCorrectors","applyTo","boxShadow","isForcedMotionValue","layout","layoutId","scrapeMotionValuesFromProps","prevProps","prevStyle","newValues","getValue","liveStyle","dashKeys","array","camelKeys","cssMotionPathProperties","buildSVGAttrs","attrX","attrY","attrScale","pathLength","pathSpacing","pathOffset","isSVGTag","styleProp","viewBox","attrs","transformBox","spacing","useDashCase","keys","buildSVGPath","resolveMotionValue","get","useCreateMotionContext","initial","context","inherit","getCurrentTreeVariants","useContext","useMemo","variantLabelsAsDependency","prop","join","createHtmlRenderState","copyRawValuesOnly","useStyle","visualState","assign","useInitialMotionValues","useHTMLProps","htmlProps","drag","dragListener","draggable","userSelect","WebkitUserSelect","WebkitTouchCallout","touchAction","tabIndex","onTap","onTapStart","whileTap","createSvgRenderState","useSVGProps","_isStatic","Component","visualProps","tag","rawStyles","validMotionProps","isValidMotionProp","shouldForward","isValidProp","require","lowercaseSVGElements","isSVGComponent","includes","indexOf","useRender","ref","forwardMotionProps","isSVG","filteredProps","isDom","filterProps","elementProps","Fragment","children","renderedChildren","createElement","PresenceContext","makeLatestValues","presenceContext","scrapeMotionValues","motionValues","checkIsControllingVariants","isVariantNode","checkIsVariantNode","isInitialAnimationBlocked","variantToSet","list","resolved","transitionEnd","transition","valueTarget","makeUseVisualState","config","make","createRenderState","renderState","makeState","init","useRef","useConstant","useHTMLVisualState","scrapeHTMLMotionValuesFromProps","useSVGVisualState","scrapeMotionValuesFromProps$1","charAt","toUpperCase","isBrowser","window","featureProps","animation","exit","focus","hover","tap","pan","inView","isInitialized","initFeatureDefinitions","initialFeatureDefinitions","isEnabled","getInitializedFeatureDefinitions","motionComponentSymbol","Symbol","for","useMotionRef","externalRef","externalRefContainer","useInsertionEffect","refCleanup","useCallback","instance","onMount","mount","unmount","cleanup","SwitchLayoutGroupContext","isRefObject","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","useVisualElement","createVisualElement","ProjectionNodeConstructor","parent","lazyContext","reducedMotionConfig","visualElementRef","renderer","blockInitialAnimation","initialLayoutGroupConfig","projection","initialPromotionConfig","dragConstraints","layoutScroll","layoutRoot","layoutCrossfade","getClosestProjectingNode","setOptions","alwaysMeasureLayout","animationType","crossfade","createProjectionNode","isMounted","update","optimisedAppearId","wantsHandoff","MotionHandoffIsComplete","MotionHasOptimisedAnimation","MotionIsMounted","updateFeatures","scheduleRenderMicrotask","animationState","animateChanges","queueMicrotask","MotionHandoffMarkAsComplete","enteringChildren","options","allowProjection","createMotionComponent","preloadedFeatures","useVisualState","MotionDOMComponent","MeasureLayout","configAndProps","useLayoutId","layoutProjection","combined","ProjectionNode","getProjectionFunctionality","_jsxs","Provider","_jsx","displayName","ForwardRefMotionComponent","forwardRef","layoutGroupId","id","createMinimalMotionComponent","MotionDiv"],"mappings":"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"}