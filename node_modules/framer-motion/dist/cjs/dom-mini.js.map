{"version":3,"file":"dom-mini.js","sources":["../../src/animation/utils/is-dom-keyframes.ts","../../src/animation/animate/resolve-subjects.ts","../../src/animation/sequence/utils/calc-repeat-duration.ts","../../src/animation/sequence/utils/calc-time.ts","../../src/animation/sequence/utils/edit.ts","../../src/animation/sequence/utils/normalize-times.ts","../../src/animation/sequence/utils/sort.ts","../../src/animation/sequence/create.ts","../../src/animation/animators/waapi/animate-elements.ts","../../src/animation/animators/waapi/animate-sequence.ts","../../src/animation/animators/waapi/animate-style.ts"],"sourcesContent":["import { DOMKeyframesDefinition } from \"motion-dom\"\n\nexport function isDOMKeyframes(\n    keyframes: unknown\n): keyframes is DOMKeyframesDefinition {\n    return typeof keyframes === \"object\" && !Array.isArray(keyframes)\n}\n","import {\n    AnimationScope,\n    DOMKeyframesDefinition,\n    SelectorCache,\n    resolveElements,\n} from \"motion-dom\"\nimport { ObjectTarget } from \"../sequence/types\"\nimport { isDOMKeyframes } from \"../utils/is-dom-keyframes\"\n\nexport function resolveSubjects<O extends {}>(\n    subject:\n        | string\n        | Element\n        | Element[]\n        | NodeListOf<Element>\n        | O\n        | O[]\n        | null\n        | undefined,\n    keyframes: DOMKeyframesDefinition | ObjectTarget<O>,\n    scope?: AnimationScope,\n    selectorCache?: SelectorCache\n) {\n    if (subject == null) {\n        return []\n    }\n\n    if (typeof subject === \"string\" && isDOMKeyframes(keyframes)) {\n        return resolveElements(subject, scope, selectorCache)\n    } else if (subject instanceof NodeList) {\n        return Array.from(subject)\n    } else if (Array.isArray(subject)) {\n        return subject.filter((s) => s != null)\n    } else {\n        return [subject]\n    }\n}\n","export function calculateRepeatDuration(\n    duration: number,\n    repeat: number,\n    _repeatDelay: number\n): number {\n    return duration * (repeat + 1)\n}\n","import { SequenceTime } from \"../types\"\n\n/**\n * Given a absolute or relative time definition and current/prev time state of the sequence,\n * calculate an absolute time for the next keyframes.\n */\nexport function calcNextTime(\n    current: number,\n    next: SequenceTime,\n    prev: number,\n    labels: Map<string, number>\n): number {\n    if (typeof next === \"number\") {\n        return next\n    } else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n        return Math.max(0, current + parseFloat(next))\n    } else if (next === \"<\") {\n        return prev\n    } else if (next.startsWith(\"<\")) {\n        return Math.max(0, prev + parseFloat(next.slice(1)))\n    } else {\n        return labels.get(next) ?? current\n    }\n}\n","import { mixNumber, UnresolvedValueKeyframe } from \"motion-dom\"\nimport { Easing, getEasingForSegment, removeItem } from \"motion-utils\"\nimport type { ValueSequence } from \"../types\"\n\nexport function eraseKeyframes(\n    sequence: ValueSequence,\n    startTime: number,\n    endTime: number\n): void {\n    for (let i = 0; i < sequence.length; i++) {\n        const keyframe = sequence[i]\n\n        if (keyframe.at > startTime && keyframe.at < endTime) {\n            removeItem(sequence, keyframe)\n\n            // If we remove this item we have to push the pointer back one\n            i--\n        }\n    }\n}\n\nexport function addKeyframes(\n    sequence: ValueSequence,\n    keyframes: UnresolvedValueKeyframe[],\n    easing: Easing | Easing[],\n    offset: number[],\n    startTime: number,\n    endTime: number\n): void {\n    /**\n     * Erase every existing value between currentTime and targetTime,\n     * this will essentially splice this timeline into any currently\n     * defined ones.\n     */\n    eraseKeyframes(sequence, startTime, endTime)\n\n    for (let i = 0; i < keyframes.length; i++) {\n        sequence.push({\n            value: keyframes[i],\n            at: mixNumber(startTime, endTime, offset[i]),\n            easing: getEasingForSegment(easing, i),\n        })\n    }\n}\n","/**\n * Take an array of times that represent repeated keyframes. For instance\n * if we have original times of [0, 0.5, 1] then our repeated times will\n * be [0, 0.5, 1, 1, 1.5, 2]. Loop over the times and scale them back\n * down to a 0-1 scale.\n */\nexport function normalizeTimes(times: number[], repeat: number): void {\n    for (let i = 0; i < times.length; i++) {\n        times[i] = times[i] / (repeat + 1)\n    }\n}\n","import { AbsoluteKeyframe } from \"../types\"\n\nexport function compareByTime(\n    a: AbsoluteKeyframe,\n    b: AbsoluteKeyframe\n): number {\n    if (a.at === b.at) {\n        if (a.value === null) return 1\n        if (b.value === null) return -1\n        return 0\n    } else {\n        return a.at - b.at\n    }\n}\n","import {\n    AnimationScope,\n    createGeneratorEasing,\n    defaultOffset,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    fillOffset,\n    GeneratorFactory,\n    isGenerator,\n    isMotionValue,\n    Transition,\n    UnresolvedValueKeyframe,\n    type AnyResolvedKeyframe,\n    type MotionValue,\n} from \"motion-dom\"\nimport {\n    Easing,\n    getEasingForSegment,\n    invariant,\n    progress,\n    secondsToMilliseconds,\n} from \"motion-utils\"\nimport { resolveSubjects } from \"../animate/resolve-subjects\"\nimport {\n    AnimationSequence,\n    At,\n    ResolvedAnimationDefinitions,\n    SequenceMap,\n    SequenceOptions,\n    ValueSequence,\n} from \"./types\"\nimport { calculateRepeatDuration } from \"./utils/calc-repeat-duration\"\nimport { calcNextTime } from \"./utils/calc-time\"\nimport { addKeyframes } from \"./utils/edit\"\nimport { normalizeTimes } from \"./utils/normalize-times\"\nimport { compareByTime } from \"./utils/sort\"\n\nconst defaultSegmentEasing = \"easeInOut\"\n\nconst MAX_REPEAT = 20\n\nexport function createAnimationsFromSequence(\n    sequence: AnimationSequence,\n    { defaultTransition = {}, ...sequenceTransition }: SequenceOptions = {},\n    scope?: AnimationScope,\n    generators?: { [key: string]: GeneratorFactory }\n): ResolvedAnimationDefinitions {\n    const defaultDuration = defaultTransition.duration || 0.3\n    const animationDefinitions: ResolvedAnimationDefinitions = new Map()\n    const sequences = new Map<Element | MotionValue, SequenceMap>()\n    const elementCache = {}\n    const timeLabels = new Map<string, number>()\n\n    let prevTime = 0\n    let currentTime = 0\n    let totalDuration = 0\n\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i]\n\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime)\n            continue\n        } else if (!Array.isArray(segment)) {\n            timeLabels.set(\n                segment.name,\n                calcNextTime(currentTime, segment.at, prevTime, timeLabels)\n            )\n            continue\n        }\n\n        let [subject, keyframes, transition = {}] = segment\n\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(\n                currentTime,\n                transition.at,\n                prevTime,\n                timeLabels\n            )\n        }\n\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0\n\n        const resolveValueSequence = (\n            valueKeyframes: UnresolvedValueKeyframe | UnresolvedValueKeyframe[],\n            valueTransition: Transition | DynamicAnimationOptions,\n            valueSequence: ValueSequence,\n            elementIndex = 0,\n            numSubjects = 0\n        ) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes)\n            const {\n                delay = 0,\n                times = defaultOffset(valueKeyframesAsList),\n                type = \"keyframes\",\n                repeat,\n                repeatType,\n                repeatDelay = 0,\n                ...remainingTransition\n            } = valueTransition\n            let { ease = defaultTransition.ease || \"easeOut\", duration } =\n                valueTransition\n\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay =\n                typeof delay === \"function\"\n                    ? delay(elementIndex, numSubjects)\n                    : delay\n\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length\n            const createGenerator = isGenerator(type)\n                ? type\n                : generators?.[type || \"keyframes\"]\n\n            if (numKeyframes <= 2 && createGenerator) {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100\n                if (\n                    numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)\n                ) {\n                    const delta =\n                        valueKeyframesAsList[1] - valueKeyframesAsList[0]\n                    absoluteDelta = Math.abs(delta)\n                }\n\n                const springTransition = { ...remainingTransition }\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration)\n                }\n\n                const springEasing = createGeneratorEasing(\n                    springTransition,\n                    absoluteDelta,\n                    createGenerator\n                )\n\n                ease = springEasing.ease\n                duration = springEasing.duration\n            }\n\n            duration ??= defaultDuration\n\n            const startTime = currentTime + calculatedDelay\n\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1\n            }\n\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length\n            remainder > 0 && fillOffset(times, remainder)\n\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null)\n\n            /**\n             * Handle repeat options\n             */\n            if (repeat) {\n                invariant(\n                    repeat < MAX_REPEAT,\n                    \"Repeat count too high, must be less than 20\",\n                    \"repeat-count-high\"\n                )\n\n                duration = calculateRepeatDuration(\n                    duration,\n                    repeat,\n                    repeatDelay\n                )\n\n                const originalKeyframes = [...valueKeyframesAsList]\n                const originalTimes = [...times]\n                ease = Array.isArray(ease) ? [...ease] : [ease]\n                const originalEase = [...ease]\n\n                for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\n                    valueKeyframesAsList.push(...originalKeyframes)\n\n                    for (\n                        let keyframeIndex = 0;\n                        keyframeIndex < originalKeyframes.length;\n                        keyframeIndex++\n                    ) {\n                        times.push(\n                            originalTimes[keyframeIndex] + (repeatIndex + 1)\n                        )\n                        ease.push(\n                            keyframeIndex === 0\n                                ? \"linear\"\n                                : getEasingForSegment(\n                                      originalEase,\n                                      keyframeIndex - 1\n                                  )\n                        )\n                    }\n                }\n\n                normalizeTimes(times, repeat)\n            }\n\n            const targetTime = startTime + duration\n\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(\n                valueSequence,\n                valueKeyframesAsList,\n                ease as Easing | Easing[],\n                times,\n                startTime,\n                targetTime\n            )\n\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration)\n            totalDuration = Math.max(targetTime, totalDuration)\n        }\n\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences)\n            resolveValueSequence(\n                keyframes as AnyResolvedKeyframe,\n                transition,\n                getValueSequence(\"default\", subjectSequence)\n            )\n        } else {\n            const subjects = resolveSubjects(\n                subject,\n                keyframes as DOMKeyframesDefinition,\n                scope,\n                elementCache\n            )\n\n            const numSubjects = subjects.length\n\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (\n                let subjectIndex = 0;\n                subjectIndex < numSubjects;\n                subjectIndex++\n            ) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes as DOMKeyframesDefinition\n                transition = transition as DynamicAnimationOptions\n\n                const thisSubject = subjects[subjectIndex]\n                const subjectSequence = getSubjectSequence(\n                    thisSubject,\n                    sequences\n                )\n\n                for (const key in keyframes) {\n                    resolveValueSequence(\n                        keyframes[\n                            key as keyof typeof keyframes\n                        ] as UnresolvedValueKeyframe,\n                        getValueTransition(transition, key),\n                        getValueSequence(key, subjectSequence),\n                        subjectIndex,\n                        numSubjects\n                    )\n                }\n            }\n        }\n\n        prevTime = currentTime\n        currentTime += maxDuration\n    }\n\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key]\n\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime)\n\n            const keyframes: UnresolvedValueKeyframe[] = []\n            const valueOffset: number[] = []\n            const valueEasing: Easing[] = []\n\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i]\n                keyframes.push(value)\n                valueOffset.push(progress(0, totalDuration, at))\n                valueEasing.push(easing || \"easeOut\")\n            }\n\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0)\n                keyframes.unshift(keyframes[0])\n                valueEasing.unshift(defaultSegmentEasing)\n            }\n\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1)\n                keyframes.push(null)\n            }\n\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                })\n            }\n\n            const definition = animationDefinitions.get(element)!\n\n            definition.keyframes[key] = keyframes\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            }\n        }\n    })\n\n    return animationDefinitions\n}\n\nfunction getSubjectSequence<O extends {}>(\n    subject: Element | MotionValue | O,\n    sequences: Map<Element | MotionValue | O, SequenceMap>\n): SequenceMap {\n    !sequences.has(subject) && sequences.set(subject, {})\n    return sequences.get(subject)!\n}\n\nfunction getValueSequence(name: string, sequences: SequenceMap): ValueSequence {\n    if (!sequences[name]) sequences[name] = []\n    return sequences[name]\n}\n\nfunction keyframesAsList(\n    keyframes: UnresolvedValueKeyframe | UnresolvedValueKeyframe[]\n): UnresolvedValueKeyframe[] {\n    return Array.isArray(keyframes) ? keyframes : [keyframes]\n}\n\nexport function getValueTransition(\n    transition: DynamicAnimationOptions & At,\n    key: string\n): DynamicAnimationOptions {\n    return transition && transition[key as keyof typeof transition]\n        ? {\n              ...transition,\n              ...(transition[key as keyof typeof transition] as Transition),\n          }\n        : { ...transition }\n}\n\nconst isNumber = (keyframe: unknown) => typeof keyframe === \"number\"\nconst isNumberKeyframesArray = (\n    keyframes: UnresolvedValueKeyframe[]\n): keyframes is number[] => keyframes.every(isNumber)\n","import {\n    animationMapKey,\n    AnimationPlaybackControls,\n    AnimationScope,\n    applyPxDefaults,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    ElementOrSelector,\n    fillWildcards,\n    getAnimationMap,\n    getComputedStyle,\n    getValueTransition,\n    NativeAnimation,\n    NativeAnimationOptions,\n    resolveElements,\n    UnresolvedValueKeyframe,\n    ValueKeyframe,\n} from \"motion-dom\"\nimport { invariant, secondsToMilliseconds } from \"motion-utils\"\n\ninterface AnimationDefinition {\n    map: Map<string, NativeAnimation<any>>\n    key: string\n    unresolvedKeyframes: UnresolvedValueKeyframe[]\n    options: Omit<NativeAnimationOptions, \"keyframes\"> & {\n        keyframes?: ValueKeyframe[]\n    }\n}\n\nexport function animateElements(\n    elementOrSelector: ElementOrSelector,\n    keyframes: DOMKeyframesDefinition,\n    options?: DynamicAnimationOptions,\n    scope?: AnimationScope\n) {\n    // Gracefully handle null/undefined elements (e.g., from querySelector returning null)\n    if (elementOrSelector == null) {\n        return []\n    }\n\n    const elements = resolveElements(elementOrSelector, scope) as Array<\n        HTMLElement | SVGElement\n    >\n    const numElements = elements.length\n\n    invariant(\n        Boolean(numElements),\n        \"No valid elements provided.\",\n        \"no-valid-elements\"\n    )\n\n    /**\n     * WAAPI doesn't support interrupting animations.\n     *\n     * Therefore, starting animations requires a three-step process:\n     * 1. Stop existing animations (write styles to DOM)\n     * 2. Resolve keyframes (read styles from DOM)\n     * 3. Create new animations (write styles to DOM)\n     *\n     * The hybrid `animate()` function uses AsyncAnimation to resolve\n     * keyframes before creating new animations, which removes style\n     * thrashing. Here, we have much stricter filesize constraints.\n     * Therefore we do this in a synchronous way that ensures that\n     * at least within `animate()` calls there is no style thrashing.\n     *\n     * In the motion-native-animate-mini-interrupt benchmark this\n     * was 80% faster than a single loop.\n     */\n    const animationDefinitions: AnimationDefinition[] = []\n\n    /**\n     * Step 1: Build options and stop existing animations (write)\n     */\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i]\n        const elementTransition: DynamicAnimationOptions = { ...options }\n\n        /**\n         * Resolve stagger function if provided.\n         */\n        if (typeof elementTransition.delay === \"function\") {\n            elementTransition.delay = elementTransition.delay(i, numElements)\n        }\n\n        for (const valueName in keyframes) {\n            let valueKeyframes = keyframes[valueName as keyof typeof keyframes]!\n\n            if (!Array.isArray(valueKeyframes)) {\n                valueKeyframes = [valueKeyframes]\n            }\n\n            const valueOptions = {\n                ...getValueTransition(elementTransition as any, valueName),\n            }\n\n            valueOptions.duration &&= secondsToMilliseconds(\n                valueOptions.duration\n            )\n\n            valueOptions.delay &&= secondsToMilliseconds(valueOptions.delay)\n\n            /**\n             * If there's an existing animation playing on this element then stop it\n             * before creating a new one.\n             */\n            const map = getAnimationMap(element)\n            const key = animationMapKey(\n                valueName,\n                valueOptions.pseudoElement || \"\"\n            )\n            const currentAnimation = map.get(key)\n            currentAnimation && currentAnimation.stop()\n\n            animationDefinitions.push({\n                map,\n                key,\n                unresolvedKeyframes: valueKeyframes,\n                options: {\n                    ...valueOptions,\n                    element,\n                    name: valueName,\n                    allowFlatten:\n                        !elementTransition.type && !elementTransition.ease,\n                },\n            })\n        }\n    }\n\n    /**\n     * Step 2: Resolve keyframes (read)\n     */\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { unresolvedKeyframes, options: animationOptions } =\n            animationDefinitions[i]\n\n        const { element, name, pseudoElement } = animationOptions\n        if (!pseudoElement && unresolvedKeyframes[0] === null) {\n            unresolvedKeyframes[0] = getComputedStyle(element, name)\n        }\n\n        fillWildcards(unresolvedKeyframes)\n        applyPxDefaults(unresolvedKeyframes, name)\n\n        /**\n         * If we only have one keyframe, explicitly read the initial keyframe\n         * from the computed style. This is to ensure consistency with WAAPI behaviour\n         * for restarting animations, for instance .play() after finish, when it\n         * has one vs two keyframes.\n         */\n        if (!pseudoElement && unresolvedKeyframes.length < 2) {\n            unresolvedKeyframes.unshift(getComputedStyle(element, name))\n        }\n\n        animationOptions.keyframes = unresolvedKeyframes as ValueKeyframe[]\n    }\n\n    /**\n     * Step 3: Create new animations (write)\n     */\n    const animations: AnimationPlaybackControls[] = []\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { map, key, options: animationOptions } = animationDefinitions[i]\n        const animation = new NativeAnimation(\n            animationOptions as NativeAnimationOptions\n        )\n\n        map.set(key, animation)\n        animation.finished.finally(() => map.delete(key))\n\n        animations.push(animation)\n    }\n\n    return animations\n}\n","import { AnimationPlaybackControls, GroupAnimationWithThen } from \"motion-dom\"\nimport { createAnimationsFromSequence } from \"../../sequence/create\"\nimport { AnimationSequence, SequenceOptions } from \"../../sequence/types\"\nimport { animateElements } from \"./animate-elements\"\n\nexport function animateSequence(\n    definition: AnimationSequence,\n    options?: SequenceOptions\n) {\n    const animations: AnimationPlaybackControls[] = []\n\n    createAnimationsFromSequence(definition, options).forEach(\n        ({ keyframes, transition }, element: Element) => {\n            animations.push(...animateElements(element, keyframes, transition))\n        }\n    )\n\n    return new GroupAnimationWithThen(animations)\n}\n","import {\n    AnimationPlaybackControlsWithThen,\n    AnimationScope,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    ElementOrSelector,\n    GroupAnimationWithThen,\n} from \"motion-dom\"\nimport { animateElements } from \"./animate-elements\"\n\nexport const createScopedWaapiAnimate = (scope?: AnimationScope) => {\n    function scopedAnimate(\n        elementOrSelector: ElementOrSelector,\n        keyframes: DOMKeyframesDefinition,\n        options?: DynamicAnimationOptions\n    ): AnimationPlaybackControlsWithThen {\n        return new GroupAnimationWithThen(\n            animateElements(\n                elementOrSelector,\n                keyframes as DOMKeyframesDefinition,\n                options,\n                scope\n            )\n        )\n    }\n\n    return scopedAnimate\n}\n\nexport const animateMini = /*@__PURE__*/ createScopedWaapiAnimate()\n"],"names":["resolveElements","removeItem","mixNumber","getEasingForSegment","defaultOffset","isGenerator","secondsToMilliseconds","createGeneratorEasing","fillOffset","invariant","isMotionValue","progress","getValueTransition","getAnimationMap","animationMapKey","getComputedStyle","fillWildcards","applyPxDefaults","NativeAnimation","GroupAnimationWithThen"],"mappings":"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"}