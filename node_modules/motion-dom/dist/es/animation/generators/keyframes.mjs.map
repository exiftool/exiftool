{"version":3,"file":"keyframes.mjs","sources":["../../../../src/animation/generators/keyframes.ts"],"sourcesContent":["import {\n    easeInOut,\n    easingDefinitionToFunction,\n    EasingFunction,\n    isEasingArray,\n} from \"motion-utils\"\nimport { interpolate } from \"../../utils/interpolate\"\nimport { defaultOffset } from \"../keyframes/offsets/default\"\nimport { convertOffsetToTimes } from \"../keyframes/offsets/time\"\nimport {\n    AnimationState,\n    AnyResolvedKeyframe,\n    KeyframeGenerator,\n    ValueAnimationOptions,\n} from \"../types\"\n\nexport function defaultEasing(\n    values: any[],\n    easing?: EasingFunction\n): EasingFunction[] {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1)\n}\n\nexport function keyframes<T extends AnyResolvedKeyframe>({\n    duration = 300,\n    keyframes: keyframeValues,\n    times,\n    ease = \"easeInOut\",\n}: ValueAnimationOptions<T>): KeyframeGenerator<T> {\n    /**\n     * Easing functions can be externally defined as strings. Here we convert them\n     * into actual functions.\n     */\n    const easingFunctions = isEasingArray(ease)\n        ? ease.map(easingDefinitionToFunction)\n        : easingDefinitionToFunction(ease)\n\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state: AnimationState<T> = {\n        done: false,\n        value: keyframeValues[0],\n    }\n\n    /**\n     * Create a times array based on the provided 0-1 offsets\n     */\n    const absoluteTimes = convertOffsetToTimes(\n        // Only use the provided offsets if they're the correct length\n        // TODO Maybe we should warn here if there's a length mismatch\n        times && times.length === keyframeValues.length\n            ? times\n            : defaultOffset(keyframeValues),\n        duration\n    )\n\n    const mapTimeToKeyframe = interpolate<T>(absoluteTimes, keyframeValues, {\n        ease: Array.isArray(easingFunctions)\n            ? easingFunctions\n            : defaultEasing(keyframeValues, easingFunctions),\n    })\n\n    return {\n        calculatedDuration: duration,\n        next: (t: number) => {\n            state.value = mapTimeToKeyframe(t)\n            state.done = t >= duration\n            return state\n        },\n    }\n}\n"],"names":[],"mappings":";;;;;AAgBgB,SAAA,aAAa,CACzB,MAAa,EACb,MAAuB,EAAA;IAEvB,OAAO,MAAM,CAAC,GAAG,CAAC,MAAM,MAAM,IAAI,SAAS,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;AAC7E,CAAC;SAEe,SAAS,CAAgC,EACrD,QAAQ,GAAG,GAAG,EACd,SAAS,EAAE,cAAc,EACzB,KAAK,EACL,IAAI,GAAG,WAAW,GACK,EAAA;AACvB;;;AAGG;AACH,IAAA,MAAM,eAAe,GAAG,aAAa,CAAC,IAAI,CAAC;AACvC,UAAE,IAAI,CAAC,GAAG,CAAC,0BAA0B,CAAC;AACtC,UAAE,0BAA0B,CAAC,IAAI,CAAC,CAAA;AAEtC;;;AAGG;AACH,IAAA,MAAM,KAAK,GAAsB;AAC7B,QAAA,IAAI,EAAE,KAAK;AACX,QAAA,KAAK,EAAE,cAAc,CAAC,CAAC,CAAC;KAC3B,CAAA;AAED;;AAEG;IACH,MAAM,aAAa,GAAG,oBAAoB;;;AAGtC,IAAA,KAAK,IAAI,KAAK,CAAC,MAAM,KAAK,cAAc,CAAC,MAAM;AAC3C,UAAE,KAAK;UACL,aAAa,CAAC,cAAc,CAAC,EACnC,QAAQ,CACX,CAAA;AAED,IAAA,MAAM,iBAAiB,GAAG,WAAW,CAAI,aAAa,EAAE,cAAc,EAAE;AACpE,QAAA,IAAI,EAAE,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC;AAChC,cAAE,eAAe;AACjB,cAAE,aAAa,CAAC,cAAc,EAAE,eAAe,CAAC;AACvD,KAAA,CAAC,CAAA;IAEF,OAAO;AACH,QAAA,kBAAkB,EAAE,QAAQ;AAC5B,QAAA,IAAI,EAAE,CAAC,CAAS,KAAI;AAChB,YAAA,KAAK,CAAC,KAAK,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAA;AAClC,YAAA,KAAK,CAAC,IAAI,GAAG,CAAC,IAAI,QAAQ,CAAA;AAC1B,YAAA,OAAO,KAAK,CAAA;SACf;KACJ,CAAA;AACL;;;;"}