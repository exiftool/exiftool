{"version":3,"file":"index.mjs","sources":["../../../../../../src/render/dom/scroll/offsets/index.ts"],"sourcesContent":["import { defaultOffset, interpolate } from \"motion-dom\"\nimport { clamp } from \"motion-utils\"\nimport { ScrollInfo, ScrollInfoOptions } from \"../types\"\nimport { calcInset } from \"./inset\"\nimport { resolveOffset } from \"./offset\"\nimport { ScrollOffset } from \"./presets\"\n\nconst point = { x: 0, y: 0 }\n\nfunction getTargetSize(target: Element) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? (target as SVGGraphicsElement).getBBox()\n        : { width: target.clientWidth, height: target.clientHeight }\n}\n\nexport function resolveOffsets(\n    container: Element,\n    info: ScrollInfo,\n    options: ScrollInfoOptions\n) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options\n    const { target = container, axis = \"y\" } = options\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\"\n\n    const inset = target !== container ? calcInset(target, container) : point\n\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize =\n        target === container\n            ? { width: container.scrollWidth, height: container.scrollHeight }\n            : getTargetSize(target)\n\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    }\n\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0\n\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate\n\n    const numOffsets = offsetDefinition.length\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(\n            offsetDefinition[i],\n            containerSize[lengthLabel],\n            targetSize[lengthLabel],\n            inset[axis]\n        )\n\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets![i]) {\n            hasChanged = true\n        }\n\n        info[axis].offset[i] = offset\n    }\n\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(\n            info[axis].offset,\n            defaultOffset(offsetDefinition),\n            { clamp: false }\n        )\n\n        info[axis].interpolatorOffsets = [...info[axis].offset]\n    }\n\n    info[axis].progress = clamp(\n        0,\n        1,\n        info[axis].interpolate!(info[axis].current)\n    )\n}\n"],"names":[],"mappings":";;;;;;AAOA,MAAM,KAAK,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAA;AAE5B,SAAS,aAAa,CAAC,MAAe,EAAA;IAClC,OAAO,SAAS,IAAI,MAAM,IAAI,MAAM,CAAC,OAAO,KAAK,KAAK;AAClD,UAAG,MAA6B,CAAC,OAAO,EAAE;AAC1C,UAAE,EAAE,KAAK,EAAE,MAAM,CAAC,WAAW,EAAE,MAAM,EAAE,MAAM,CAAC,YAAY,EAAE,CAAA;AACpE,CAAC;SAEe,cAAc,CAC1B,SAAkB,EAClB,IAAgB,EAChB,OAA0B,EAAA;IAE1B,MAAM,EAAE,MAAM,EAAE,gBAAgB,GAAG,YAAY,CAAC,GAAG,EAAE,GAAG,OAAO,CAAA;IAC/D,MAAM,EAAE,MAAM,GAAG,SAAS,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,OAAO,CAAA;AAClD,IAAA,MAAM,WAAW,GAAG,IAAI,KAAK,GAAG,GAAG,QAAQ,GAAG,OAAO,CAAA;AAErD,IAAA,MAAM,KAAK,GAAG,MAAM,KAAK,SAAS,GAAG,SAAS,CAAC,MAAM,EAAE,SAAS,CAAC,GAAG,KAAK,CAAA;AAEzE;;;;AAIG;AACH,IAAA,MAAM,UAAU,GACZ,MAAM,KAAK,SAAS;AAChB,UAAE,EAAE,KAAK,EAAE,SAAS,CAAC,WAAW,EAAE,MAAM,EAAE,SAAS,CAAC,YAAY,EAAE;AAClE,UAAE,aAAa,CAAC,MAAM,CAAC,CAAA;AAE/B,IAAA,MAAM,aAAa,GAAG;QAClB,KAAK,EAAE,SAAS,CAAC,WAAW;QAC5B,MAAM,EAAE,SAAS,CAAC,YAAY;KACjC,CAAA;AAED;;;AAGG;IACH,IAAI,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAA;AAE5B;;;AAGG;IACH,IAAI,UAAU,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,WAAW,CAAA;AAExC,IAAA,MAAM,UAAU,GAAG,gBAAgB,CAAC,MAAM,CAAA;AAC1C,IAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;QACjC,MAAM,MAAM,GAAG,aAAa,CACxB,gBAAgB,CAAC,CAAC,CAAC,EACnB,aAAa,CAAC,WAAW,CAAC,EAC1B,UAAU,CAAC,WAAW,CAAC,EACvB,KAAK,CAAC,IAAI,CAAC,CACd,CAAA;AAED,QAAA,IAAI,CAAC,UAAU,IAAI,MAAM,KAAK,IAAI,CAAC,IAAI,CAAC,CAAC,mBAAoB,CAAC,CAAC,CAAC,EAAE;YAC9D,UAAU,GAAG,IAAI,CAAA;SACpB;QAED,IAAI,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,CAAA;KAChC;AAED;;;AAGG;IACH,IAAI,UAAU,EAAE;QACZ,IAAI,CAAC,IAAI,CAAC,CAAC,WAAW,GAAG,WAAW,CAChC,IAAI,CAAC,IAAI,CAAC,CAAC,MAAM,EACjB,aAAa,CAAC,gBAAgB,CAAC,EAC/B,EAAE,KAAK,EAAE,KAAK,EAAE,CACnB,CAAA;AAED,QAAA,IAAI,CAAC,IAAI,CAAC,CAAC,mBAAmB,GAAG,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAA;KAC1D;IAED,IAAI,CAAC,IAAI,CAAC,CAAC,QAAQ,GAAG,KAAK,CACvB,CAAC,EACD,CAAC,EACD,IAAI,CAAC,IAAI,CAAC,CAAC,WAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAC9C,CAAA;AACL;;;;"}