{"version":3,"file":"motion-values.mjs","sources":["../../../../src/render/utils/motion-values.ts"],"sourcesContent":["import { motionValue } from \"../../value\"\nimport { isMotionValue } from \"../../value/utils/is-motion-value\"\n\ntype MotionStyleLike = Record<string, any>\n\n/**\n * Updates motion values from props changes.\n * Uses `any` type for element to avoid circular dependencies with VisualElement.\n */\nexport function updateMotionValuesFromProps(\n    element: any,\n    next: MotionStyleLike,\n    prev: MotionStyleLike\n) {\n    for (const key in next) {\n        const nextValue = next[key]\n        const prevValue = prev[key]\n\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */\n            element.addValue(key, nextValue)\n        } else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping from a motion value to a static value,\n             * create a new motion value from that\n             */\n            element.addValue(key, motionValue(nextValue, { owner: element }))\n        } else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                const existingValue = element.getValue(key)!\n\n                if (existingValue.liveStyle === true) {\n                    existingValue.jump(nextValue)\n                } else if (!existingValue.hasAnimated) {\n                    existingValue.set(nextValue)\n                }\n            } else {\n                const latestValue = element.getStaticValue(key)\n                element.addValue(\n                    key,\n                    motionValue(\n                        latestValue !== undefined ? latestValue : nextValue,\n                        { owner: element }\n                    )\n                )\n            }\n        }\n    }\n\n    // Handle removed values\n    for (const key in prev) {\n        if (next[key] === undefined) element.removeValue(key)\n    }\n\n    return next\n}\n"],"names":[],"mappings":";;;AAKA;;;AAGG;SACa,2BAA2B,CACvC,OAAY,EACZ,IAAqB,EACrB,IAAqB,EAAA;AAErB,IAAA,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;AACpB,QAAA,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAA;AAC3B,QAAA,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAA;AAE3B,QAAA,IAAI,aAAa,CAAC,SAAS,CAAC,EAAE;AAC1B;;;AAGG;AACH,YAAA,OAAO,CAAC,QAAQ,CAAC,GAAG,EAAE,SAAS,CAAC,CAAA;SACnC;AAAM,aAAA,IAAI,aAAa,CAAC,SAAS,CAAC,EAAE;AACjC;;;AAGG;AACH,YAAA,OAAO,CAAC,QAAQ,CAAC,GAAG,EAAE,WAAW,CAAC,SAAS,EAAE,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,CAAA;SACpE;AAAM,aAAA,IAAI,SAAS,KAAK,SAAS,EAAE;AAChC;;;;AAIG;AACH,YAAA,IAAI,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;gBACvB,MAAM,aAAa,GAAG,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAE,CAAA;AAE5C,gBAAA,IAAI,aAAa,CAAC,SAAS,KAAK,IAAI,EAAE;AAClC,oBAAA,aAAa,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;iBAChC;AAAM,qBAAA,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE;AACnC,oBAAA,aAAa,CAAC,GAAG,CAAC,SAAS,CAAC,CAAA;iBAC/B;aACJ;iBAAM;gBACH,MAAM,WAAW,GAAG,OAAO,CAAC,cAAc,CAAC,GAAG,CAAC,CAAA;gBAC/C,OAAO,CAAC,QAAQ,CACZ,GAAG,EACH,WAAW,CACP,WAAW,KAAK,SAAS,GAAG,WAAW,GAAG,SAAS,EACnD,EAAE,KAAK,EAAE,OAAO,EAAE,CACrB,CACJ,CAAA;aACJ;SACJ;KACJ;;AAGD,IAAA,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;AACpB,QAAA,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,SAAS;AAAE,YAAA,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,CAAA;KACxD;AAED,IAAA,OAAO,IAAI,CAAA;AACf;;;;"}