{"version":3,"file":"size-rollup-waapi-animate.js","sources":["../../motion-utils/dist/es/errors.mjs","../../motion-utils/dist/es/memo.mjs","../../motion-utils/dist/es/format-error-message.mjs","../../motion-utils/dist/es/noop.mjs","../../motion-utils/dist/es/time-conversion.mjs","../../motion-dom/dist/es/animation/keyframes/get-final.mjs","../../motion-dom/dist/es/animation/utils/WithPromise.mjs","../../motion-dom/dist/es/animation/keyframes/utils/fill-wildcards.mjs","../../motion-dom/dist/es/render/dom/is-css-var.mjs","../../motion-dom/dist/es/utils/supports/scroll-timeline.mjs","../../motion-dom/dist/es/utils/supports/flags.mjs","../../motion-dom/dist/es/utils/supports/memo.mjs","../../motion-dom/dist/es/utils/supports/linear-easing.mjs","../../motion-dom/dist/es/animation/waapi/easing/cubic-bezier.mjs","../../motion-dom/dist/es/animation/waapi/easing/supported.mjs","../../motion-dom/dist/es/animation/waapi/easing/map-easing.mjs","../../motion-dom/dist/es/animation/waapi/utils/linear.mjs","../../motion-utils/dist/es/easing/utils/is-bezier-definition.mjs","../../motion-dom/dist/es/animation/NativeAnimation.mjs","../../motion-dom/dist/es/animation/waapi/utils/apply-generator.mjs","../../motion-dom/dist/es/animation/generators/utils/is-generator.mjs","../../motion-dom/dist/es/animation/waapi/start-waapi-animation.mjs","../../motion-dom/dist/es/render/dom/style-set.mjs","../../motion-dom/dist/es/animation/GroupAnimation.mjs","../../motion-dom/dist/es/animation/GroupAnimationWithThen.mjs","../../motion-dom/dist/es/animation/utils/active-animations.mjs","../../motion-dom/dist/es/animation/utils/get-value-transition.mjs","../../motion-dom/dist/es/animation/waapi/utils/px-values.mjs","../../motion-dom/dist/es/animation/keyframes/utils/apply-px-defaults.mjs","../../motion-dom/dist/es/render/dom/style-computed.mjs","../lib/animation/animators/waapi/animate-elements.js","../../motion-dom/dist/es/utils/resolve-elements.mjs","../lib/animation/animators/waapi/animate-style.js"],"sourcesContent":["import { formatErrorMessage } from './format-error-message.mjs';\n\nlet warning = () => { };\nlet invariant = () => { };\nif (typeof process !== \"undefined\" &&\n    process.env?.NODE_ENV !== \"production\") {\n    warning = (check, message, errorCode) => {\n        if (!check && typeof console !== \"undefined\") {\n            console.warn(formatErrorMessage(message, errorCode));\n        }\n    };\n    invariant = (check, message, errorCode) => {\n        if (!check) {\n            throw new Error(formatErrorMessage(message, errorCode));\n        }\n    };\n}\n\nexport { invariant, warning };\n//# sourceMappingURL=errors.mjs.map\n","/*#__NO_SIDE_EFFECTS__*/\nfunction memo(callback) {\n    let result;\n    return () => {\n        if (result === undefined)\n            result = callback();\n        return result;\n    };\n}\n\nexport { memo };\n//# sourceMappingURL=memo.mjs.map\n","function formatErrorMessage(message, errorCode) {\n    return errorCode\n        ? `${message}. For more information and steps for solving, visit https://motion.dev/troubleshooting/${errorCode}`\n        : message;\n}\n\nexport { formatErrorMessage };\n//# sourceMappingURL=format-error-message.mjs.map\n","/*#__NO_SIDE_EFFECTS__*/\nconst noop = (any) => any;\n\nexport { noop };\n//# sourceMappingURL=noop.mjs.map\n","/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\n/*#__NO_SIDE_EFFECTS__*/\nconst secondsToMilliseconds = (seconds) => seconds * 1000;\n/*#__NO_SIDE_EFFECTS__*/\nconst millisecondsToSeconds = (milliseconds) => milliseconds / 1000;\n\nexport { millisecondsToSeconds, secondsToMilliseconds };\n//# sourceMappingURL=time-conversion.mjs.map\n","const isNotNull = (value) => value !== null;\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \"loop\" }, finalKeyframe, speed = 1) {\n    const resolvedKeyframes = keyframes.filter(isNotNull);\n    const useFirstKeyframe = speed < 0 || (repeat && repeatType !== \"loop\" && repeat % 2 === 1);\n    const index = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;\n    return !index || finalKeyframe === undefined\n        ? resolvedKeyframes[index]\n        : finalKeyframe;\n}\n\nexport { getFinalKeyframe };\n//# sourceMappingURL=get-final.mjs.map\n","class WithPromise {\n    constructor() {\n        this.updateFinished();\n    }\n    get finished() {\n        return this._finished;\n    }\n    updateFinished() {\n        this._finished = new Promise((resolve) => {\n            this.resolve = resolve;\n        });\n    }\n    notifyFinished() {\n        this.resolve();\n    }\n    /**\n     * Allows the animation to be awaited.\n     *\n     * @deprecated Use `finished` instead.\n     */\n    then(onResolve, onReject) {\n        return this.finished.then(onResolve, onReject);\n    }\n}\n\nexport { WithPromise };\n//# sourceMappingURL=WithPromise.mjs.map\n","function fillWildcards(keyframes) {\n    for (let i = 1; i < keyframes.length; i++) {\n        keyframes[i] ?? (keyframes[i] = keyframes[i - 1]);\n    }\n}\n\nexport { fillWildcards };\n//# sourceMappingURL=fill-wildcards.mjs.map\n","const isCSSVar = (name) => name.startsWith(\"--\");\n\nexport { isCSSVar };\n//# sourceMappingURL=is-css-var.mjs.map\n","import { memo } from 'motion-utils';\n\nconst supportsScrollTimeline = /* @__PURE__ */ memo(() => window.ScrollTimeline !== undefined);\n\nexport { supportsScrollTimeline };\n//# sourceMappingURL=scroll-timeline.mjs.map\n","/**\n * Add the ability for test suites to manually set support flags\n * to better test more environments.\n */\nconst supportsFlags = {};\n\nexport { supportsFlags };\n//# sourceMappingURL=flags.mjs.map\n","import { memo } from 'motion-utils';\nimport { supportsFlags } from './flags.mjs';\n\nfunction memoSupports(callback, supportsFlag) {\n    const memoized = memo(callback);\n    return () => supportsFlags[supportsFlag] ?? memoized();\n}\n\nexport { memoSupports };\n//# sourceMappingURL=memo.mjs.map\n","import { memoSupports } from './memo.mjs';\n\nconst supportsLinearEasing = /*@__PURE__*/ memoSupports(() => {\n    try {\n        document\n            .createElement(\"div\")\n            .animate({ opacity: 0 }, { easing: \"linear(0, 1)\" });\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}, \"linearEasing\");\n\nexport { supportsLinearEasing };\n//# sourceMappingURL=linear-easing.mjs.map\n","const cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\n\nexport { cubicBezierAsString };\n//# sourceMappingURL=cubic-bezier.mjs.map\n","import { cubicBezierAsString } from './cubic-bezier.mjs';\n\nconst supportedWaapiEasing = {\n    linear: \"linear\",\n    ease: \"ease\",\n    easeIn: \"ease-in\",\n    easeOut: \"ease-out\",\n    easeInOut: \"ease-in-out\",\n    circIn: /*@__PURE__*/ cubicBezierAsString([0, 0.65, 0.55, 1]),\n    circOut: /*@__PURE__*/ cubicBezierAsString([0.55, 0, 1, 0.45]),\n    backIn: /*@__PURE__*/ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\n    backOut: /*@__PURE__*/ cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),\n};\n\nexport { supportedWaapiEasing };\n//# sourceMappingURL=supported.mjs.map\n","import { isBezierDefinition } from 'motion-utils';\nimport { supportsLinearEasing } from '../../../utils/supports/linear-easing.mjs';\nimport { generateLinearEasing } from '../utils/linear.mjs';\nimport { cubicBezierAsString } from './cubic-bezier.mjs';\nimport { supportedWaapiEasing } from './supported.mjs';\n\nfunction mapEasingToNativeEasing(easing, duration) {\n    if (!easing) {\n        return undefined;\n    }\n    else if (typeof easing === \"function\") {\n        return supportsLinearEasing()\n            ? generateLinearEasing(easing, duration)\n            : \"ease-out\";\n    }\n    else if (isBezierDefinition(easing)) {\n        return cubicBezierAsString(easing);\n    }\n    else if (Array.isArray(easing)) {\n        return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) ||\n            supportedWaapiEasing.easeOut);\n    }\n    else {\n        return supportedWaapiEasing[easing];\n    }\n}\n\nexport { mapEasingToNativeEasing };\n//# sourceMappingURL=map-easing.mjs.map\n","const generateLinearEasing = (easing, duration, // as milliseconds\nresolution = 10 // as milliseconds\n) => {\n    let points = \"\";\n    const numPoints = Math.max(Math.round(duration / resolution), 2);\n    for (let i = 0; i < numPoints; i++) {\n        points += Math.round(easing(i / (numPoints - 1)) * 10000) / 10000 + \", \";\n    }\n    return `linear(${points.substring(0, points.length - 2)})`;\n};\n\nexport { generateLinearEasing };\n//# sourceMappingURL=linear.mjs.map\n","const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === \"number\";\n\nexport { isBezierDefinition };\n//# sourceMappingURL=is-bezier-definition.mjs.map\n","import { invariant, millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { setStyle } from '../render/dom/style-set.mjs';\nimport { supportsScrollTimeline } from '../utils/supports/scroll-timeline.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { startWaapiAnimation } from './waapi/start-waapi-animation.mjs';\nimport { applyGeneratorOptions } from './waapi/utils/apply-generator.mjs';\n\n/**\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\n */\nclass NativeAnimation extends WithPromise {\n    constructor(options) {\n        super();\n        this.finishedTime = null;\n        this.isStopped = false;\n        /**\n         * Tracks a manually-set start time that takes precedence over WAAPI's\n         * dynamic startTime. This is cleared when play() or time setter is called,\n         * allowing WAAPI to take over timing.\n         */\n        this.manualStartTime = null;\n        if (!options)\n            return;\n        const { element, name, keyframes, pseudoElement, allowFlatten = false, finalKeyframe, onComplete, } = options;\n        this.isPseudoElement = Boolean(pseudoElement);\n        this.allowFlatten = allowFlatten;\n        this.options = options;\n        invariant(typeof options.type !== \"string\", `Mini animate() doesn't support \"type\" as a string.`, \"mini-spring\");\n        const transition = applyGeneratorOptions(options);\n        this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);\n        if (transition.autoplay === false) {\n            this.animation.pause();\n        }\n        this.animation.onfinish = () => {\n            this.finishedTime = this.time;\n            if (!pseudoElement) {\n                const keyframe = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n                if (this.updateMotionValue) {\n                    this.updateMotionValue(keyframe);\n                }\n                else {\n                    /**\n                     * If we can, we want to commit the final style as set by the user,\n                     * rather than the computed keyframe value supplied by the animation.\n                     */\n                    setStyle(element, name, keyframe);\n                }\n                this.animation.cancel();\n            }\n            onComplete?.();\n            this.notifyFinished();\n        };\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        this.manualStartTime = null;\n        this.animation.play();\n        if (this.state === \"finished\") {\n            this.updateFinished();\n        }\n    }\n    pause() {\n        this.animation.pause();\n    }\n    complete() {\n        this.animation.finish?.();\n    }\n    cancel() {\n        try {\n            this.animation.cancel();\n        }\n        catch (e) { }\n    }\n    stop() {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        const { state } = this;\n        if (state === \"idle\" || state === \"finished\") {\n            return;\n        }\n        if (this.updateMotionValue) {\n            this.updateMotionValue();\n        }\n        else {\n            this.commitStyles();\n        }\n        if (!this.isPseudoElement)\n            this.cancel();\n    }\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * In this method, we commit styles back to the DOM before cancelling\n     * the animation.\n     *\n     * This is designed to be overridden by NativeAnimationExtended, which\n     * will create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to also correctly calculate velocity for any subsequent animation\n     * while deferring the commit until the next animation frame.\n     */\n    commitStyles() {\n        if (!this.isPseudoElement) {\n            this.animation.commitStyles?.();\n        }\n    }\n    get duration() {\n        const duration = this.animation.effect?.getComputedTiming?.().duration || 0;\n        return millisecondsToSeconds(Number(duration));\n    }\n    get iterationDuration() {\n        const { delay = 0 } = this.options || {};\n        return this.duration + millisecondsToSeconds(delay);\n    }\n    get time() {\n        return millisecondsToSeconds(Number(this.animation.currentTime) || 0);\n    }\n    set time(newTime) {\n        this.manualStartTime = null;\n        this.finishedTime = null;\n        this.animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    /**\n     * The playback speed of the animation.\n     * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n     */\n    get speed() {\n        return this.animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        // Allow backwards playback after finishing\n        if (newSpeed < 0)\n            this.finishedTime = null;\n        this.animation.playbackRate = newSpeed;\n    }\n    get state() {\n        return this.finishedTime !== null\n            ? \"finished\"\n            : this.animation.playState;\n    }\n    get startTime() {\n        return this.manualStartTime ?? Number(this.animation.startTime);\n    }\n    set startTime(newStartTime) {\n        this.manualStartTime = this.animation.startTime = newStartTime;\n    }\n    /**\n     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n     */\n    attachTimeline({ timeline, observe }) {\n        if (this.allowFlatten) {\n            this.animation.effect?.updateTiming({ easing: \"linear\" });\n        }\n        this.animation.onfinish = null;\n        if (timeline && supportsScrollTimeline()) {\n            this.animation.timeline = timeline;\n            return noop;\n        }\n        else {\n            return observe(this);\n        }\n    }\n}\n\nexport { NativeAnimation };\n//# sourceMappingURL=NativeAnimation.mjs.map\n","import { supportsLinearEasing } from '../../../utils/supports/linear-easing.mjs';\nimport { isGenerator } from '../../generators/utils/is-generator.mjs';\n\nfunction applyGeneratorOptions({ type, ...options }) {\n    if (isGenerator(type) && supportsLinearEasing()) {\n        return type.applyToOptions(options);\n    }\n    else {\n        options.duration ?? (options.duration = 300);\n        options.ease ?? (options.ease = \"easeOut\");\n    }\n    return options;\n}\n\nexport { applyGeneratorOptions };\n//# sourceMappingURL=apply-generator.mjs.map\n","function isGenerator(type) {\n    return typeof type === \"function\" && \"applyToOptions\" in type;\n}\n\nexport { isGenerator };\n//# sourceMappingURL=is-generator.mjs.map\n","import { activeAnimations } from '../../stats/animation-count.mjs';\nimport { statsBuffer } from '../../stats/buffer.mjs';\nimport { mapEasingToNativeEasing } from './easing/map-easing.mjs';\n\nfunction startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = \"loop\", ease = \"easeOut\", times, } = {}, pseudoElement = undefined) {\n    const keyframeOptions = {\n        [valueName]: keyframes,\n    };\n    if (times)\n        keyframeOptions.offset = times;\n    const easing = mapEasingToNativeEasing(ease, duration);\n    /**\n     * If this is an easing array, apply to keyframes, not animation as a whole\n     */\n    if (Array.isArray(easing))\n        keyframeOptions.easing = easing;\n    if (statsBuffer.value) {\n        activeAnimations.waapi++;\n    }\n    const options = {\n        delay,\n        duration,\n        easing: !Array.isArray(easing) ? easing : \"linear\",\n        fill: \"both\",\n        iterations: repeat + 1,\n        direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\",\n    };\n    if (pseudoElement)\n        options.pseudoElement = pseudoElement;\n    const animation = element.animate(keyframeOptions, options);\n    if (statsBuffer.value) {\n        animation.finished.finally(() => {\n            activeAnimations.waapi--;\n        });\n    }\n    return animation;\n}\n\nexport { startWaapiAnimation };\n//# sourceMappingURL=start-waapi-animation.mjs.map\n","import { isCSSVar } from './is-css-var.mjs';\n\nfunction setStyle(element, name, value) {\n    isCSSVar(name)\n        ? element.style.setProperty(name, value)\n        : (element.style[name] = value);\n}\n\nexport { setStyle };\n//# sourceMappingURL=style-set.mjs.map\n","class GroupAnimation {\n    constructor(animations) {\n        // Bound to accomadate common `return animation.stop` pattern\n        this.stop = () => this.runAll(\"stop\");\n        this.animations = animations.filter(Boolean);\n    }\n    get finished() {\n        return Promise.all(this.animations.map((animation) => animation.finished));\n    }\n    /**\n     * TODO: Filter out cancelled or stopped animations before returning\n     */\n    getAll(propName) {\n        return this.animations[0][propName];\n    }\n    setAll(propName, newValue) {\n        for (let i = 0; i < this.animations.length; i++) {\n            this.animations[i][propName] = newValue;\n        }\n    }\n    attachTimeline(timeline) {\n        const subscriptions = this.animations.map((animation) => animation.attachTimeline(timeline));\n        return () => {\n            subscriptions.forEach((cancel, i) => {\n                cancel && cancel();\n                this.animations[i].stop();\n            });\n        };\n    }\n    get time() {\n        return this.getAll(\"time\");\n    }\n    set time(time) {\n        this.setAll(\"time\", time);\n    }\n    get speed() {\n        return this.getAll(\"speed\");\n    }\n    set speed(speed) {\n        this.setAll(\"speed\", speed);\n    }\n    get state() {\n        return this.getAll(\"state\");\n    }\n    get startTime() {\n        return this.getAll(\"startTime\");\n    }\n    get duration() {\n        return getMax(this.animations, \"duration\");\n    }\n    get iterationDuration() {\n        return getMax(this.animations, \"iterationDuration\");\n    }\n    runAll(methodName) {\n        this.animations.forEach((controls) => controls[methodName]());\n    }\n    play() {\n        this.runAll(\"play\");\n    }\n    pause() {\n        this.runAll(\"pause\");\n    }\n    cancel() {\n        this.runAll(\"cancel\");\n    }\n    complete() {\n        this.runAll(\"complete\");\n    }\n}\nfunction getMax(animations, propName) {\n    let max = 0;\n    for (let i = 0; i < animations.length; i++) {\n        const value = animations[i][propName];\n        if (value !== null && value > max) {\n            max = value;\n        }\n    }\n    return max;\n}\n\nexport { GroupAnimation };\n//# sourceMappingURL=GroupAnimation.mjs.map\n","import { GroupAnimation } from './GroupAnimation.mjs';\n\nclass GroupAnimationWithThen extends GroupAnimation {\n    then(onResolve, _onReject) {\n        return this.finished.finally(onResolve).then(() => { });\n    }\n}\n\nexport { GroupAnimationWithThen };\n//# sourceMappingURL=GroupAnimationWithThen.mjs.map\n","const animationMaps = new WeakMap();\nconst animationMapKey = (name, pseudoElement = \"\") => `${name}:${pseudoElement}`;\nfunction getAnimationMap(element) {\n    const map = animationMaps.get(element) || new Map();\n    animationMaps.set(element, map);\n    return map;\n}\n\nexport { animationMapKey, getAnimationMap };\n//# sourceMappingURL=active-animations.mjs.map\n","function getValueTransition(transition, key) {\n    return (transition?.[key] ??\n        transition?.[\"default\"] ??\n        transition);\n}\n\nexport { getValueTransition };\n//# sourceMappingURL=get-value-transition.mjs.map\n","const pxValues = new Set([\n    // Border props\n    \"borderWidth\",\n    \"borderTopWidth\",\n    \"borderRightWidth\",\n    \"borderBottomWidth\",\n    \"borderLeftWidth\",\n    \"borderRadius\",\n    \"radius\",\n    \"borderTopLeftRadius\",\n    \"borderTopRightRadius\",\n    \"borderBottomRightRadius\",\n    \"borderBottomLeftRadius\",\n    // Positioning props\n    \"width\",\n    \"maxWidth\",\n    \"height\",\n    \"maxHeight\",\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\",\n    \"inset\",\n    \"insetBlock\",\n    \"insetBlockStart\",\n    \"insetBlockEnd\",\n    \"insetInline\",\n    \"insetInlineStart\",\n    \"insetInlineEnd\",\n    // Spacing props\n    \"padding\",\n    \"paddingTop\",\n    \"paddingRight\",\n    \"paddingBottom\",\n    \"paddingLeft\",\n    \"paddingBlock\",\n    \"paddingBlockStart\",\n    \"paddingBlockEnd\",\n    \"paddingInline\",\n    \"paddingInlineStart\",\n    \"paddingInlineEnd\",\n    \"margin\",\n    \"marginTop\",\n    \"marginRight\",\n    \"marginBottom\",\n    \"marginLeft\",\n    \"marginBlock\",\n    \"marginBlockStart\",\n    \"marginBlockEnd\",\n    \"marginInline\",\n    \"marginInlineStart\",\n    \"marginInlineEnd\",\n    // Misc\n    \"backgroundPositionX\",\n    \"backgroundPositionY\",\n]);\n\nexport { pxValues };\n//# sourceMappingURL=px-values.mjs.map\n","import { pxValues } from '../../waapi/utils/px-values.mjs';\n\nfunction applyPxDefaults(keyframes, name) {\n    for (let i = 0; i < keyframes.length; i++) {\n        if (typeof keyframes[i] === \"number\" && pxValues.has(name)) {\n            keyframes[i] = keyframes[i] + \"px\";\n        }\n    }\n}\n\nexport { applyPxDefaults };\n//# sourceMappingURL=apply-px-defaults.mjs.map\n","import { isCSSVar } from './is-css-var.mjs';\n\nfunction getComputedStyle(element, name) {\n    const computedStyle = window.getComputedStyle(element);\n    return isCSSVar(name)\n        ? computedStyle.getPropertyValue(name)\n        : computedStyle[name];\n}\n\nexport { getComputedStyle };\n//# sourceMappingURL=style-computed.mjs.map\n","import { animationMapKey, applyPxDefaults, fillWildcards, getAnimationMap, getComputedStyle, getValueTransition, NativeAnimation, resolveElements, } from \"motion-dom\";\nimport { invariant, secondsToMilliseconds } from \"motion-utils\";\nexport function animateElements(elementOrSelector, keyframes, options, scope) {\n    // Gracefully handle null/undefined elements (e.g., from querySelector returning null)\n    if (elementOrSelector == null) {\n        return [];\n    }\n    const elements = resolveElements(elementOrSelector, scope);\n    const numElements = elements.length;\n    invariant(Boolean(numElements), \"No valid elements provided.\", \"no-valid-elements\");\n    /**\n     * WAAPI doesn't support interrupting animations.\n     *\n     * Therefore, starting animations requires a three-step process:\n     * 1. Stop existing animations (write styles to DOM)\n     * 2. Resolve keyframes (read styles from DOM)\n     * 3. Create new animations (write styles to DOM)\n     *\n     * The hybrid `animate()` function uses AsyncAnimation to resolve\n     * keyframes before creating new animations, which removes style\n     * thrashing. Here, we have much stricter filesize constraints.\n     * Therefore we do this in a synchronous way that ensures that\n     * at least within `animate()` calls there is no style thrashing.\n     *\n     * In the motion-native-animate-mini-interrupt benchmark this\n     * was 80% faster than a single loop.\n     */\n    const animationDefinitions = [];\n    /**\n     * Step 1: Build options and stop existing animations (write)\n     */\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i];\n        const elementTransition = { ...options };\n        /**\n         * Resolve stagger function if provided.\n         */\n        if (typeof elementTransition.delay === \"function\") {\n            elementTransition.delay = elementTransition.delay(i, numElements);\n        }\n        for (const valueName in keyframes) {\n            let valueKeyframes = keyframes[valueName];\n            if (!Array.isArray(valueKeyframes)) {\n                valueKeyframes = [valueKeyframes];\n            }\n            const valueOptions = {\n                ...getValueTransition(elementTransition, valueName),\n            };\n            valueOptions.duration && (valueOptions.duration = secondsToMilliseconds(valueOptions.duration));\n            valueOptions.delay && (valueOptions.delay = secondsToMilliseconds(valueOptions.delay));\n            /**\n             * If there's an existing animation playing on this element then stop it\n             * before creating a new one.\n             */\n            const map = getAnimationMap(element);\n            const key = animationMapKey(valueName, valueOptions.pseudoElement || \"\");\n            const currentAnimation = map.get(key);\n            currentAnimation && currentAnimation.stop();\n            animationDefinitions.push({\n                map,\n                key,\n                unresolvedKeyframes: valueKeyframes,\n                options: {\n                    ...valueOptions,\n                    element,\n                    name: valueName,\n                    allowFlatten: !elementTransition.type && !elementTransition.ease,\n                },\n            });\n        }\n    }\n    /**\n     * Step 2: Resolve keyframes (read)\n     */\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { unresolvedKeyframes, options: animationOptions } = animationDefinitions[i];\n        const { element, name, pseudoElement } = animationOptions;\n        if (!pseudoElement && unresolvedKeyframes[0] === null) {\n            unresolvedKeyframes[0] = getComputedStyle(element, name);\n        }\n        fillWildcards(unresolvedKeyframes);\n        applyPxDefaults(unresolvedKeyframes, name);\n        /**\n         * If we only have one keyframe, explicitly read the initial keyframe\n         * from the computed style. This is to ensure consistency with WAAPI behaviour\n         * for restarting animations, for instance .play() after finish, when it\n         * has one vs two keyframes.\n         */\n        if (!pseudoElement && unresolvedKeyframes.length < 2) {\n            unresolvedKeyframes.unshift(getComputedStyle(element, name));\n        }\n        animationOptions.keyframes = unresolvedKeyframes;\n    }\n    /**\n     * Step 3: Create new animations (write)\n     */\n    const animations = [];\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { map, key, options: animationOptions } = animationDefinitions[i];\n        const animation = new NativeAnimation(animationOptions);\n        map.set(key, animation);\n        animation.finished.finally(() => map.delete(key));\n        animations.push(animation);\n    }\n    return animations;\n}\n//# sourceMappingURL=animate-elements.js.map","function resolveElements(elementOrSelector, scope, selectorCache) {\n    if (elementOrSelector == null) {\n        return [];\n    }\n    if (elementOrSelector instanceof EventTarget) {\n        return [elementOrSelector];\n    }\n    else if (typeof elementOrSelector === \"string\") {\n        let root = document;\n        if (scope) {\n            root = scope.current;\n        }\n        const elements = selectorCache?.[elementOrSelector] ??\n            root.querySelectorAll(elementOrSelector);\n        return elements ? Array.from(elements) : [];\n    }\n    return Array.from(elementOrSelector).filter((element) => element != null);\n}\n\nexport { resolveElements };\n//# sourceMappingURL=resolve-elements.mjs.map\n","import { GroupAnimationWithThen, } from \"motion-dom\";\nimport { animateElements } from \"./animate-elements\";\nexport const createScopedWaapiAnimate = (scope) => {\n    function scopedAnimate(elementOrSelector, keyframes, options) {\n        return new GroupAnimationWithThen(animateElements(elementOrSelector, keyframes, options, scope));\n    }\n    return scopedAnimate;\n};\nexport const animateMini = /*@__PURE__*/ createScopedWaapiAnimate();\n//# sourceMappingURL=animate-style.js.map"],"names":["invariant","memo","callback","result","undefined","process","env","NODE_ENV","check","message","errorCode","Error","formatErrorMessage","noop","any","secondsToMilliseconds","seconds","millisecondsToSeconds","milliseconds","isNotNull","value","WithPromise","constructor","this","updateFinished","finished","_finished","Promise","resolve","notifyFinished","then","onResolve","onReject","fillWildcards","keyframes","i","length","isCSSVar","name","startsWith","supportsScrollTimeline","window","ScrollTimeline","supportsFlags","memoSupports","supportsFlag","memoized","supportsLinearEasing","document","createElement","animate","opacity","easing","e","cubicBezierAsString","a","b","c","d","supportedWaapiEasing","linear","ease","easeIn","easeOut","easeInOut","circIn","circOut","backIn","backOut","mapEasingToNativeEasing","duration","resolution","points","numPoints","Math","max","round","substring","generateLinearEasing","Array","isArray","isBezierDefinition","map","segmentEasing","NativeAnimation","options","super","finishedTime","isStopped","manualStartTime","element","pseudoElement","allowFlatten","finalKeyframe","onComplete","isPseudoElement","Boolean","type","transition","isGenerator","applyToOptions","applyGeneratorOptions","animation","valueName","delay","repeat","repeatType","times","keyframeOptions","offset","fill","iterations","direction","startWaapiAnimation","autoplay","pause","onfinish","time","keyframe","speed","resolvedKeyframes","filter","index","getFinalKeyframe","updateMotionValue","style","setProperty","setStyle","cancel","play","state","complete","finish","stop","commitStyles","effect","getComputedTiming","Number","iterationDuration","currentTime","newTime","playbackRate","newSpeed","playState","startTime","newStartTime","attachTimeline","timeline","observe","updateTiming","GroupAnimation","animations","runAll","all","getAll","propName","setAll","newValue","subscriptions","forEach","getMax","methodName","controls","GroupAnimationWithThen","_onReject","finally","animationMaps","WeakMap","animationMapKey","getAnimationMap","get","Map","set","getValueTransition","key","pxValues","Set","applyPxDefaults","has","getComputedStyle","computedStyle","getPropertyValue","animateElements","elementOrSelector","scope","elements","EventTarget","root","current","querySelectorAll","from","resolveElements","numElements","animationDefinitions","elementTransition","valueKeyframes","valueOptions","currentAnimation","push","unresolvedKeyframes","animationOptions","unshift","delete","createScopedWaapiAnimate","animateMini"],"mappings":"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"}