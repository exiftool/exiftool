{"version":3,"file":"animation-state.mjs","sources":["../../../../src/render/utils/animation-state.ts"],"sourcesContent":["import type {\n    AnimationDefinition,\n    TargetAndTransition,\n    VariantLabels,\n} from \"../../node/types\"\nimport type { AnimationType } from \"../types\"\nimport type { VisualElementAnimationOptions } from \"../../animation/interfaces/types\"\nimport { animateVisualElement } from \"../../animation/interfaces/visual-element\"\nimport { calcChildStagger } from \"../../animation/utils/calc-child-stagger\"\nimport { getVariantContext } from \"./get-variant-context\"\nimport { isAnimationControls } from \"./is-animation-controls\"\nimport { isKeyframesTarget } from \"./is-keyframes-target\"\nimport { isVariantLabel } from \"./is-variant-label\"\nimport { resolveVariant } from \"./resolve-dynamic-variants\"\nimport { shallowCompare } from \"./shallow-compare\"\nimport { variantPriorityOrder } from \"./variant-props\"\n\nexport type { VisualElementAnimationOptions }\n\nexport interface AnimationState {\n    animateChanges: (type?: AnimationType) => Promise<any>\n    setActive: (\n        type: AnimationType,\n        isActive: boolean,\n        options?: VisualElementAnimationOptions\n    ) => Promise<any>\n    setAnimateFunction: (fn: any) => void\n    getState: () => { [key: string]: AnimationTypeState }\n    reset: () => void\n}\n\ninterface DefinitionAndOptions {\n    animation: AnimationDefinition\n    options?: VisualElementAnimationOptions\n}\n\nexport type AnimationList = string[] | TargetAndTransition[]\n\nconst reversePriorityOrder = [...variantPriorityOrder].reverse()\nconst numAnimationTypes = variantPriorityOrder.length\n\n/**\n * Type for the animate function that can be injected.\n * This allows the animation implementation to be provided by the framework layer.\n */\nexport type AnimateFunction = (animations: DefinitionAndOptions[]) => Promise<any>\n\nfunction createAnimateFunction(visualElement: any): AnimateFunction {\n    return (animations: DefinitionAndOptions[]) => {\n        return Promise.all(\n            animations.map(({ animation, options }) =>\n                animateVisualElement(visualElement, animation, options)\n            )\n        )\n    }\n}\n\nexport function createAnimationState(visualElement: any): AnimationState {\n    let animate = createAnimateFunction(visualElement)\n    let state = createState()\n    let isInitialRender = true\n\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    const buildResolvedTypeValues =\n        (type: AnimationType) =>\n        (\n            acc: { [key: string]: any },\n            definition: string | TargetAndTransition | undefined\n        ) => {\n            const resolved = resolveVariant(\n                visualElement,\n                definition,\n                type === \"exit\"\n                    ? visualElement.presenceContext?.custom\n                    : undefined\n            )\n\n            if (resolved) {\n                const { transition, transitionEnd, ...target } = resolved\n                acc = { ...acc, ...target, ...transitionEnd }\n            }\n\n            return acc\n        }\n\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(\n        makeAnimator: (visualElement: any) => AnimateFunction\n    ) {\n        animate = makeAnimator(visualElement)\n    }\n\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(changedActiveType?: AnimationType) {\n        const { props } = visualElement\n        const context = getVariantContext(visualElement.parent) || {}\n\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        const animations: DefinitionAndOptions[] = []\n\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        const removedKeys = new Set<string>()\n\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        let encounteredKeys: { [key: string]: any } = {}\n\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        let removedVariantIndex = Infinity\n\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (let i = 0; i < numAnimationTypes; i++) {\n            const type = reversePriorityOrder[i]\n            const typeState = state[type]\n            const prop =\n                props[type] !== undefined\n                    ? props[type]\n                    : context[type as keyof typeof context]\n            const propIsVariant = isVariantLabel(prop)\n\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            const activeDelta =\n                type === changedActiveType ? typeState.isActive : null\n\n            if (activeDelta === false) removedVariantIndex = i\n\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            let isInherited =\n                prop === context[type as keyof typeof context] &&\n                prop !== props[type] &&\n                propIsVariant\n\n            if (\n                isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount\n            ) {\n                isInherited = false\n            }\n\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = { ...encounteredKeys }\n\n            // Check if we can skip analysing this prop early\n            if (\n                // If it isn't active and hasn't *just* been set as inactive\n                (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\"\n            ) {\n                continue\n            }\n\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            const variantDidChange = checkVariantsDidChange(\n                typeState.prevProp,\n                prop\n            )\n\n            let shouldAnimateType =\n                variantDidChange ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant)\n\n            let handledRemovedValues = false\n\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            const definitionList = Array.isArray(prop) ? prop : [prop]\n\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            let resolvedValues = definitionList.reduce(\n                buildResolvedTypeValues(type),\n                {}\n            )\n\n            if (activeDelta === false) resolvedValues = {}\n\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            const { prevResolvedValues = {} } = typeState\n\n            const allKeys = {\n                ...prevResolvedValues,\n                ...resolvedValues,\n            }\n            const markToAnimate = (key: string) => {\n                shouldAnimateType = true\n                if (removedKeys.has(key)) {\n                    handledRemovedValues = true\n                    removedKeys.delete(key)\n                }\n                typeState.needsAnimating[key] = true\n\n                const motionValue = visualElement.getValue(key)\n                if (motionValue) motionValue.liveStyle = false\n            }\n\n            for (const key in allKeys) {\n                const next = resolvedValues[key]\n                const prev = prevResolvedValues[key]\n\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key)) continue\n\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                let valueHasChanged = false\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                    valueHasChanged = !shallowCompare(next, prev)\n                } else {\n                    valueHasChanged = next !== prev\n                }\n\n                if (valueHasChanged) {\n                    if (next !== undefined && next !== null) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key)\n                    } else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key)\n                    }\n                } else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key)\n                } else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true\n                }\n            }\n\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop\n            typeState.prevResolvedValues = resolvedValues\n\n            if (typeState.isActive) {\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues }\n            }\n\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false\n            }\n\n            /**\n             * If this is an inherited prop we want to skip this animation\n             * unless the inherited variants haven't changed on this render.\n             */\n            const willAnimateViaParent = isInherited && variantDidChange\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues\n            if (shouldAnimateType && needsAnimating) {\n                animations.push(\n                    ...definitionList.map((animation) => {\n                        const options: VisualElementAnimationOptions = { type }\n\n                        /**\n                         * If we're performing the initial animation, but we're not\n                         * rendering at the same time as the variant-controlling parent,\n                         * we want to use the parent's transition to calculate the stagger.\n                         */\n                        if (\n                            typeof animation === \"string\" &&\n                            isInitialRender &&\n                            !willAnimateViaParent &&\n                            visualElement.manuallyAnimateOnMount &&\n                            visualElement.parent\n                        ) {\n                            const { parent } = visualElement\n                            const parentVariant = resolveVariant(\n                                parent,\n                                animation\n                            )\n\n                            if (parent.enteringChildren && parentVariant) {\n                                const { delayChildren } =\n                                    parentVariant.transition || {}\n                                options.delay = calcChildStagger(\n                                    parent.enteringChildren,\n                                    visualElement,\n                                    delayChildren\n                                )\n                            }\n                        }\n\n                        return {\n                            animation: animation as AnimationDefinition,\n                            options,\n                        }\n                    })\n                )\n            }\n        }\n\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            const fallbackAnimation: TargetAndTransition = {}\n\n            /**\n             * If the initial prop contains a transition we can use that, otherwise\n             * allow the animation function to use the visual element's default.\n             */\n            if (typeof props.initial !== \"boolean\") {\n                const initialTransition = resolveVariant(\n                    visualElement,\n                    Array.isArray(props.initial)\n                        ? props.initial[0]\n                        : props.initial\n                )\n\n                if (initialTransition && initialTransition.transition) {\n                    fallbackAnimation.transition = initialTransition.transition\n                }\n            }\n\n            removedKeys.forEach((key) => {\n                const fallbackTarget = visualElement.getBaseTarget(key)\n\n                const motionValue = visualElement.getValue(key)\n                if (motionValue) motionValue.liveStyle = true\n\n                // @ts-expect-error - @mattgperry to figure if we should do something here\n                fallbackAnimation[key] = fallbackTarget ?? null\n            })\n\n            animations.push({ animation: fallbackAnimation })\n        }\n\n        let shouldAnimate = Boolean(animations.length)\n\n        if (\n            isInitialRender &&\n            (props.initial === false || props.initial === props.animate) &&\n            !visualElement.manuallyAnimateOnMount\n        ) {\n            shouldAnimate = false\n        }\n\n        isInitialRender = false\n        return shouldAnimate ? animate(animations) : Promise.resolve()\n    }\n\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type: AnimationType, isActive: boolean) {\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive) return Promise.resolve()\n\n        // Propagate active change to children\n        visualElement.variantChildren?.forEach((child: any) =>\n            child.animationState?.setActive(type, isActive)\n        )\n\n        state[type].isActive = isActive\n\n        const animations = animateChanges(type)\n\n        for (const key in state) {\n            state[key as keyof typeof state].protectedKeys = {}\n        }\n\n        return animations\n    }\n\n    return {\n        animateChanges,\n        setActive,\n        setAnimateFunction,\n        getState: () => state,\n        reset: () => {\n            state = createState()\n            /**\n             * Temporarily disabling resetting this flag as it prevents components\n             * with initial={false} from animating after being remounted, for instance\n             * as the child of an Activity component.\n             */\n            // isInitialRender = true\n        },\n    }\n}\n\nexport function checkVariantsDidChange(prev: any, next: any) {\n    if (typeof next === \"string\") {\n        return next !== prev\n    } else if (Array.isArray(next)) {\n        return !shallowCompare(next, prev)\n    }\n\n    return false\n}\n\nexport interface AnimationTypeState {\n    isActive: boolean\n    protectedKeys: { [key: string]: true }\n    needsAnimating: { [key: string]: boolean }\n    prevResolvedValues: { [key: string]: any }\n    prevProp?: VariantLabels | TargetAndTransition\n}\n\nfunction createTypeState(isActive = false): AnimationTypeState {\n    return {\n        isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    }\n}\n\nfunction createState() {\n    return {\n        animate: createTypeState(true),\n        whileInView: createTypeState(),\n        whileHover: createTypeState(),\n        whileTap: createTypeState(),\n        whileDrag: createTypeState(),\n        whileFocus: createTypeState(),\n        exit: createTypeState(),\n    }\n}\n"],"names":[],"mappings":"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"}