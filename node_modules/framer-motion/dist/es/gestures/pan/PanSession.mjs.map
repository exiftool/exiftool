{"version":3,"file":"PanSession.mjs","sources":["../../../../src/gestures/pan/PanSession.ts"],"sourcesContent":["import type { EventInfo, PanHandler } from \"motion-dom\"\nimport { cancelFrame, frame, frameData, isPrimaryPointer } from \"motion-dom\"\nimport {\n    millisecondsToSeconds,\n    pipe,\n    Point,\n    secondsToMilliseconds,\n    TransformPoint,\n} from \"motion-utils\"\nimport { addPointerEvent } from \"../../events/add-pointer-event\"\nimport { extractEventInfo } from \"../../events/event-info\"\nimport { distance2D } from \"../../utils/distance\"\n\ninterface PanSessionHandlers {\n    onSessionStart: PanHandler\n    onStart: PanHandler\n    onMove: PanHandler\n    onEnd: PanHandler\n    onSessionEnd: PanHandler\n    resumeAnimation: () => void\n}\n\ninterface PanSessionOptions {\n    transformPagePoint?: TransformPoint\n    dragSnapToOrigin?: boolean\n    distanceThreshold?: number\n    contextWindow?: (Window & typeof globalThis) | null\n    /**\n     * Element being dragged. When provided, scroll events on its\n     * ancestors and window are compensated so the gesture continues\n     * smoothly during scroll.\n     */\n    element?: HTMLElement | null\n}\n\ninterface TimestampedPoint extends Point {\n    timestamp: number\n}\n\nconst overflowStyles = /*#__PURE__*/ new Set([\"auto\", \"scroll\"])\n\n/**\n * @internal\n */\nexport class PanSession {\n    /**\n     * @internal\n     */\n    private history: TimestampedPoint[]\n\n    /**\n     * @internal\n     */\n    private startEvent: PointerEvent | null = null\n\n    /**\n     * @internal\n     */\n    private lastMoveEvent: PointerEvent | null = null\n\n    /**\n     * @internal\n     */\n    private lastMoveEventInfo: EventInfo | null = null\n\n    /**\n     * @internal\n     */\n    private transformPagePoint?: TransformPoint\n\n    /**\n     * @internal\n     */\n    private handlers: Partial<PanSessionHandlers> = {}\n\n    /**\n     * @internal\n     */\n    private removeListeners: Function\n\n    /**\n     * For determining if an animation should resume after it is interupted\n     *\n     * @internal\n     */\n    private dragSnapToOrigin: boolean\n\n    /**\n     * The distance after which panning should start.\n     *\n     * @internal\n     */\n    private distanceThreshold: number\n\n    /**\n     * @internal\n     */\n    private contextWindow: PanSessionOptions[\"contextWindow\"] = window\n\n    /**\n     * Scroll positions of scrollable ancestors and window.\n     * @internal\n     */\n    private scrollPositions: Map<Element | Window, Point> = new Map()\n\n    /**\n     * Cleanup function for scroll listeners.\n     * @internal\n     */\n    private removeScrollListeners: (() => void) | null = null\n\n    constructor(\n        event: PointerEvent,\n        handlers: Partial<PanSessionHandlers>,\n        {\n            transformPagePoint,\n            contextWindow = window,\n            dragSnapToOrigin = false,\n            distanceThreshold = 3,\n            element,\n        }: PanSessionOptions = {}\n    ) {\n        // If we have more than one touch, don't start detecting this gesture\n        if (!isPrimaryPointer(event)) return\n\n        this.dragSnapToOrigin = dragSnapToOrigin\n        this.handlers = handlers\n        this.transformPagePoint = transformPagePoint\n        this.distanceThreshold = distanceThreshold\n        this.contextWindow = contextWindow || window\n\n        const info = extractEventInfo(event)\n        const initialInfo = transformPoint(info, this.transformPagePoint)\n        const { point } = initialInfo\n\n        const { timestamp } = frameData\n\n        this.history = [{ ...point, timestamp }]\n\n        const { onSessionStart } = handlers\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history))\n\n        this.removeListeners = pipe(\n            addPointerEvent(\n                this.contextWindow,\n                \"pointermove\",\n                this.handlePointerMove\n            ),\n            addPointerEvent(\n                this.contextWindow,\n                \"pointerup\",\n                this.handlePointerUp\n            ),\n            addPointerEvent(\n                this.contextWindow,\n                \"pointercancel\",\n                this.handlePointerUp\n            )\n        )\n\n        // Start scroll tracking if element provided\n        if (element) {\n            this.startScrollTracking(element)\n        }\n    }\n\n    /**\n     * Start tracking scroll on ancestors and window.\n     */\n    private startScrollTracking(element: HTMLElement): void {\n        // Store initial scroll positions for scrollable ancestors\n        let current = element.parentElement\n        while (current) {\n            const style = getComputedStyle(current)\n            if (\n                overflowStyles.has(style.overflowX) ||\n                overflowStyles.has(style.overflowY)\n            ) {\n                this.scrollPositions.set(current, {\n                    x: current.scrollLeft,\n                    y: current.scrollTop,\n                })\n            }\n            current = current.parentElement\n        }\n\n        // Track window scroll\n        this.scrollPositions.set(window, {\n            x: window.scrollX,\n            y: window.scrollY,\n        })\n\n        // Capture listener catches element scroll events as they bubble\n        window.addEventListener(\"scroll\", this.onElementScroll, {\n            capture: true,\n            passive: true,\n        })\n\n        // Direct window scroll listener (window scroll doesn't bubble)\n        window.addEventListener(\"scroll\", this.onWindowScroll, {\n            passive: true,\n        })\n\n        this.removeScrollListeners = () => {\n            window.removeEventListener(\"scroll\", this.onElementScroll, {\n                capture: true,\n            })\n            window.removeEventListener(\"scroll\", this.onWindowScroll)\n        }\n    }\n\n    private onElementScroll = (event: Event): void => {\n        this.handleScroll(event.target as Element)\n    }\n\n    private onWindowScroll = (): void => {\n        this.handleScroll(window)\n    }\n\n    /**\n     * Handle scroll compensation during drag.\n     *\n     * For element scroll: adjusts history origin since pageX/pageY doesn't change.\n     * For window scroll: adjusts lastMoveEventInfo since pageX/pageY would change.\n     */\n    private handleScroll(target: Element | Window): void {\n        const initial = this.scrollPositions.get(target)\n        if (!initial) return\n\n        const isWindow = target === window\n        const current = isWindow\n            ? { x: window.scrollX, y: window.scrollY }\n            : {\n                  x: (target as Element).scrollLeft,\n                  y: (target as Element).scrollTop,\n              }\n\n        const delta = { x: current.x - initial.x, y: current.y - initial.y }\n        if (delta.x === 0 && delta.y === 0) return\n\n        if (isWindow) {\n            // Window scroll: pageX/pageY changes, so update lastMoveEventInfo\n            if (this.lastMoveEventInfo) {\n                this.lastMoveEventInfo.point.x += delta.x\n                this.lastMoveEventInfo.point.y += delta.y\n            }\n        } else {\n            // Element scroll: pageX/pageY unchanged, so adjust history origin\n            if (this.history.length > 0) {\n                this.history[0].x -= delta.x\n                this.history[0].y -= delta.y\n            }\n        }\n\n        this.scrollPositions.set(target, current)\n        frame.update(this.updatePoint, true)\n    }\n\n    private updatePoint = () => {\n        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return\n\n        const info = getPanInfo(this.lastMoveEventInfo, this.history)\n        const isPanStarted = this.startEvent !== null\n\n        // Only start panning if the offset is larger than 3 pixels. If we make it\n        // any larger than this we'll want to reset the pointer history\n        // on the first update to avoid visual snapping to the cursor.\n        const isDistancePastThreshold =\n            distance2D(info.offset, { x: 0, y: 0 }) >= this.distanceThreshold\n\n        if (!isPanStarted && !isDistancePastThreshold) return\n\n        const { point } = info\n        const { timestamp } = frameData\n        this.history.push({ ...point, timestamp })\n\n        const { onStart, onMove } = this.handlers\n\n        if (!isPanStarted) {\n            onStart && onStart(this.lastMoveEvent, info)\n            this.startEvent = this.lastMoveEvent\n        }\n\n        onMove && onMove(this.lastMoveEvent, info)\n    }\n\n    private handlePointerMove = (event: PointerEvent, info: EventInfo) => {\n        this.lastMoveEvent = event\n        this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint)\n\n        // Throttle mouse move event to once per frame\n        frame.update(this.updatePoint, true)\n    }\n\n    private handlePointerUp = (event: PointerEvent, info: EventInfo) => {\n        this.end()\n\n        const { onEnd, onSessionEnd, resumeAnimation } = this.handlers\n\n        // Resume animation if dragSnapToOrigin is set OR if no drag started (user just clicked)\n        // This ensures constraint animations continue when interrupted by a click\n        if (this.dragSnapToOrigin || !this.startEvent) {\n            resumeAnimation && resumeAnimation()\n        }\n        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return\n\n        const panInfo = getPanInfo(\n            event.type === \"pointercancel\"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint),\n            this.history\n        )\n\n        if (this.startEvent && onEnd) {\n            onEnd(event, panInfo)\n        }\n\n        onSessionEnd && onSessionEnd(event, panInfo)\n    }\n\n    updateHandlers(handlers: Partial<PanSessionHandlers>) {\n        this.handlers = handlers\n    }\n\n    end() {\n        this.removeListeners && this.removeListeners()\n        this.removeScrollListeners && this.removeScrollListeners()\n        this.scrollPositions.clear()\n        cancelFrame(this.updatePoint)\n    }\n}\n\nfunction transformPoint(\n    info: EventInfo,\n    transformPagePoint?: (point: Point) => Point\n) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info\n}\n\nfunction subtractPoint(a: Point, b: Point): Point {\n    return { x: a.x - b.x, y: a.y - b.y }\n}\n\nfunction getPanInfo({ point }: EventInfo, history: TimestampedPoint[]) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    }\n}\n\nfunction startDevicePoint(history: TimestampedPoint[]): TimestampedPoint {\n    return history[0]\n}\n\nfunction lastDevicePoint(history: TimestampedPoint[]): TimestampedPoint {\n    return history[history.length - 1]\n}\n\nfunction getVelocity(history: TimestampedPoint[], timeDelta: number): Point {\n    if (history.length < 2) {\n        return { x: 0, y: 0 }\n    }\n\n    let i = history.length - 1\n    let timestampedPoint: TimestampedPoint | null = null\n    const lastPoint = lastDevicePoint(history)\n    while (i >= 0) {\n        timestampedPoint = history[i]\n        if (\n            lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)\n        ) {\n            break\n        }\n        i--\n    }\n\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 }\n    }\n\n    const time = millisecondsToSeconds(\n        lastPoint.timestamp - timestampedPoint.timestamp\n    )\n    if (time === 0) {\n        return { x: 0, y: 0 }\n    }\n\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    }\n\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0\n    }\n\n    return currentVelocity\n}\n"],"names":[],"mappings":"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"}