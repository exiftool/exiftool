{"version":3,"file":"interpolate.mjs","sources":["../../../src/utils/interpolate.ts"],"sourcesContent":["import {\n    clamp,\n    EasingFunction,\n    invariant,\n    MotionGlobalConfig,\n    noop,\n    pipe,\n    progress,\n} from \"motion-utils\"\nimport { mix } from \"./mix\"\nimport { Mixer, MixerFactory } from \"./mix/types\"\n\nexport interface InterpolateOptions<T> {\n    clamp?: boolean\n    ease?: EasingFunction | EasingFunction[]\n    mixer?: MixerFactory<T>\n}\n\nfunction createMixers<T>(\n    output: T[],\n    ease?: EasingFunction | EasingFunction[],\n    customMixer?: MixerFactory<T>\n) {\n    const mixers: Array<Mixer<T>> = []\n    const mixerFactory: MixerFactory<T> =\n        customMixer || MotionGlobalConfig.mix || mix\n    const numMixers = output.length - 1\n\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1])\n\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease\n            mixer = pipe(easingFunction, mixer) as Mixer<T>\n        }\n\n        mixers.push(mixer)\n    }\n\n    return mixers\n}\n\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revisit this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nexport function interpolate<T>(\n    input: number[],\n    output: T[],\n    { clamp: isClamp = true, ease, mixer }: InterpolateOptions<T> = {}\n): (v: number) => T {\n    const inputLength = input.length\n\n    invariant(\n        inputLength === output.length,\n        \"Both input and output ranges must be the same length\",\n        \"range-length\"\n    )\n\n    /**\n     * If we're only provided a single input, we can just make a function\n     * that returns the output.\n     */\n    if (inputLength === 1) return () => output[0]\n    if (inputLength === 2 && output[0] === output[1]) return () => output[1]\n\n    const isZeroDeltaRange = input[0] === input[1]\n\n    // If input runs highest -> lowest, reverse both arrays\n    if (input[0] > input[inputLength - 1]) {\n        input = [...input].reverse()\n        output = [...output].reverse()\n    }\n\n    const mixers = createMixers(output, ease, mixer)\n    const numMixers = mixers.length\n\n    const interpolator = (v: number): T => {\n        if (isZeroDeltaRange && v < input[0]) return output[0]\n\n        let i = 0\n\n        if (numMixers > 1) {\n            for (; i < input.length - 2; i++) {\n                if (v < input[i + 1]) break\n            }\n        }\n\n        const progressInRange = progress(input[i], input[i + 1], v)\n\n        return mixers[i](progressInRange)\n    }\n\n    return isClamp\n        ? (v: number) =>\n              interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator\n}\n"],"names":[],"mappings":"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"}