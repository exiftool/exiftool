{"version":3,"file":"motion-value.mjs","sources":["../../../../src/animation/interfaces/motion-value.ts"],"sourcesContent":["import { MotionGlobalConfig, secondsToMilliseconds } from \"motion-utils\"\nimport { AsyncMotionValueAnimation } from \"../AsyncMotionValueAnimation\"\nimport { JSAnimation } from \"../JSAnimation\"\nimport type {\n    AnyResolvedKeyframe,\n    ValueAnimationOptions,\n    ValueTransition,\n} from \"../types\"\nimport type { UnresolvedKeyframes } from \"../keyframes/KeyframesResolver\"\nimport { getValueTransition } from \"../utils/get-value-transition\"\nimport { makeAnimationInstant } from \"../utils/make-animation-instant\"\nimport { getDefaultTransition } from \"../utils/default-transitions\"\nimport { getFinalKeyframe } from \"../utils/get-final-keyframe\"\nimport { isTransitionDefined } from \"../utils/is-transition-defined\"\nimport { frame } from \"../../frameloop\"\nimport type { MotionValue, StartAnimation } from \"../../value\"\nimport type { VisualElement } from \"../../render/VisualElement\"\n\nexport const animateMotionValue =\n    <V extends AnyResolvedKeyframe>(\n        name: string,\n        value: MotionValue<V>,\n        target: V | UnresolvedKeyframes<V>,\n        transition: ValueTransition & { elapsed?: number } = {},\n        element?: VisualElement<any>,\n        isHandoff?: boolean\n    ): StartAnimation =>\n    (onComplete) => {\n        const valueTransition = getValueTransition(transition, name) || {}\n\n        /**\n         * Most transition values are currently completely overwritten by value-specific\n         * transitions. In the future it'd be nicer to blend these transitions. But for now\n         * delay actually does inherit from the root transition if not value-specific.\n         */\n        const delay = valueTransition.delay || transition.delay || 0\n\n        /**\n         * Elapsed isn't a public transition option but can be passed through from\n         * optimized appear effects in milliseconds.\n         */\n        let { elapsed = 0 } = transition\n        elapsed = elapsed - secondsToMilliseconds(delay)\n\n        const options: ValueAnimationOptions = {\n            keyframes: Array.isArray(target) ? target : [null, target],\n            ease: \"easeOut\",\n            velocity: value.getVelocity(),\n            ...valueTransition,\n            delay: -elapsed,\n            onUpdate: (v) => {\n                value.set(v)\n                valueTransition.onUpdate && valueTransition.onUpdate(v)\n            },\n            onComplete: () => {\n                onComplete()\n                valueTransition.onComplete && valueTransition.onComplete()\n            },\n            name,\n            motionValue: value,\n            element: isHandoff ? undefined : element,\n        }\n\n        /**\n         * If there's no transition defined for this value, we can generate\n         * unique transition settings for this value.\n         */\n        if (!isTransitionDefined(valueTransition)) {\n            Object.assign(options, getDefaultTransition(name, options))\n        }\n\n        /**\n         * Both WAAPI and our internal animation functions use durations\n         * as defined by milliseconds, while our external API defines them\n         * as seconds.\n         */\n        options.duration &&= secondsToMilliseconds(options.duration)\n        options.repeatDelay &&= secondsToMilliseconds(options.repeatDelay)\n\n        /**\n         * Support deprecated way to set initial value. Prefer keyframe syntax.\n         */\n        if (options.from !== undefined) {\n            options.keyframes[0] = options.from as any\n        }\n\n        let shouldSkip = false\n\n        if (\n            (options as any).type === false ||\n            (options.duration === 0 && !options.repeatDelay)\n        ) {\n            makeAnimationInstant(options)\n\n            if (options.delay === 0) {\n                shouldSkip = true\n            }\n        }\n\n        if (\n            MotionGlobalConfig.instantAnimations ||\n            MotionGlobalConfig.skipAnimations\n        ) {\n            shouldSkip = true\n            makeAnimationInstant(options)\n            options.delay = 0\n        }\n\n        /**\n         * If the transition type or easing has been explicitly set by the user\n         * then we don't want to allow flattening the animation.\n         */\n        options.allowFlatten = !valueTransition.type && !valueTransition.ease\n\n        /**\n         * If we can or must skip creating the animation, and apply only\n         * the final keyframe, do so. We also check once keyframes are resolved but\n         * this early check prevents the need to create an animation at all.\n         */\n        if (shouldSkip && !isHandoff && value.get() !== undefined) {\n            const finalKeyframe = getFinalKeyframe<V>(\n                options.keyframes as V[],\n                valueTransition\n            )\n\n            if (finalKeyframe !== undefined) {\n                frame.update(() => {\n                    options.onUpdate!(finalKeyframe)\n                    options.onComplete!()\n                })\n\n                return\n            }\n        }\n\n        return valueTransition.isSync\n            ? new JSAnimation(options)\n            : new AsyncMotionValueAnimation(options)\n    }\n"],"names":[],"mappings":"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"}