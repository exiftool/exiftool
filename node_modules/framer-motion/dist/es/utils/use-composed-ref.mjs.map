{"version":3,"file":"use-composed-ref.mjs","sources":["../../../src/utils/use-composed-ref.ts"],"sourcesContent":["/**\n * Taken from https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\nimport * as React from \"react\"\n\ntype PossibleRef<T> = React.Ref<T> | undefined\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T): void | (() => void) {\n    if (typeof ref === \"function\") {\n        return ref(value)\n    } else if (ref !== null && ref !== undefined) {\n        ;(ref as React.MutableRefObject<T>).current = value\n    }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n    return (node) => {\n        let hasCleanup = false\n        const cleanups = refs.map((ref) => {\n            const cleanup = setRef(ref, node)\n            if (!hasCleanup && typeof cleanup === \"function\") {\n                hasCleanup = true\n            }\n            return cleanup\n        })\n        // React <19 will log an error to the console if a callback ref returns a\n        // value. We don't use ref cleanups internally so this will only happen if a\n        // user's ref callback returns a value, which we only expect if they are\n        // using the cleanup functionality added in React 19.\n        if (hasCleanup) {\n            return () => {\n                for (let i = 0; i < cleanups.length; i++) {\n                    const cleanup = cleanups[i]\n                    if (typeof cleanup === \"function\") {\n                        cleanup()\n                    } else {\n                        setRef(refs[i], null)\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    return React.useCallback(composeRefs(...refs), refs)\n}\n\nexport { useComposedRefs }\n"],"names":[],"mappings":";;AAAA;;AAEG;AAKH;;;AAGG;AACH,SAAS,MAAM,CAAI,GAAmB,EAAE,KAAQ,EAAA;AAC5C,IAAA,IAAI,OAAO,GAAG,KAAK,UAAU,EAAE;AAC3B,QAAA,OAAO,GAAG,CAAC,KAAK,CAAC,CAAA;KACpB;SAAM,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,KAAK,SAAS,EAAE;AACxC,QAAA,GAAiC,CAAC,OAAO,GAAG,KAAK,CAAA;KACtD;AACL,CAAC;AAED;;;AAGG;AACH,SAAS,WAAW,CAAI,GAAG,IAAsB,EAAA;IAC7C,OAAO,CAAC,IAAI,KAAI;QACZ,IAAI,UAAU,GAAG,KAAK,CAAA;QACtB,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,KAAI;YAC9B,MAAM,OAAO,GAAG,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,CAAA;YACjC,IAAI,CAAC,UAAU,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;gBAC9C,UAAU,GAAG,IAAI,CAAA;aACpB;AACD,YAAA,OAAO,OAAO,CAAA;AAClB,SAAC,CAAC,CAAA;;;;;QAKF,IAAI,UAAU,EAAE;AACZ,YAAA,OAAO,MAAK;AACR,gBAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACtC,oBAAA,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAA;AAC3B,oBAAA,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;AAC/B,wBAAA,OAAO,EAAE,CAAA;qBACZ;yBAAM;wBACH,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAA;qBACxB;iBACJ;AACL,aAAC,CAAA;SACJ;AACL,KAAC,CAAA;AACL,CAAC;AAED;;;AAGG;AACH,SAAS,eAAe,CAAI,GAAG,IAAsB,EAAA;;AAEjD,IAAA,OAAO,KAAK,CAAC,WAAW,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC,EAAE,IAAI,CAAC,CAAA;AACxD;;;;"}