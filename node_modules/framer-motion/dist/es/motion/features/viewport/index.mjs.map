{"version":3,"file":"index.mjs","sources":["../../../../../src/motion/features/viewport/index.ts"],"sourcesContent":["import { Feature } from \"motion-dom\"\nimport { MotionProps } from \"../../types\"\nimport { observeIntersection } from \"./observers\"\n\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n}\n\nexport class InViewFeature extends Feature<Element> {\n    private hasEnteredView = false\n\n    private isInView = false\n\n    private startObserver() {\n        this.unmount()\n\n        const { viewport = {} } = this.node.getProps()\n        const { root, margin: rootMargin, amount = \"some\", once } = viewport\n\n        const options = {\n            root: root ? root.current : undefined,\n            rootMargin,\n            threshold:\n                typeof amount === \"number\" ? amount : thresholdNames[amount],\n        }\n\n        const onIntersectionUpdate = (entry: IntersectionObserverEntry) => {\n            const { isIntersecting } = entry\n\n            /**\n             * If there's been no change in the viewport state, early return.\n             */\n            if (this.isInView === isIntersecting) return\n\n            this.isInView = isIntersecting\n\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && this.hasEnteredView) {\n                return\n            } else if (isIntersecting) {\n                this.hasEnteredView = true\n            }\n\n            if (this.node.animationState) {\n                this.node.animationState.setActive(\n                    \"whileInView\",\n                    isIntersecting\n                )\n            }\n\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const { onViewportEnter, onViewportLeave } = this.node.getProps()\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave\n            callback && callback(entry)\n        }\n\n        return observeIntersection(\n            this.node.current!,\n            options,\n            onIntersectionUpdate\n        )\n    }\n\n    mount() {\n        this.startObserver()\n    }\n\n    update() {\n        if (typeof IntersectionObserver === \"undefined\") return\n\n        const { props, prevProps } = this.node\n        const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(\n            hasViewportOptionChanged(props, prevProps)\n        )\n\n        if (hasOptionsChanged) {\n            this.startObserver()\n        }\n    }\n\n    unmount() {}\n}\n\nfunction hasViewportOptionChanged(\n    { viewport = {} }: MotionProps,\n    { viewport: prevViewport = {} }: MotionProps = {}\n) {\n    return (name: keyof typeof viewport) =>\n        viewport[name] !== prevViewport[name]\n}\n"],"names":[],"mappings":";;;AAIA,MAAM,cAAc,GAAG;AACnB,IAAA,IAAI,EAAE,CAAC;AACP,IAAA,GAAG,EAAE,CAAC;CACT,CAAA;AAEK,MAAO,aAAc,SAAQ,OAAgB,CAAA;AAAnD,IAAA,WAAA,GAAA;;QACY,IAAc,CAAA,cAAA,GAAG,KAAK,CAAA;QAEtB,IAAQ,CAAA,QAAA,GAAG,KAAK,CAAA;KA4E3B;IA1EW,aAAa,GAAA;QACjB,IAAI,CAAC,OAAO,EAAE,CAAA;AAEd,QAAA,MAAM,EAAE,QAAQ,GAAG,EAAE,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAA;AAC9C,QAAA,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,GAAG,MAAM,EAAE,IAAI,EAAE,GAAG,QAAQ,CAAA;AAEpE,QAAA,MAAM,OAAO,GAAG;YACZ,IAAI,EAAE,IAAI,GAAG,IAAI,CAAC,OAAO,GAAG,SAAS;YACrC,UAAU;AACV,YAAA,SAAS,EACL,OAAO,MAAM,KAAK,QAAQ,GAAG,MAAM,GAAG,cAAc,CAAC,MAAM,CAAC;SACnE,CAAA;AAED,QAAA,MAAM,oBAAoB,GAAG,CAAC,KAAgC,KAAI;AAC9D,YAAA,MAAM,EAAE,cAAc,EAAE,GAAG,KAAK,CAAA;AAEhC;;AAEG;AACH,YAAA,IAAI,IAAI,CAAC,QAAQ,KAAK,cAAc;gBAAE,OAAM;AAE5C,YAAA,IAAI,CAAC,QAAQ,GAAG,cAAc,CAAA;AAE9B;;;AAGG;YACH,IAAI,IAAI,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,EAAE;gBAChD,OAAM;aACT;iBAAM,IAAI,cAAc,EAAE;AACvB,gBAAA,IAAI,CAAC,cAAc,GAAG,IAAI,CAAA;aAC7B;AAED,YAAA,IAAI,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;gBAC1B,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,SAAS,CAC9B,aAAa,EACb,cAAc,CACjB,CAAA;aACJ;AAED;;;AAGG;AACH,YAAA,MAAM,EAAE,eAAe,EAAE,eAAe,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAA;YACjE,MAAM,QAAQ,GAAG,cAAc,GAAG,eAAe,GAAG,eAAe,CAAA;AACnE,YAAA,QAAQ,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAA;AAC/B,SAAC,CAAA;AAED,QAAA,OAAO,mBAAmB,CACtB,IAAI,CAAC,IAAI,CAAC,OAAQ,EAClB,OAAO,EACP,oBAAoB,CACvB,CAAA;KACJ;IAED,KAAK,GAAA;QACD,IAAI,CAAC,aAAa,EAAE,CAAA;KACvB;IAED,MAAM,GAAA;QACF,IAAI,OAAO,oBAAoB,KAAK,WAAW;YAAE,OAAM;QAEvD,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC,IAAI,CAAA;AACtC,QAAA,MAAM,iBAAiB,GAAG,CAAC,QAAQ,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC,IAAI,CACvD,wBAAwB,CAAC,KAAK,EAAE,SAAS,CAAC,CAC7C,CAAA;QAED,IAAI,iBAAiB,EAAE;YACnB,IAAI,CAAC,aAAa,EAAE,CAAA;SACvB;KACJ;AAED,IAAA,OAAO,MAAK;AACf,CAAA;AAED,SAAS,wBAAwB,CAC7B,EAAE,QAAQ,GAAG,EAAE,EAAe,EAC9B,EAAE,QAAQ,EAAE,YAAY,GAAG,EAAE,KAAkB,EAAE,EAAA;AAEjD,IAAA,OAAO,CAAC,IAA2B,KAC/B,QAAQ,CAAC,IAAI,CAAC,KAAK,YAAY,CAAC,IAAI,CAAC,CAAA;AAC7C;;;;"}