{"version":3,"file":"dom.js","sources":["../../src/animation/utils/is-dom-keyframes.ts","../../src/animation/animate/resolve-subjects.ts","../../src/animation/sequence/utils/calc-repeat-duration.ts","../../src/animation/sequence/utils/calc-time.ts","../../src/animation/sequence/utils/edit.ts","../../src/animation/sequence/utils/normalize-times.ts","../../src/animation/sequence/utils/sort.ts","../../src/animation/sequence/create.ts","../../src/animation/utils/create-visual-element.ts","../../src/animation/animate/subject.ts","../../src/animation/animate/sequence.ts","../../src/animation/animate/index.ts","../../src/animation/animators/waapi/animate-elements.ts","../../src/animation/animators/waapi/animate-style.ts","../../src/render/dom/scroll/info.ts","../../src/render/dom/scroll/offsets/inset.ts","../../src/render/dom/scroll/offsets/edge.ts","../../src/render/dom/scroll/offsets/offset.ts","../../src/render/dom/scroll/offsets/presets.ts","../../src/render/dom/scroll/offsets/index.ts","../../src/render/dom/scroll/on-scroll-handler.ts","../../src/render/dom/scroll/track.ts","../../src/render/dom/scroll/utils/get-timeline.ts","../../src/render/dom/scroll/attach-animation.ts","../../src/render/dom/scroll/attach-function.ts","../../src/render/dom/scroll/index.ts","../../src/render/dom/viewport/index.ts","../../src/utils/distance.ts"],"sourcesContent":["import { DOMKeyframesDefinition } from \"motion-dom\"\n\nexport function isDOMKeyframes(\n    keyframes: unknown\n): keyframes is DOMKeyframesDefinition {\n    return typeof keyframes === \"object\" && !Array.isArray(keyframes)\n}\n","import {\n    AnimationScope,\n    DOMKeyframesDefinition,\n    SelectorCache,\n    resolveElements,\n} from \"motion-dom\"\nimport { ObjectTarget } from \"../sequence/types\"\nimport { isDOMKeyframes } from \"../utils/is-dom-keyframes\"\n\nexport function resolveSubjects<O extends {}>(\n    subject:\n        | string\n        | Element\n        | Element[]\n        | NodeListOf<Element>\n        | O\n        | O[]\n        | null\n        | undefined,\n    keyframes: DOMKeyframesDefinition | ObjectTarget<O>,\n    scope?: AnimationScope,\n    selectorCache?: SelectorCache\n) {\n    if (subject == null) {\n        return []\n    }\n\n    if (typeof subject === \"string\" && isDOMKeyframes(keyframes)) {\n        return resolveElements(subject, scope, selectorCache)\n    } else if (subject instanceof NodeList) {\n        return Array.from(subject)\n    } else if (Array.isArray(subject)) {\n        return subject.filter((s) => s != null)\n    } else {\n        return [subject]\n    }\n}\n","export function calculateRepeatDuration(\n    duration: number,\n    repeat: number,\n    _repeatDelay: number\n): number {\n    return duration * (repeat + 1)\n}\n","import { SequenceTime } from \"../types\"\n\n/**\n * Given a absolute or relative time definition and current/prev time state of the sequence,\n * calculate an absolute time for the next keyframes.\n */\nexport function calcNextTime(\n    current: number,\n    next: SequenceTime,\n    prev: number,\n    labels: Map<string, number>\n): number {\n    if (typeof next === \"number\") {\n        return next\n    } else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n        return Math.max(0, current + parseFloat(next))\n    } else if (next === \"<\") {\n        return prev\n    } else if (next.startsWith(\"<\")) {\n        return Math.max(0, prev + parseFloat(next.slice(1)))\n    } else {\n        return labels.get(next) ?? current\n    }\n}\n","import { mixNumber, UnresolvedValueKeyframe } from \"motion-dom\"\nimport { Easing, getEasingForSegment, removeItem } from \"motion-utils\"\nimport type { ValueSequence } from \"../types\"\n\nexport function eraseKeyframes(\n    sequence: ValueSequence,\n    startTime: number,\n    endTime: number\n): void {\n    for (let i = 0; i < sequence.length; i++) {\n        const keyframe = sequence[i]\n\n        if (keyframe.at > startTime && keyframe.at < endTime) {\n            removeItem(sequence, keyframe)\n\n            // If we remove this item we have to push the pointer back one\n            i--\n        }\n    }\n}\n\nexport function addKeyframes(\n    sequence: ValueSequence,\n    keyframes: UnresolvedValueKeyframe[],\n    easing: Easing | Easing[],\n    offset: number[],\n    startTime: number,\n    endTime: number\n): void {\n    /**\n     * Erase every existing value between currentTime and targetTime,\n     * this will essentially splice this timeline into any currently\n     * defined ones.\n     */\n    eraseKeyframes(sequence, startTime, endTime)\n\n    for (let i = 0; i < keyframes.length; i++) {\n        sequence.push({\n            value: keyframes[i],\n            at: mixNumber(startTime, endTime, offset[i]),\n            easing: getEasingForSegment(easing, i),\n        })\n    }\n}\n","/**\n * Take an array of times that represent repeated keyframes. For instance\n * if we have original times of [0, 0.5, 1] then our repeated times will\n * be [0, 0.5, 1, 1, 1.5, 2]. Loop over the times and scale them back\n * down to a 0-1 scale.\n */\nexport function normalizeTimes(times: number[], repeat: number): void {\n    for (let i = 0; i < times.length; i++) {\n        times[i] = times[i] / (repeat + 1)\n    }\n}\n","import { AbsoluteKeyframe } from \"../types\"\n\nexport function compareByTime(\n    a: AbsoluteKeyframe,\n    b: AbsoluteKeyframe\n): number {\n    if (a.at === b.at) {\n        if (a.value === null) return 1\n        if (b.value === null) return -1\n        return 0\n    } else {\n        return a.at - b.at\n    }\n}\n","import {\n    AnimationScope,\n    createGeneratorEasing,\n    defaultOffset,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    fillOffset,\n    GeneratorFactory,\n    isGenerator,\n    isMotionValue,\n    Transition,\n    UnresolvedValueKeyframe,\n    type AnyResolvedKeyframe,\n    type MotionValue,\n} from \"motion-dom\"\nimport {\n    Easing,\n    getEasingForSegment,\n    invariant,\n    progress,\n    secondsToMilliseconds,\n} from \"motion-utils\"\nimport { resolveSubjects } from \"../animate/resolve-subjects\"\nimport {\n    AnimationSequence,\n    At,\n    ResolvedAnimationDefinitions,\n    SequenceMap,\n    SequenceOptions,\n    ValueSequence,\n} from \"./types\"\nimport { calculateRepeatDuration } from \"./utils/calc-repeat-duration\"\nimport { calcNextTime } from \"./utils/calc-time\"\nimport { addKeyframes } from \"./utils/edit\"\nimport { normalizeTimes } from \"./utils/normalize-times\"\nimport { compareByTime } from \"./utils/sort\"\n\nconst defaultSegmentEasing = \"easeInOut\"\n\nconst MAX_REPEAT = 20\n\nexport function createAnimationsFromSequence(\n    sequence: AnimationSequence,\n    { defaultTransition = {}, ...sequenceTransition }: SequenceOptions = {},\n    scope?: AnimationScope,\n    generators?: { [key: string]: GeneratorFactory }\n): ResolvedAnimationDefinitions {\n    const defaultDuration = defaultTransition.duration || 0.3\n    const animationDefinitions: ResolvedAnimationDefinitions = new Map()\n    const sequences = new Map<Element | MotionValue, SequenceMap>()\n    const elementCache = {}\n    const timeLabels = new Map<string, number>()\n\n    let prevTime = 0\n    let currentTime = 0\n    let totalDuration = 0\n\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i]\n\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime)\n            continue\n        } else if (!Array.isArray(segment)) {\n            timeLabels.set(\n                segment.name,\n                calcNextTime(currentTime, segment.at, prevTime, timeLabels)\n            )\n            continue\n        }\n\n        let [subject, keyframes, transition = {}] = segment\n\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(\n                currentTime,\n                transition.at,\n                prevTime,\n                timeLabels\n            )\n        }\n\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0\n\n        const resolveValueSequence = (\n            valueKeyframes: UnresolvedValueKeyframe | UnresolvedValueKeyframe[],\n            valueTransition: Transition | DynamicAnimationOptions,\n            valueSequence: ValueSequence,\n            elementIndex = 0,\n            numSubjects = 0\n        ) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes)\n            const {\n                delay = 0,\n                times = defaultOffset(valueKeyframesAsList),\n                type = \"keyframes\",\n                repeat,\n                repeatType,\n                repeatDelay = 0,\n                ...remainingTransition\n            } = valueTransition\n            let { ease = defaultTransition.ease || \"easeOut\", duration } =\n                valueTransition\n\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay =\n                typeof delay === \"function\"\n                    ? delay(elementIndex, numSubjects)\n                    : delay\n\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length\n            const createGenerator = isGenerator(type)\n                ? type\n                : generators?.[type || \"keyframes\"]\n\n            if (numKeyframes <= 2 && createGenerator) {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100\n                if (\n                    numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)\n                ) {\n                    const delta =\n                        valueKeyframesAsList[1] - valueKeyframesAsList[0]\n                    absoluteDelta = Math.abs(delta)\n                }\n\n                const springTransition = { ...remainingTransition }\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration)\n                }\n\n                const springEasing = createGeneratorEasing(\n                    springTransition,\n                    absoluteDelta,\n                    createGenerator\n                )\n\n                ease = springEasing.ease\n                duration = springEasing.duration\n            }\n\n            duration ??= defaultDuration\n\n            const startTime = currentTime + calculatedDelay\n\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1\n            }\n\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length\n            remainder > 0 && fillOffset(times, remainder)\n\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null)\n\n            /**\n             * Handle repeat options\n             */\n            if (repeat) {\n                invariant(\n                    repeat < MAX_REPEAT,\n                    \"Repeat count too high, must be less than 20\",\n                    \"repeat-count-high\"\n                )\n\n                duration = calculateRepeatDuration(\n                    duration,\n                    repeat,\n                    repeatDelay\n                )\n\n                const originalKeyframes = [...valueKeyframesAsList]\n                const originalTimes = [...times]\n                ease = Array.isArray(ease) ? [...ease] : [ease]\n                const originalEase = [...ease]\n\n                for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\n                    valueKeyframesAsList.push(...originalKeyframes)\n\n                    for (\n                        let keyframeIndex = 0;\n                        keyframeIndex < originalKeyframes.length;\n                        keyframeIndex++\n                    ) {\n                        times.push(\n                            originalTimes[keyframeIndex] + (repeatIndex + 1)\n                        )\n                        ease.push(\n                            keyframeIndex === 0\n                                ? \"linear\"\n                                : getEasingForSegment(\n                                      originalEase,\n                                      keyframeIndex - 1\n                                  )\n                        )\n                    }\n                }\n\n                normalizeTimes(times, repeat)\n            }\n\n            const targetTime = startTime + duration\n\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(\n                valueSequence,\n                valueKeyframesAsList,\n                ease as Easing | Easing[],\n                times,\n                startTime,\n                targetTime\n            )\n\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration)\n            totalDuration = Math.max(targetTime, totalDuration)\n        }\n\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences)\n            resolveValueSequence(\n                keyframes as AnyResolvedKeyframe,\n                transition,\n                getValueSequence(\"default\", subjectSequence)\n            )\n        } else {\n            const subjects = resolveSubjects(\n                subject,\n                keyframes as DOMKeyframesDefinition,\n                scope,\n                elementCache\n            )\n\n            const numSubjects = subjects.length\n\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (\n                let subjectIndex = 0;\n                subjectIndex < numSubjects;\n                subjectIndex++\n            ) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes as DOMKeyframesDefinition\n                transition = transition as DynamicAnimationOptions\n\n                const thisSubject = subjects[subjectIndex]\n                const subjectSequence = getSubjectSequence(\n                    thisSubject,\n                    sequences\n                )\n\n                for (const key in keyframes) {\n                    resolveValueSequence(\n                        keyframes[\n                            key as keyof typeof keyframes\n                        ] as UnresolvedValueKeyframe,\n                        getValueTransition(transition, key),\n                        getValueSequence(key, subjectSequence),\n                        subjectIndex,\n                        numSubjects\n                    )\n                }\n            }\n        }\n\n        prevTime = currentTime\n        currentTime += maxDuration\n    }\n\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key]\n\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime)\n\n            const keyframes: UnresolvedValueKeyframe[] = []\n            const valueOffset: number[] = []\n            const valueEasing: Easing[] = []\n\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i]\n                keyframes.push(value)\n                valueOffset.push(progress(0, totalDuration, at))\n                valueEasing.push(easing || \"easeOut\")\n            }\n\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0)\n                keyframes.unshift(keyframes[0])\n                valueEasing.unshift(defaultSegmentEasing)\n            }\n\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1)\n                keyframes.push(null)\n            }\n\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                })\n            }\n\n            const definition = animationDefinitions.get(element)!\n\n            definition.keyframes[key] = keyframes\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            }\n        }\n    })\n\n    return animationDefinitions\n}\n\nfunction getSubjectSequence<O extends {}>(\n    subject: Element | MotionValue | O,\n    sequences: Map<Element | MotionValue | O, SequenceMap>\n): SequenceMap {\n    !sequences.has(subject) && sequences.set(subject, {})\n    return sequences.get(subject)!\n}\n\nfunction getValueSequence(name: string, sequences: SequenceMap): ValueSequence {\n    if (!sequences[name]) sequences[name] = []\n    return sequences[name]\n}\n\nfunction keyframesAsList(\n    keyframes: UnresolvedValueKeyframe | UnresolvedValueKeyframe[]\n): UnresolvedValueKeyframe[] {\n    return Array.isArray(keyframes) ? keyframes : [keyframes]\n}\n\nexport function getValueTransition(\n    transition: DynamicAnimationOptions & At,\n    key: string\n): DynamicAnimationOptions {\n    return transition && transition[key as keyof typeof transition]\n        ? {\n              ...transition,\n              ...(transition[key as keyof typeof transition] as Transition),\n          }\n        : { ...transition }\n}\n\nconst isNumber = (keyframe: unknown) => typeof keyframe === \"number\"\nconst isNumberKeyframesArray = (\n    keyframes: UnresolvedValueKeyframe[]\n): keyframes is number[] => keyframes.every(isNumber)\n","import {\n    HTMLVisualElement,\n    isSVGElement,\n    isSVGSVGElement,\n    ObjectVisualElement,\n    SVGVisualElement,\n    visualElementStore,\n} from \"motion-dom\"\n\nexport function createDOMVisualElement(element: HTMLElement | SVGElement) {\n    const options = {\n        presenceContext: null,\n        props: {},\n        visualState: {\n            renderState: {\n                transform: {},\n                transformOrigin: {},\n                style: {},\n                vars: {},\n                attrs: {},\n            },\n            latestValues: {},\n        },\n    }\n    const node =\n        isSVGElement(element) && !isSVGSVGElement(element)\n            ? new SVGVisualElement(options)\n            : new HTMLVisualElement(options)\n\n    node.mount(element as any)\n\n    visualElementStore.set(element, node)\n}\n\nexport function createObjectVisualElement(subject: Object) {\n    const options = {\n        presenceContext: null,\n        props: {},\n        visualState: {\n            renderState: {\n                output: {},\n            },\n            latestValues: {},\n        },\n    }\n    const node = new ObjectVisualElement(options)\n\n    node.mount(subject)\n\n    visualElementStore.set(subject, node)\n}\n","import {\n    animateTarget,\n    AnimationPlaybackControlsWithThen,\n    AnimationScope,\n    AnyResolvedKeyframe,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    ElementOrSelector,\n    isMotionValue,\n    MotionValue,\n    TargetAndTransition,\n    UnresolvedValueKeyframe,\n    ValueAnimationTransition,\n    visualElementStore,\n} from \"motion-dom\"\nimport { invariant } from \"motion-utils\"\nimport { ObjectTarget } from \"../sequence/types\"\nimport {\n    createDOMVisualElement,\n    createObjectVisualElement,\n} from \"../utils/create-visual-element\"\nimport { isDOMKeyframes } from \"../utils/is-dom-keyframes\"\nimport { resolveSubjects } from \"./resolve-subjects\"\nimport { animateSingleValue } from \"motion-dom\"\n\nexport type AnimationSubject = Element | MotionValue<any> | any\n\nfunction isSingleValue(\n    subject: unknown,\n    keyframes: unknown\n): subject is MotionValue | AnyResolvedKeyframe {\n    return (\n        isMotionValue(subject) ||\n        typeof subject === \"number\" ||\n        (typeof subject === \"string\" && !isDOMKeyframes(keyframes))\n    )\n}\n\n/**\n * Animate a string\n */\nexport function animateSubject(\n    value: string | MotionValue<string>,\n    keyframes: string | UnresolvedValueKeyframe<string>[],\n    options?: ValueAnimationTransition<string>\n): AnimationPlaybackControlsWithThen[]\n/**\n * Animate a number\n */\nexport function animateSubject(\n    value: number | MotionValue<number>,\n    keyframes: number | UnresolvedValueKeyframe<number>[],\n    options?: ValueAnimationTransition<number>\n): AnimationPlaybackControlsWithThen[]\n/**\n * Animate a Element\n */\nexport function animateSubject(\n    element: ElementOrSelector,\n    keyframes: DOMKeyframesDefinition,\n    options?: DynamicAnimationOptions,\n    scope?: AnimationScope\n): AnimationPlaybackControlsWithThen[]\n/**\n * Animate a object\n */\nexport function animateSubject<O extends Object>(\n    object: O | O[],\n    keyframes: ObjectTarget<O>,\n    options?: DynamicAnimationOptions\n): AnimationPlaybackControlsWithThen[]\n/**\n * Implementation\n */\nexport function animateSubject<O extends Object>(\n    subject:\n        | MotionValue<number>\n        | MotionValue<string>\n        | number\n        | string\n        | ElementOrSelector\n        | O\n        | O[],\n    keyframes:\n        | number\n        | string\n        | UnresolvedValueKeyframe<number>[]\n        | UnresolvedValueKeyframe<string>[]\n        | DOMKeyframesDefinition\n        | ObjectTarget<O>,\n    options?:\n        | ValueAnimationTransition<number>\n        | ValueAnimationTransition<string>\n        | DynamicAnimationOptions,\n    scope?: AnimationScope\n): AnimationPlaybackControlsWithThen[] {\n    const animations: AnimationPlaybackControlsWithThen[] = []\n\n    if (isSingleValue(subject, keyframes)) {\n        animations.push(\n            animateSingleValue(\n                subject,\n                isDOMKeyframes(keyframes)\n                    ? (keyframes as any).default || keyframes\n                    : keyframes,\n                options ? (options as any).default || options : options\n            )\n        )\n    } else {\n        // Gracefully handle null/undefined subjects (e.g., from querySelector returning null)\n        if (subject == null) {\n            return animations\n        }\n\n        const subjects = resolveSubjects(\n            subject,\n            keyframes as DOMKeyframesDefinition,\n            scope\n        )\n\n        const numSubjects = subjects.length\n\n        invariant(\n            Boolean(numSubjects),\n            \"No valid elements provided.\",\n            \"no-valid-elements\"\n        )\n\n        for (let i = 0; i < numSubjects; i++) {\n            const thisSubject = subjects[i]\n\n            const createVisualElement =\n                thisSubject instanceof Element\n                    ? createDOMVisualElement\n                    : createObjectVisualElement\n\n            if (!visualElementStore.has(thisSubject)) {\n                createVisualElement(thisSubject as any)\n            }\n\n            const visualElement = visualElementStore.get(thisSubject)!\n            const transition = { ...options }\n\n            /**\n             * Resolve stagger function if provided.\n             */\n            if (\n                \"delay\" in transition &&\n                typeof transition.delay === \"function\"\n            ) {\n                transition.delay = transition.delay(i, numSubjects)\n            }\n\n            animations.push(\n                ...animateTarget(\n                    visualElement,\n                    { ...(keyframes as {}), transition } as TargetAndTransition,\n                    {}\n                )\n            )\n        }\n    }\n\n    return animations\n}\n","import {\n    AnimationPlaybackControlsWithThen,\n    AnimationScope,\n    spring,\n} from \"motion-dom\"\nimport { createAnimationsFromSequence } from \"../sequence/create\"\nimport { AnimationSequence, SequenceOptions } from \"../sequence/types\"\nimport { animateSubject } from \"./subject\"\n\nexport function animateSequence(\n    sequence: AnimationSequence,\n    options?: SequenceOptions,\n    scope?: AnimationScope\n) {\n    const animations: AnimationPlaybackControlsWithThen[] = []\n\n    const animationDefinitions = createAnimationsFromSequence(\n        sequence,\n        options,\n        scope,\n        { spring }\n    )\n\n    animationDefinitions.forEach(({ keyframes, transition }, subject) => {\n        animations.push(...animateSubject(subject, keyframes, transition))\n    })\n\n    return animations\n}\n","import type {\n    AnimationPlaybackControlsWithThen,\n    AnimationScope,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    ElementOrSelector,\n    MotionValue,\n    UnresolvedValueKeyframe,\n    ValueAnimationTransition,\n} from \"motion-dom\"\nimport { GroupAnimationWithThen } from \"motion-dom\"\nimport { removeItem } from \"motion-utils\"\nimport {\n    AnimationSequence,\n    ObjectTarget,\n    SequenceOptions,\n} from \"../sequence/types\"\nimport { animateSequence } from \"./sequence\"\nimport { animateSubject } from \"./subject\"\n\nfunction isSequence(value: unknown): value is AnimationSequence {\n    return Array.isArray(value) && value.some(Array.isArray)\n}\n\n/**\n * Creates an animation function that is optionally scoped\n * to a specific element.\n */\nexport function createScopedAnimate(scope?: AnimationScope) {\n    /**\n     * Animate a sequence\n     */\n    function scopedAnimate(\n        sequence: AnimationSequence,\n        options?: SequenceOptions\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Animate a string\n     */\n    function scopedAnimate(\n        value: string | MotionValue<string>,\n        keyframes: string | UnresolvedValueKeyframe<string>[],\n        options?: ValueAnimationTransition<string>\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Animate a number\n     */\n    function scopedAnimate(\n        value: number | MotionValue<number>,\n        keyframes: number | UnresolvedValueKeyframe<number>[],\n        options?: ValueAnimationTransition<number>\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Animate a generic motion value\n     */\n    function scopedAnimate<V extends string | number>(\n        value: V | MotionValue<V>,\n        keyframes: V | UnresolvedValueKeyframe<V>[],\n        options?: ValueAnimationTransition<V>\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Animate an Element\n     */\n    function scopedAnimate(\n        element: ElementOrSelector,\n        keyframes: DOMKeyframesDefinition,\n        options?: DynamicAnimationOptions\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Animate an object\n     */\n    function scopedAnimate<O extends {}>(\n        object: O | O[],\n        keyframes: ObjectTarget<O>,\n        options?: DynamicAnimationOptions\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Implementation\n     */\n    function scopedAnimate<O extends {}>(\n        subjectOrSequence:\n            | AnimationSequence\n            | MotionValue<number>\n            | MotionValue<string>\n            | number\n            | string\n            | ElementOrSelector\n            | O\n            | O[],\n        optionsOrKeyframes?:\n            | SequenceOptions\n            | number\n            | string\n            | UnresolvedValueKeyframe<number>[]\n            | UnresolvedValueKeyframe<string>[]\n            | DOMKeyframesDefinition\n            | ObjectTarget<O>,\n        options?:\n            | ValueAnimationTransition<number>\n            | ValueAnimationTransition<string>\n            | DynamicAnimationOptions\n    ): AnimationPlaybackControlsWithThen {\n        let animations: AnimationPlaybackControlsWithThen[] = []\n        let animationOnComplete: VoidFunction | undefined\n\n        if (isSequence(subjectOrSequence)) {\n            animations = animateSequence(\n                subjectOrSequence,\n                optionsOrKeyframes as SequenceOptions,\n                scope\n            )\n        } else {\n            // Extract top-level onComplete so it doesn't get applied per-value\n            const { onComplete, ...rest } = options || {}\n            if (typeof onComplete === \"function\") {\n                animationOnComplete = onComplete as VoidFunction\n            }\n            animations = animateSubject(\n                subjectOrSequence as ElementOrSelector,\n                optionsOrKeyframes as DOMKeyframesDefinition,\n                rest as DynamicAnimationOptions,\n                scope\n            )\n        }\n\n        const animation = new GroupAnimationWithThen(animations)\n\n        if (animationOnComplete) {\n            animation.finished.then(animationOnComplete)\n        }\n\n        if (scope) {\n            scope.animations.push(animation)\n            animation.finished.then(() => {\n                removeItem(scope.animations, animation)\n            })\n        }\n\n        return animation\n    }\n\n    return scopedAnimate\n}\n\nexport const animate = createScopedAnimate()\n","import {\n    animationMapKey,\n    AnimationPlaybackControls,\n    AnimationScope,\n    applyPxDefaults,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    ElementOrSelector,\n    fillWildcards,\n    getAnimationMap,\n    getComputedStyle,\n    getValueTransition,\n    NativeAnimation,\n    NativeAnimationOptions,\n    resolveElements,\n    UnresolvedValueKeyframe,\n    ValueKeyframe,\n} from \"motion-dom\"\nimport { invariant, secondsToMilliseconds } from \"motion-utils\"\n\ninterface AnimationDefinition {\n    map: Map<string, NativeAnimation<any>>\n    key: string\n    unresolvedKeyframes: UnresolvedValueKeyframe[]\n    options: Omit<NativeAnimationOptions, \"keyframes\"> & {\n        keyframes?: ValueKeyframe[]\n    }\n}\n\nexport function animateElements(\n    elementOrSelector: ElementOrSelector,\n    keyframes: DOMKeyframesDefinition,\n    options?: DynamicAnimationOptions,\n    scope?: AnimationScope\n) {\n    // Gracefully handle null/undefined elements (e.g., from querySelector returning null)\n    if (elementOrSelector == null) {\n        return []\n    }\n\n    const elements = resolveElements(elementOrSelector, scope) as Array<\n        HTMLElement | SVGElement\n    >\n    const numElements = elements.length\n\n    invariant(\n        Boolean(numElements),\n        \"No valid elements provided.\",\n        \"no-valid-elements\"\n    )\n\n    /**\n     * WAAPI doesn't support interrupting animations.\n     *\n     * Therefore, starting animations requires a three-step process:\n     * 1. Stop existing animations (write styles to DOM)\n     * 2. Resolve keyframes (read styles from DOM)\n     * 3. Create new animations (write styles to DOM)\n     *\n     * The hybrid `animate()` function uses AsyncAnimation to resolve\n     * keyframes before creating new animations, which removes style\n     * thrashing. Here, we have much stricter filesize constraints.\n     * Therefore we do this in a synchronous way that ensures that\n     * at least within `animate()` calls there is no style thrashing.\n     *\n     * In the motion-native-animate-mini-interrupt benchmark this\n     * was 80% faster than a single loop.\n     */\n    const animationDefinitions: AnimationDefinition[] = []\n\n    /**\n     * Step 1: Build options and stop existing animations (write)\n     */\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i]\n        const elementTransition: DynamicAnimationOptions = { ...options }\n\n        /**\n         * Resolve stagger function if provided.\n         */\n        if (typeof elementTransition.delay === \"function\") {\n            elementTransition.delay = elementTransition.delay(i, numElements)\n        }\n\n        for (const valueName in keyframes) {\n            let valueKeyframes = keyframes[valueName as keyof typeof keyframes]!\n\n            if (!Array.isArray(valueKeyframes)) {\n                valueKeyframes = [valueKeyframes]\n            }\n\n            const valueOptions = {\n                ...getValueTransition(elementTransition as any, valueName),\n            }\n\n            valueOptions.duration &&= secondsToMilliseconds(\n                valueOptions.duration\n            )\n\n            valueOptions.delay &&= secondsToMilliseconds(valueOptions.delay)\n\n            /**\n             * If there's an existing animation playing on this element then stop it\n             * before creating a new one.\n             */\n            const map = getAnimationMap(element)\n            const key = animationMapKey(\n                valueName,\n                valueOptions.pseudoElement || \"\"\n            )\n            const currentAnimation = map.get(key)\n            currentAnimation && currentAnimation.stop()\n\n            animationDefinitions.push({\n                map,\n                key,\n                unresolvedKeyframes: valueKeyframes,\n                options: {\n                    ...valueOptions,\n                    element,\n                    name: valueName,\n                    allowFlatten:\n                        !elementTransition.type && !elementTransition.ease,\n                },\n            })\n        }\n    }\n\n    /**\n     * Step 2: Resolve keyframes (read)\n     */\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { unresolvedKeyframes, options: animationOptions } =\n            animationDefinitions[i]\n\n        const { element, name, pseudoElement } = animationOptions\n        if (!pseudoElement && unresolvedKeyframes[0] === null) {\n            unresolvedKeyframes[0] = getComputedStyle(element, name)\n        }\n\n        fillWildcards(unresolvedKeyframes)\n        applyPxDefaults(unresolvedKeyframes, name)\n\n        /**\n         * If we only have one keyframe, explicitly read the initial keyframe\n         * from the computed style. This is to ensure consistency with WAAPI behaviour\n         * for restarting animations, for instance .play() after finish, when it\n         * has one vs two keyframes.\n         */\n        if (!pseudoElement && unresolvedKeyframes.length < 2) {\n            unresolvedKeyframes.unshift(getComputedStyle(element, name))\n        }\n\n        animationOptions.keyframes = unresolvedKeyframes as ValueKeyframe[]\n    }\n\n    /**\n     * Step 3: Create new animations (write)\n     */\n    const animations: AnimationPlaybackControls[] = []\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { map, key, options: animationOptions } = animationDefinitions[i]\n        const animation = new NativeAnimation(\n            animationOptions as NativeAnimationOptions\n        )\n\n        map.set(key, animation)\n        animation.finished.finally(() => map.delete(key))\n\n        animations.push(animation)\n    }\n\n    return animations\n}\n","import {\n    AnimationPlaybackControlsWithThen,\n    AnimationScope,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    ElementOrSelector,\n    GroupAnimationWithThen,\n} from \"motion-dom\"\nimport { animateElements } from \"./animate-elements\"\n\nexport const createScopedWaapiAnimate = (scope?: AnimationScope) => {\n    function scopedAnimate(\n        elementOrSelector: ElementOrSelector,\n        keyframes: DOMKeyframesDefinition,\n        options?: DynamicAnimationOptions\n    ): AnimationPlaybackControlsWithThen {\n        return new GroupAnimationWithThen(\n            animateElements(\n                elementOrSelector,\n                keyframes as DOMKeyframesDefinition,\n                options,\n                scope\n            )\n        )\n    }\n\n    return scopedAnimate\n}\n\nexport const animateMini = /*@__PURE__*/ createScopedWaapiAnimate()\n","import { progress, velocityPerSecond } from \"motion-utils\"\nimport { AxisScrollInfo, ScrollInfo } from \"./types\"\n\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50\n\nconst createAxisInfo = (): AxisScrollInfo => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n})\n\nexport const createScrollInfo = (): ScrollInfo => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n})\n\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\",\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\",\n    },\n} as const\n\nfunction updateAxisInfo(\n    element: Element,\n    axisName: \"x\" | \"y\",\n    info: ScrollInfo,\n    time: number\n) {\n    const axis = info[axisName]\n    const { length, position } = keys[axisName]\n\n    const prev = axis.current\n    const prevTime = info.time\n\n    axis.current = element[`scroll${position}`]\n    axis.scrollLength = element[`scroll${length}`] - element[`client${length}`]\n\n    axis.offset.length = 0\n    axis.offset[0] = 0\n    axis.offset[1] = axis.scrollLength\n    axis.progress = progress(0, axis.scrollLength, axis.current)\n\n    const elapsed = time - prevTime\n    axis.velocity =\n        elapsed > maxElapsed\n            ? 0\n            : velocityPerSecond(axis.current - prev, elapsed)\n}\n\nexport function updateScrollInfo(\n    element: Element,\n    info: ScrollInfo,\n    time: number\n) {\n    updateAxisInfo(element, \"x\", info, time)\n    updateAxisInfo(element, \"y\", info, time)\n    info.time = time\n}\n","import { isHTMLElement } from \"motion-dom\"\n\nexport function calcInset(element: Element, container: Element) {\n    const inset = { x: 0, y: 0 }\n\n    let current: Element | null = element\n    while (current && current !== container) {\n        if (isHTMLElement(current)) {\n            inset.x += current.offsetLeft\n            inset.y += current.offsetTop\n            current = current.offsetParent\n        } else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect()\n            current = current.parentElement!\n            const parentBoundingBox = current.getBoundingClientRect()\n            inset.x += svgBoundingBox.left - parentBoundingBox.left\n            inset.y += svgBoundingBox.top - parentBoundingBox.top\n        } else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox()\n            inset.x += x\n            inset.y += y\n\n            let svg: SVGElement | null = null\n            let parent: SVGElement = current.parentNode as SVGElement\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent\n                }\n                parent = current.parentNode as SVGElement\n            }\n            current = svg\n        } else {\n            break\n        }\n    }\n\n    return inset\n}\n","import { Edge, NamedEdges } from \"../types\"\n\nexport const namedEdges: Record<NamedEdges, number> = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n}\n\nexport function resolveEdge(edge: Edge, length: number, inset = 0) {\n    let delta = 0\n\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (edge in namedEdges) {\n        edge = namedEdges[edge as NamedEdges]\n    }\n\n    /**\n     * Handle unit values\n     */\n    if (typeof edge === \"string\") {\n        const asNumber = parseFloat(edge)\n\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber\n        } else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100\n        } else if (edge.endsWith(\"vw\")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth\n        } else if (edge.endsWith(\"vh\")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight\n        } else {\n            edge = asNumber\n        }\n    }\n\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (typeof edge === \"number\") {\n        delta = length * edge\n    }\n\n    return inset + delta\n}\n","import { Edge, EdgeString, Intersection, ProgressIntersection } from \"../types\"\nimport { namedEdges, resolveEdge } from \"./edge\"\n\nconst defaultOffset: ProgressIntersection = [0, 0]\n\nexport function resolveOffset(\n    offset: Edge | Intersection | ProgressIntersection,\n    containerLength: number,\n    targetLength: number,\n    targetInset: number\n) {\n    let offsetDefinition: ProgressIntersection | [EdgeString, EdgeString] =\n        Array.isArray(offset) ? offset : defaultOffset\n\n    let targetPoint = 0\n    let containerPoint = 0\n\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset]\n    } else if (typeof offset === \"string\") {\n        offset = offset.trim() as EdgeString\n\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \") as [EdgeString, EdgeString]\n        } else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset as keyof typeof namedEdges] ? offset : `0`]\n        }\n    }\n\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset)\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength)\n\n    return targetPoint - containerPoint\n}\n","import { ProgressIntersection } from \"../types\"\n\nexport const ScrollOffset: Record<string, ProgressIntersection[]> = {\n  Enter: [\n    [0, 1],\n    [1, 1],\n  ],\n  Exit: [\n    [0, 0],\n    [1, 0],\n  ],\n  Any: [\n    [1, 0],\n    [0, 1],\n  ],\n  All: [\n    [0, 0],\n    [1, 1],\n  ],\n}\n","import { defaultOffset, interpolate } from \"motion-dom\"\nimport { clamp } from \"motion-utils\"\nimport { ScrollInfo, ScrollInfoOptions } from \"../types\"\nimport { calcInset } from \"./inset\"\nimport { resolveOffset } from \"./offset\"\nimport { ScrollOffset } from \"./presets\"\n\nconst point = { x: 0, y: 0 }\n\nfunction getTargetSize(target: Element) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? (target as SVGGraphicsElement).getBBox()\n        : { width: target.clientWidth, height: target.clientHeight }\n}\n\nexport function resolveOffsets(\n    container: Element,\n    info: ScrollInfo,\n    options: ScrollInfoOptions\n) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options\n    const { target = container, axis = \"y\" } = options\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\"\n\n    const inset = target !== container ? calcInset(target, container) : point\n\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize =\n        target === container\n            ? { width: container.scrollWidth, height: container.scrollHeight }\n            : getTargetSize(target)\n\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    }\n\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0\n\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate\n\n    const numOffsets = offsetDefinition.length\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(\n            offsetDefinition[i],\n            containerSize[lengthLabel],\n            targetSize[lengthLabel],\n            inset[axis]\n        )\n\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets![i]) {\n            hasChanged = true\n        }\n\n        info[axis].offset[i] = offset\n    }\n\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(\n            info[axis].offset,\n            defaultOffset(offsetDefinition),\n            { clamp: false }\n        )\n\n        info[axis].interpolatorOffsets = [...info[axis].offset]\n    }\n\n    info[axis].progress = clamp(\n        0,\n        1,\n        info[axis].interpolate!(info[axis].current)\n    )\n}\n","import { warnOnce } from \"motion-utils\"\nimport { updateScrollInfo } from \"./info\"\nimport { resolveOffsets } from \"./offsets/index\"\nimport {\n    OnScrollHandler,\n    OnScrollInfo,\n    ScrollInfo,\n    ScrollInfoOptions,\n} from \"./types\"\n\nfunction measure(\n    container: Element,\n    target: Element = container,\n    info: ScrollInfo\n) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0\n    info.y.targetOffset = 0\n    if (target !== container) {\n        let node = target as HTMLElement\n        while (node && node !== container) {\n            info.x.targetOffset += node.offsetLeft\n            info.y.targetOffset += node.offsetTop\n            node = node.offsetParent as HTMLElement\n        }\n    }\n\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight\n    info.x.containerLength = container.clientWidth\n    info.y.containerLength = container.clientHeight\n\n    /**\n     * In development mode ensure scroll containers aren't position: static as this makes\n     * it difficult to measure their relative positions.\n     */\n    if (process.env.NODE_ENV !== \"production\") {\n        if (container && target && target !== container) {\n            warnOnce(\n                getComputedStyle(container).position !== \"static\",\n                \"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\"\n            )\n        }\n    }\n}\n\nexport function createOnScrollHandler(\n    element: Element,\n    onScroll: OnScrollInfo,\n    info: ScrollInfo,\n    options: ScrollInfoOptions = {}\n): OnScrollHandler {\n    return {\n        measure: (time) => {\n            measure(element, options.target, info)\n            updateScrollInfo(element, info, time)\n\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options)\n            }\n        },\n        notify: () => onScroll(info),\n    }\n}\n","import { cancelFrame, frame, frameData, resize } from \"motion-dom\"\nimport { noop } from \"motion-utils\"\nimport { createScrollInfo } from \"./info\"\nimport { createOnScrollHandler } from \"./on-scroll-handler\"\nimport { OnScrollHandler, OnScrollInfo, ScrollInfoOptions } from \"./types\"\n\nconst scrollListeners = new WeakMap<Element, VoidFunction>()\nconst resizeListeners = new WeakMap<Element, VoidFunction>()\nconst onScrollHandlers = new WeakMap<Element, Set<OnScrollHandler>>()\n\nexport type ScrollTargets = Array<HTMLElement>\n\nconst getEventTarget = (element: Element) =>\n    element === document.scrollingElement ? window : element\n\nexport function scrollInfo(\n    onScroll: OnScrollInfo,\n    {\n        container = document.scrollingElement as Element,\n        ...options\n    }: ScrollInfoOptions = {}\n) {\n    if (!container) return noop as VoidFunction\n\n    let containerHandlers = onScrollHandlers.get(container)\n\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set()\n        onScrollHandlers.set(container, containerHandlers)\n    }\n\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo()\n    const containerHandler = createOnScrollHandler(\n        container,\n        onScroll,\n        info,\n        options\n    )\n    containerHandlers.add(containerHandler)\n\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const measureAll = () => {\n            for (const handler of containerHandlers) {\n                handler.measure(frameData.timestamp)\n            }\n\n            frame.preUpdate(notifyAll)\n        }\n\n        const notifyAll = () => {\n            for (const handler of containerHandlers) {\n                handler.notify()\n            }\n        }\n\n        const listener = () => frame.read(measureAll)\n\n        scrollListeners.set(container, listener)\n\n        const target = getEventTarget(container)\n        window.addEventListener(\"resize\", listener, { passive: true })\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener))\n        }\n\n        target.addEventListener(\"scroll\", listener, { passive: true })\n\n        listener()\n    }\n\n    const listener = scrollListeners.get(container)!\n    frame.read(listener, false, true)\n\n    return () => {\n        cancelFrame(listener)\n\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const currentHandlers = onScrollHandlers.get(container)\n        if (!currentHandlers) return\n\n        currentHandlers.delete(containerHandler)\n\n        if (currentHandlers.size) return\n\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const scrollListener = scrollListeners.get(container)\n        scrollListeners.delete(container)\n\n        if (scrollListener) {\n            getEventTarget(container).removeEventListener(\n                \"scroll\",\n                scrollListener\n            )\n            resizeListeners.get(container)?.()\n            window.removeEventListener(\"resize\", scrollListener)\n        }\n    }\n}\n","import { ProgressTimeline, supportsScrollTimeline } from \"motion-dom\"\nimport { scrollInfo } from \"../track\"\nimport { ScrollOptionsWithDefaults } from \"../types\"\n\ndeclare global {\n    interface Window {\n        ScrollTimeline: ScrollTimeline\n    }\n}\n\ndeclare class ScrollTimeline implements ProgressTimeline {\n    constructor(options: ScrollOptions)\n\n    currentTime: null | { value: number }\n\n    cancel?: VoidFunction\n}\n\nconst timelineCache = new Map<\n    Element,\n    Map<Element | \"self\", { x?: ProgressTimeline; y?: ProgressTimeline }>\n>()\n\nfunction scrollTimelineFallback(options: ScrollOptionsWithDefaults) {\n    const currentTime = { value: 0 }\n\n    const cancel = scrollInfo((info) => {\n        currentTime.value = info[options.axis!].progress * 100\n    }, options)\n\n    return { currentTime, cancel }\n}\n\nexport function getTimeline({\n    source,\n    container,\n    ...options\n}: ScrollOptionsWithDefaults): ProgressTimeline {\n    const { axis } = options\n\n    if (source) container = source\n\n    const containerCache = timelineCache.get(container) ?? new Map()\n    timelineCache.set(container, containerCache)\n\n    const targetKey = options.target ?? \"self\"\n    const targetCache = containerCache.get(targetKey) ?? {}\n\n    const axisKey = axis + (options.offset ?? []).join(\",\")\n\n    if (!targetCache[axisKey]) {\n        targetCache[axisKey] =\n            !options.target && supportsScrollTimeline()\n                ? new ScrollTimeline({ source: container, axis } as any)\n                : scrollTimelineFallback({ container, ...options })\n    }\n\n    return targetCache[axisKey]!\n}\n","import { AnimationPlaybackControls, observeTimeline } from \"motion-dom\"\nimport { ScrollOptionsWithDefaults } from \"./types\"\nimport { getTimeline } from \"./utils/get-timeline\"\n\nexport function attachToAnimation(\n    animation: AnimationPlaybackControls,\n    options: ScrollOptionsWithDefaults\n) {\n    const timeline = getTimeline(options)\n\n    return animation.attachTimeline({\n        timeline: options.target ? undefined : timeline,\n        observe: (valueAnimation) => {\n            valueAnimation.pause()\n\n            return observeTimeline((progress) => {\n                valueAnimation.time =\n                    valueAnimation.iterationDuration * progress\n            }, timeline)\n        },\n    })\n}\n","import { observeTimeline } from \"motion-dom\"\nimport { scrollInfo } from \"./track\"\nimport { OnScroll, OnScrollWithInfo, ScrollOptionsWithDefaults } from \"./types\"\nimport { getTimeline } from \"./utils/get-timeline\"\n\n/**\n * If the onScroll function has two arguments, it's expecting\n * more specific information about the scroll from scrollInfo.\n */\nfunction isOnScrollWithInfo(onScroll: OnScroll): onScroll is OnScrollWithInfo {\n    return onScroll.length === 2\n}\n\nexport function attachToFunction(\n    onScroll: OnScroll,\n    options: ScrollOptionsWithDefaults\n) {\n    if (isOnScrollWithInfo(onScroll)) {\n        return scrollInfo((info) => {\n            onScroll(info[options.axis!].progress, info)\n        }, options)\n    } else {\n        return observeTimeline(onScroll, getTimeline(options))\n    }\n}\n","import { AnimationPlaybackControls } from \"motion-dom\"\nimport { noop } from \"motion-utils\"\nimport { attachToAnimation } from \"./attach-animation\"\nimport { attachToFunction } from \"./attach-function\"\nimport { OnScroll, ScrollOptions } from \"./types\"\n\nexport function scroll(\n    onScroll: OnScroll | AnimationPlaybackControls,\n    {\n        axis = \"y\",\n        container = document.scrollingElement as Element,\n        ...options\n    }: ScrollOptions = {}\n): VoidFunction {\n    if (!container) return noop as VoidFunction\n\n    const optionsWithDefaults = { axis, container, ...options }\n\n    return typeof onScroll === \"function\"\n        ? attachToFunction(onScroll, optionsWithDefaults)\n        : attachToAnimation(onScroll, optionsWithDefaults)\n}\n","import { ElementOrSelector, resolveElements } from \"motion-dom\"\n\nexport type ViewChangeHandler = (entry: IntersectionObserverEntry) => void\n\ntype MarginValue = `${number}${\"px\" | \"%\"}`\ntype MarginType =\n    | MarginValue\n    | `${MarginValue} ${MarginValue}`\n    | `${MarginValue} ${MarginValue} ${MarginValue}`\n    | `${MarginValue} ${MarginValue} ${MarginValue} ${MarginValue}`\n\nexport interface InViewOptions {\n    root?: Element | Document\n    margin?: MarginType\n    amount?: \"some\" | \"all\" | number\n}\n\nconst thresholds = {\n    some: 0,\n    all: 1,\n}\n\nexport function inView(\n    elementOrSelector: ElementOrSelector,\n    onStart: (\n        element: Element,\n        entry: IntersectionObserverEntry\n    ) => void | ViewChangeHandler,\n    { root, margin: rootMargin, amount = \"some\" }: InViewOptions = {}\n): VoidFunction {\n    const elements = resolveElements(elementOrSelector)\n\n    const activeIntersections = new WeakMap<Element, ViewChangeHandler>()\n\n    const onIntersectionChange: IntersectionObserverCallback = (entries) => {\n        entries.forEach((entry) => {\n            const onEnd = activeIntersections.get(entry.target)\n\n            /**\n             * If there's no change to the intersection, we don't need to\n             * do anything here.\n             */\n            if (entry.isIntersecting === Boolean(onEnd)) return\n\n            if (entry.isIntersecting) {\n                const newOnEnd = onStart(entry.target, entry)\n                if (typeof newOnEnd === \"function\") {\n                    activeIntersections.set(entry.target, newOnEnd)\n                } else {\n                    observer.unobserve(entry.target)\n                }\n            } else if (typeof onEnd === \"function\") {\n                onEnd(entry)\n                activeIntersections.delete(entry.target)\n            }\n        })\n    }\n\n    const observer = new IntersectionObserver(onIntersectionChange, {\n        root,\n        rootMargin,\n        threshold: typeof amount === \"number\" ? amount : thresholds[amount],\n    })\n\n    elements.forEach((element) => observer.observe(element))\n\n    return () => observer.disconnect()\n}\n","import { Point } from \"motion-utils\"\n\nexport const distance = (a: number, b: number) => Math.abs(a - b)\n\nexport function distance2D(a: Point, b: Point): number {\n    // Multi-dimensional\n    const xDelta = distance(a.x, b.x)\n    const yDelta = distance(a.y, b.y)\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2)\n}\n"],"names":["resolveElements","removeItem","mixNumber","getEasingForSegment","defaultOffset","isGenerator","secondsToMilliseconds","createGeneratorEasing","fillOffset","invariant","isMotionValue","progress","isSVGElement","isSVGSVGElement","SVGVisualElement","HTMLVisualElement","visualElementStore","ObjectVisualElement","animateSingleValue","animateTarget","spring","GroupAnimationWithThen","getValueTransition","getAnimationMap","animationMapKey","getComputedStyle","fillWildcards","applyPxDefaults","NativeAnimation","velocityPerSecond","isHTMLElement","interpolate","clamp","warnOnce","noop","frameData","frame","resize","cancelFrame","supportsScrollTimeline","observeTimeline"],"mappings":"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"}