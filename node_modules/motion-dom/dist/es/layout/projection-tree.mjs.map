{"version":3,"file":"projection-tree.mjs","sources":["../../../src/layout/projection-tree.ts"],"sourcesContent":["import type { AnimationOptions } from \"../animation/types\"\nimport type {\n    IProjectionNode,\n    ProjectionNodeOptions,\n} from \"../projection/node/types\"\nimport { HTMLProjectionNode } from \"../projection/node/HTMLProjectionNode\"\nimport { HTMLVisualElement } from \"../render/html/HTMLVisualElement\"\nimport { nodeGroup, type NodeGroup } from \"../projection/node/group\"\nimport { getLayoutId } from \"./get-layout-elements\"\nimport { addScaleCorrector } from \"../render/utils/is-forced-motion-value\"\nimport { correctBorderRadius } from \"../projection/styles/scale-border-radius\"\nimport { correctBoxShadow } from \"../projection/styles/scale-box-shadow\"\n\nlet scaleCorrectorAdded = false\n\n/**\n * Track active projection nodes per element to handle animation interruption.\n * When a new animation starts on an element that already has an active animation,\n * we need to stop the old animation so the new one can start from the current\n * visual position.\n */\nconst activeProjectionNodes = new WeakMap<HTMLElement, IProjectionNode>()\n\nfunction ensureScaleCorrectors() {\n    if (scaleCorrectorAdded) return\n    scaleCorrectorAdded = true\n\n    addScaleCorrector({\n        borderRadius: {\n            ...correctBorderRadius,\n            applyTo: [\n                \"borderTopLeftRadius\",\n                \"borderTopRightRadius\",\n                \"borderBottomLeftRadius\",\n                \"borderBottomRightRadius\",\n            ],\n        },\n        borderTopLeftRadius: correctBorderRadius,\n        borderTopRightRadius: correctBorderRadius,\n        borderBottomLeftRadius: correctBorderRadius,\n        borderBottomRightRadius: correctBorderRadius,\n        boxShadow: correctBoxShadow,\n    })\n}\n\nexport interface ProjectionContext {\n    nodes: Map<HTMLElement, IProjectionNode>\n    visualElements: Map<HTMLElement, HTMLVisualElement>\n    group: NodeGroup\n    root: IProjectionNode\n}\n\n/**\n * Get DOM depth of an element\n */\nfunction getDepth(element: Element): number {\n    let depth = 0\n    let current = element.parentElement\n    while (current) {\n        depth++\n        current = current.parentElement\n    }\n    return depth\n}\n\n/**\n * Find the closest projection parent for an element\n */\nfunction findProjectionParent(\n    element: HTMLElement,\n    nodeCache: Map<HTMLElement, IProjectionNode>\n): IProjectionNode | undefined {\n    let parent = element.parentElement as HTMLElement | null\n    while (parent) {\n        const node = nodeCache.get(parent)\n        if (node) return node\n        parent = parent.parentElement as HTMLElement | null\n    }\n    return undefined\n}\n\n/**\n * Create or reuse a projection node for an element\n */\nfunction createProjectionNode(\n    element: HTMLElement,\n    parent: IProjectionNode | undefined,\n    options: ProjectionNodeOptions,\n    transition?: AnimationOptions\n): { node: IProjectionNode; visualElement: HTMLVisualElement } {\n    // Check for existing active node - reuse it to preserve animation state\n    const existingNode = activeProjectionNodes.get(element)\n    if (existingNode) {\n        const visualElement = existingNode.options.visualElement as HTMLVisualElement\n\n        // Update transition options for the new animation\n        const nodeTransition = transition\n            ? { duration: transition.duration, ease: transition.ease as any }\n            : { duration: 0.3, ease: \"easeOut\" }\n\n        existingNode.setOptions({\n            ...existingNode.options,\n            animate: true,\n            transition: nodeTransition,\n            ...options,\n        })\n\n        // Re-mount the node if it was previously unmounted\n        // This re-adds it to root.nodes so didUpdate() will process it\n        if (!existingNode.instance) {\n            existingNode.mount(element)\n        }\n\n        return { node: existingNode, visualElement }\n    }\n\n    // No existing node - create a new one\n    const latestValues: Record<string, any> = {}\n\n    const visualElement = new HTMLVisualElement({\n        visualState: {\n            latestValues,\n            renderState: {\n                transformOrigin: {},\n                transform: {},\n                style: {},\n                vars: {},\n            },\n        },\n        presenceContext: null,\n        props: {},\n    })\n\n    const node = new HTMLProjectionNode(latestValues, parent)\n\n    // Convert AnimationOptions to transition format for the projection system\n    const nodeTransition = transition\n        ? { duration: transition.duration, ease: transition.ease as any }\n        : { duration: 0.3, ease: \"easeOut\" }\n\n    node.setOptions({\n        visualElement,\n        layout: true,\n        animate: true,\n        transition: nodeTransition,\n        ...options,\n    })\n\n    node.mount(element)\n    visualElement.projection = node\n\n    // Track this node as the active one for this element\n    activeProjectionNodes.set(element, node)\n\n    return { node, visualElement }\n}\n\nexport interface BuildProjectionTreeOptions {\n    defaultTransition?: AnimationOptions\n    sharedTransitions?: Map<string, AnimationOptions>\n}\n\n/**\n * Build a projection tree from a list of elements\n */\nexport function buildProjectionTree(\n    elements: HTMLElement[],\n    existingContext?: ProjectionContext,\n    options?: BuildProjectionTreeOptions\n): ProjectionContext {\n    ensureScaleCorrectors()\n\n    const nodes = existingContext?.nodes ?? new Map<HTMLElement, IProjectionNode>()\n    const visualElements =\n        existingContext?.visualElements ?? new Map<HTMLElement, HTMLVisualElement>()\n    const group = existingContext?.group ?? nodeGroup()\n\n    const defaultTransition = options?.defaultTransition\n    const sharedTransitions = options?.sharedTransitions\n\n    // Sort elements by DOM depth (parents before children)\n    const sorted = [...elements].sort((a, b) => getDepth(a) - getDepth(b))\n\n    let root: IProjectionNode | undefined = existingContext?.root\n\n    for (const element of sorted) {\n        // Skip if already has a node\n        if (nodes.has(element)) continue\n\n        const parent = findProjectionParent(element, nodes)\n        const layoutId = getLayoutId(element)\n        const layoutMode = element.getAttribute(\"data-layout\")\n\n        const nodeOptions: ProjectionNodeOptions = {\n            layoutId: layoutId ?? undefined,\n            animationType: parseLayoutMode(layoutMode),\n        }\n\n        // Use layoutId-specific transition if available, otherwise use default\n        const transition = layoutId && sharedTransitions?.get(layoutId)\n            ? sharedTransitions.get(layoutId)\n            : defaultTransition\n\n        const { node, visualElement } = createProjectionNode(\n            element,\n            parent,\n            nodeOptions,\n            transition\n        )\n\n        nodes.set(element, node)\n        visualElements.set(element, visualElement)\n        group.add(node)\n\n        if (!root) {\n            root = node.root\n        }\n    }\n\n    return {\n        nodes,\n        visualElements,\n        group,\n        root: root!,\n    }\n}\n\n/**\n * Parse the data-layout attribute value\n */\nfunction parseLayoutMode(\n    value: string | null\n): \"size\" | \"position\" | \"both\" | \"preserve-aspect\" {\n    if (value === \"position\") return \"position\"\n    if (value === \"size\") return \"size\"\n    if (value === \"preserve-aspect\") return \"preserve-aspect\"\n    return \"both\"\n}\n\n/**\n * Clean up projection nodes for specific elements.\n * If elementsToCleanup is provided, only those elements are cleaned up.\n * If not provided, all nodes are cleaned up.\n *\n * This allows persisting elements to keep their nodes between animations,\n * matching React's behavior where nodes persist for elements that remain in the DOM.\n */\nexport function cleanupProjectionTree(\n    context: ProjectionContext,\n    elementsToCleanup?: Set<HTMLElement>\n) {\n    const elementsToProcess = elementsToCleanup\n        ? [...context.nodes.entries()].filter(([el]) => elementsToCleanup.has(el))\n        : [...context.nodes.entries()]\n\n    for (const [element, node] of elementsToProcess) {\n        context.group.remove(node)\n        node.unmount()\n\n        // Only clear from activeProjectionNodes if this is still the active node.\n        // A newer animation might have already taken over.\n        if (activeProjectionNodes.get(element) === node) {\n            activeProjectionNodes.delete(element)\n        }\n\n        context.nodes.delete(element)\n        context.visualElements.delete(element)\n    }\n}\n\n/**\n * Set a value on a projection node's visual element\n */\nexport function setNodeValue(\n    context: ProjectionContext,\n    element: HTMLElement,\n    key: string,\n    value: any\n) {\n    const visualElement = context.visualElements.get(element)\n    if (visualElement) {\n        visualElement.latestValues[key] = value\n        visualElement.scheduleRender()\n    }\n}\n"],"names":[],"mappings":"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"}