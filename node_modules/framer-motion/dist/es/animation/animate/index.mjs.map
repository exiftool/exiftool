{"version":3,"file":"index.mjs","sources":["../../../../src/animation/animate/index.ts"],"sourcesContent":["import type {\n    AnimationPlaybackControlsWithThen,\n    AnimationScope,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    ElementOrSelector,\n    MotionValue,\n    UnresolvedValueKeyframe,\n    ValueAnimationTransition,\n} from \"motion-dom\"\nimport { GroupAnimationWithThen } from \"motion-dom\"\nimport { removeItem } from \"motion-utils\"\nimport {\n    AnimationSequence,\n    ObjectTarget,\n    SequenceOptions,\n} from \"../sequence/types\"\nimport { animateSequence } from \"./sequence\"\nimport { animateSubject } from \"./subject\"\n\nfunction isSequence(value: unknown): value is AnimationSequence {\n    return Array.isArray(value) && value.some(Array.isArray)\n}\n\n/**\n * Creates an animation function that is optionally scoped\n * to a specific element.\n */\nexport function createScopedAnimate(scope?: AnimationScope) {\n    /**\n     * Animate a sequence\n     */\n    function scopedAnimate(\n        sequence: AnimationSequence,\n        options?: SequenceOptions\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Animate a string\n     */\n    function scopedAnimate(\n        value: string | MotionValue<string>,\n        keyframes: string | UnresolvedValueKeyframe<string>[],\n        options?: ValueAnimationTransition<string>\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Animate a number\n     */\n    function scopedAnimate(\n        value: number | MotionValue<number>,\n        keyframes: number | UnresolvedValueKeyframe<number>[],\n        options?: ValueAnimationTransition<number>\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Animate a generic motion value\n     */\n    function scopedAnimate<V extends string | number>(\n        value: V | MotionValue<V>,\n        keyframes: V | UnresolvedValueKeyframe<V>[],\n        options?: ValueAnimationTransition<V>\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Animate an Element\n     */\n    function scopedAnimate(\n        element: ElementOrSelector,\n        keyframes: DOMKeyframesDefinition,\n        options?: DynamicAnimationOptions\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Animate an object\n     */\n    function scopedAnimate<O extends {}>(\n        object: O | O[],\n        keyframes: ObjectTarget<O>,\n        options?: DynamicAnimationOptions\n    ): AnimationPlaybackControlsWithThen\n    /**\n     * Implementation\n     */\n    function scopedAnimate<O extends {}>(\n        subjectOrSequence:\n            | AnimationSequence\n            | MotionValue<number>\n            | MotionValue<string>\n            | number\n            | string\n            | ElementOrSelector\n            | O\n            | O[],\n        optionsOrKeyframes?:\n            | SequenceOptions\n            | number\n            | string\n            | UnresolvedValueKeyframe<number>[]\n            | UnresolvedValueKeyframe<string>[]\n            | DOMKeyframesDefinition\n            | ObjectTarget<O>,\n        options?:\n            | ValueAnimationTransition<number>\n            | ValueAnimationTransition<string>\n            | DynamicAnimationOptions\n    ): AnimationPlaybackControlsWithThen {\n        let animations: AnimationPlaybackControlsWithThen[] = []\n        let animationOnComplete: VoidFunction | undefined\n\n        if (isSequence(subjectOrSequence)) {\n            animations = animateSequence(\n                subjectOrSequence,\n                optionsOrKeyframes as SequenceOptions,\n                scope\n            )\n        } else {\n            // Extract top-level onComplete so it doesn't get applied per-value\n            const { onComplete, ...rest } = options || {}\n            if (typeof onComplete === \"function\") {\n                animationOnComplete = onComplete as VoidFunction\n            }\n            animations = animateSubject(\n                subjectOrSequence as ElementOrSelector,\n                optionsOrKeyframes as DOMKeyframesDefinition,\n                rest as DynamicAnimationOptions,\n                scope\n            )\n        }\n\n        const animation = new GroupAnimationWithThen(animations)\n\n        if (animationOnComplete) {\n            animation.finished.then(animationOnComplete)\n        }\n\n        if (scope) {\n            scope.animations.push(animation)\n            animation.finished.then(() => {\n                removeItem(scope.animations, animation)\n            })\n        }\n\n        return animation\n    }\n\n    return scopedAnimate\n}\n\nexport const animate = createScopedAnimate()\n"],"names":[],"mappings":";;;;;AAoBA,SAAS,UAAU,CAAC,KAAc,EAAA;AAC9B,IAAA,OAAO,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;AAC5D,CAAC;AAED;;;AAGG;AACG,SAAU,mBAAmB,CAAC,KAAsB,EAAA;AAgDtD;;AAEG;AACH,IAAA,SAAS,aAAa,CAClB,iBAQS,EACT,kBAOqB,EACrB,OAG6B,EAAA;QAE7B,IAAI,UAAU,GAAwC,EAAE,CAAA;AACxD,QAAA,IAAI,mBAA6C,CAAA;AAEjD,QAAA,IAAI,UAAU,CAAC,iBAAiB,CAAC,EAAE;YAC/B,UAAU,GAAG,eAAe,CACxB,iBAAiB,EACjB,kBAAqC,EACrC,KAAK,CACR,CAAA;SACJ;aAAM;;YAEH,MAAM,EAAE,UAAU,EAAE,GAAG,IAAI,EAAE,GAAG,OAAO,IAAI,EAAE,CAAA;AAC7C,YAAA,IAAI,OAAO,UAAU,KAAK,UAAU,EAAE;gBAClC,mBAAmB,GAAG,UAA0B,CAAA;aACnD;YACD,UAAU,GAAG,cAAc,CACvB,iBAAsC,EACtC,kBAA4C,EAC5C,IAA+B,EAC/B,KAAK,CACR,CAAA;SACJ;AAED,QAAA,MAAM,SAAS,GAAG,IAAI,sBAAsB,CAAC,UAAU,CAAC,CAAA;QAExD,IAAI,mBAAmB,EAAE;AACrB,YAAA,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAA;SAC/C;QAED,IAAI,KAAK,EAAE;AACP,YAAA,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;AAChC,YAAA,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAK;AACzB,gBAAA,UAAU,CAAC,KAAK,CAAC,UAAU,EAAE,SAAS,CAAC,CAAA;AAC3C,aAAC,CAAC,CAAA;SACL;AAED,QAAA,OAAO,SAAS,CAAA;KACnB;AAED,IAAA,OAAO,aAAa,CAAA;AACxB,CAAC;AAEY,MAAA,OAAO,GAAG,mBAAmB;;;;"}