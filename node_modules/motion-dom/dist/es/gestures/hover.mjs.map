{"version":3,"file":"hover.mjs","sources":["../../../src/gestures/hover.ts"],"sourcesContent":["import { ElementOrSelector } from \"../utils/resolve-elements\"\nimport { isDragActive } from \"./drag/state/is-active\"\nimport { EventOptions } from \"./types\"\nimport { setupGesture } from \"./utils/setup\"\n\n/**\n * A function to be called when a hover gesture starts.\n *\n * This function can optionally return a function that will be called\n * when the hover gesture ends.\n *\n * @public\n */\nexport type OnHoverStartEvent = (\n    element: Element,\n    event: PointerEvent\n) => void | OnHoverEndEvent\n\n/**\n * A function to be called when a hover gesture ends.\n *\n * @public\n */\nexport type OnHoverEndEvent = (event: PointerEvent) => void\n\nfunction isValidHover(event: PointerEvent) {\n    return !(event.pointerType === \"touch\" || isDragActive())\n}\n\n/**\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\n *\n * @public\n */\nexport function hover(\n    elementOrSelector: ElementOrSelector,\n    onHoverStart: OnHoverStartEvent,\n    options: EventOptions = {}\n): VoidFunction {\n    const [elements, eventOptions, cancel] = setupGesture(\n        elementOrSelector,\n        options\n    )\n\n    const onPointerEnter = (enterEvent: PointerEvent) => {\n        if (!isValidHover(enterEvent)) return\n\n        const { target } = enterEvent\n        const onHoverEnd = onHoverStart(target as Element, enterEvent)\n\n        if (typeof onHoverEnd !== \"function\" || !target) return\n\n        const onPointerLeave = (leaveEvent: PointerEvent) => {\n            if (!isValidHover(leaveEvent)) return\n\n            onHoverEnd(leaveEvent)\n            target.removeEventListener(\n                \"pointerleave\",\n                onPointerLeave as EventListener\n            )\n        }\n\n        target.addEventListener(\n            \"pointerleave\",\n            onPointerLeave as EventListener,\n            eventOptions\n        )\n    }\n\n    elements.forEach((element) => {\n        element.addEventListener(\n            \"pointerenter\",\n            onPointerEnter as EventListener,\n            eventOptions\n        )\n    })\n\n    return cancel\n}\n"],"names":[],"mappings":";;;AAyBA,SAAS,YAAY,CAAC,KAAmB,EAAA;IACrC,OAAO,EAAE,KAAK,CAAC,WAAW,KAAK,OAAO,IAAI,YAAY,EAAE,CAAC,CAAA;AAC7D,CAAC;AAED;;;;;;AAMG;AACG,SAAU,KAAK,CACjB,iBAAoC,EACpC,YAA+B,EAC/B,UAAwB,EAAE,EAAA;AAE1B,IAAA,MAAM,CAAC,QAAQ,EAAE,YAAY,EAAE,MAAM,CAAC,GAAG,YAAY,CACjD,iBAAiB,EACjB,OAAO,CACV,CAAA;AAED,IAAA,MAAM,cAAc,GAAG,CAAC,UAAwB,KAAI;AAChD,QAAA,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC;YAAE,OAAM;AAErC,QAAA,MAAM,EAAE,MAAM,EAAE,GAAG,UAAU,CAAA;QAC7B,MAAM,UAAU,GAAG,YAAY,CAAC,MAAiB,EAAE,UAAU,CAAC,CAAA;AAE9D,QAAA,IAAI,OAAO,UAAU,KAAK,UAAU,IAAI,CAAC,MAAM;YAAE,OAAM;AAEvD,QAAA,MAAM,cAAc,GAAG,CAAC,UAAwB,KAAI;AAChD,YAAA,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC;gBAAE,OAAM;YAErC,UAAU,CAAC,UAAU,CAAC,CAAA;AACtB,YAAA,MAAM,CAAC,mBAAmB,CACtB,cAAc,EACd,cAA+B,CAClC,CAAA;AACL,SAAC,CAAA;QAED,MAAM,CAAC,gBAAgB,CACnB,cAAc,EACd,cAA+B,EAC/B,YAAY,CACf,CAAA;AACL,KAAC,CAAA;AAED,IAAA,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,KAAI;QACzB,OAAO,CAAC,gBAAgB,CACpB,cAAc,EACd,cAA+B,EAC/B,YAAY,CACf,CAAA;AACL,KAAC,CAAC,CAAA;AAEF,IAAA,OAAO,MAAM,CAAA;AACjB;;;;"}